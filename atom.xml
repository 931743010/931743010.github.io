<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zuik&#39;s blog</title>
  <subtitle>写点别人没写过的</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-05-05T02:16:42.540Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zuik</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS逆向：在任意app上开启malloc stack追踪内存来源</title>
    <link href="http://yoursite.com/2017/05/04/iOS%E9%80%86%E5%90%91%EF%BC%9A%E5%9C%A8%E4%BB%BB%E6%84%8Fapp%E4%B8%8A%E5%BC%80%E5%90%AFmalloc%20stack%E8%BF%BD%E8%B8%AA%E5%86%85%E5%AD%98%E6%9D%A5%E6%BA%90/"/>
    <id>http://yoursite.com/2017/05/04/iOS逆向：在任意app上开启malloc stack追踪内存来源/</id>
    <published>2017-05-04T12:49:00.000Z</published>
    <updated>2017-05-05T02:16:42.540Z</updated>
    
    <content type="html"><![CDATA[<p>lldb有一个内存调试工具malloc stack，开启以后就可以查看某个内存地址的malloc和free记录，追踪对象是在哪里创建的。</p>
<p>这个工具可以打印出对象创建的堆栈，而在逆向时，也经常需要追踪某些方法的调用栈，如果可以随时打印出某个对象的创建记录，也就能直接找到其所在的类和方法，不用再花费大量的时间去打log和动态调试追踪了。</p>
<h2 id="malloc-stack"><a href="#malloc-stack" class="headerlink" title="malloc stack"></a>malloc stack</h2><p>在自己的项目中，要开启malloc stack，需要在<code>Product-&gt;Scheme-&gt;Edit Scheme-&gt;Diagnistic</code>里勾选<code>Malloc Stack</code>选项。</p>
<p>效果如下：</p>
<p>测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (IBAction)create:(id)sender &#123;</div><div class="line">    NSString *testString = [NSString stringWithFormat:@&quot;string created by %@&quot;,self];</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>断点后在lldb中使用<code>lldb.macosx.heap</code>里的<code>malloc_info</code>命令，虽然官网上说是Mac app才能用的命令，但是经测试现在在iOS上也能用了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">(lldb) p/x testString</div><div class="line">(__NSCFString *) $3 = 0x16eac000 @&quot;string created by &lt;ViewController: 0x16e9d7c0&gt;&quot;</div><div class="line">(lldb) command script import lldb.macosx.heap</div><div class="line">&quot;malloc_info&quot;, &quot;ptr_refs&quot;, &quot;cstr_refs&quot;, &quot;find_variable&quot;, and &quot;objc_refs&quot; commands have been installed, use the &quot;--help&quot; options on these commands for detailed help.</div><div class="line">(lldb) malloc_info -s 0x16eac000</div><div class="line">0x0000000016eac000: malloc(    64) -&gt; 0x16eac000 __NSCFString.NSMutableString.NSString.NSObject.isa</div><div class="line">stack[0]: addr = 0x16eac000, type=malloc, frames:</div><div class="line">     [0] 0x00000000242948ab libsystem_malloc.dylib`malloc_zone_malloc + 123</div><div class="line">     [1] 0x00000000244e3bc1 CoreFoundation`_CFRuntimeCreateInstance + 237</div><div class="line">     [2] 0x00000000245a6ffd CoreFoundation`__CFStringCreateImmutableFunnel3 + 1657</div><div class="line">     [3] 0x00000000244ee0f7 CoreFoundation`CFStringCreateCopy + 359</div><div class="line">     [4] 0x00000000245a725d CoreFoundation`_CFStringCreateWithFormatAndArgumentsAux2 + 89</div><div class="line">     [5] 0x0000000024d17dd3 Foundation`-[NSPlaceholderString initWithFormat:locale:arguments:] + 139</div><div class="line">     [6] 0x0000000024d17cd1 Foundation`+[NSString stringWithFormat:] + 61</div><div class="line">     [7] 0x00000000000d7343 testMallocStack`-[ViewController create:] + 97 at ViewController.m:23:28</div><div class="line">     [8] 0x00000000287a5771 UIKit`-[UIApplication sendAction:to:from:forEvent:] + 81</div><div class="line">     [9] 0x00000000287a5701 UIKit`-[UIControl sendAction:to:forEvent:] + 65</div><div class="line">     [10] 0x000000002878d61f UIKit`-[UIControl _sendActionsForEvents:withEvent:] + 447</div><div class="line">     [11] 0x00000000287a5051 UIKit`-[UIControl touchesEnded:withEvent:] + 617</div><div class="line">     [12] 0x00000000287a4cbf UIKit`-[UIWindow _sendTouchesForEvent:] + 647</div><div class="line">     [13] 0x000000002879d5d7 UIKit`-[UIWindow sendEvent:] + 643</div><div class="line">     [14] 0x000000002876e119 UIKit`-[UIApplication sendEvent:] + 205</div><div class="line">     [15] 0x000000002876c757 UIKit`_UIApplicationHandleEventQueue + 5135</div><div class="line">     [16] 0x0000000024599257 CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 15</div><div class="line">     [17] 0x0000000024598e47 CoreFoundation`__CFRunLoopDoSources0 + 455</div><div class="line">     [18] 0x00000000245971af CoreFoundation`__CFRunLoopRun + 807</div><div class="line">     [19] 0x00000000244e9bb9 CoreFoundation`CFRunLoopRunSpecific + 517</div><div class="line">     [20] 0x00000000244e99ad CoreFoundation`CFRunLoopRunInMode + 109</div><div class="line">     [21] 0x0000000025763af9 GraphicsServices`GSEventRunModal + 161</div><div class="line">     [22] 0x00000000287d5fb5 UIKit`UIApplicationMain + 145</div><div class="line">     [23] 0x00000000000d7587 testMallocStack`main + 107 at main.m:14:9</div><div class="line">     [24] 0x000000002419c873 libdyld.dylib`start + 3</div><div class="line">     [25] 0x000000003a9c0001 libsystem_pthread.dylib`_thread + 1</div></pre></td></tr></table></figure>
<p>这个工具是继承自gdb的<code>malloc_history</code>，不过<code>malloc_history</code>只能用在模拟器上，而<code>malloc_info</code>在模拟器和真机上都可以使用。另外，新版Xcode又增加了一个新的lldb工具<code>memory history</code>，在<code>Product-&gt;Scheme-&gt;Edit Scheme-&gt;Diagnistic</code>里勾选<code>Address Sanitizer</code>即可，效果类似。</p>
<p>注意，在Xcode8.3以后使用<code>malloc_info</code>会crash，似乎是出bug了，一直没修复。在Xcode8.2上可以正常使用。</p>
<h2 id="在任意app上开启malloc-stack"><a href="#在任意app上开启malloc-stack" class="headerlink" title="在任意app上开启malloc stack"></a>在任意app上开启malloc stack</h2><p><code>Address Sanitizer</code>的<code>memory history</code>需要重新编译app，但是<code>malloc stack</code>只需要在app启动前设置环境变量<code>MallocStackLogging</code>和<code>MallocStackLoggingNoCompact</code>即可。开启后会在系统的<code>/tmp</code>目录下生成一个<code>.index</code>文件，这个文件里的内容是依赖于app的运行时环境的，进程退出以后这个文件也就没用处了。</p>
<p>那么，现在的问题就变成了如何给app设置启动环境变量。</p>
<h3 id="方法一：execve"><a href="#方法一：execve" class="headerlink" title="方法一：execve"></a>方法一：execve</h3><p>这是我一开始使用的方法。使用<code>execve</code>函数来运行app的二进制文件。</p>
<p>由于沙盒的限制，需要让app拥有root权限才能使用<code>execve</code>。步骤如下。</p>
<h4 id="1-重签名ipa"><a href="#1-重签名ipa" class="headerlink" title="1.重签名ipa"></a>1.重签名ipa</h4><p>重签名需要逆向的app。因为需要对app内容作出修改。重签名后安装到越狱设备上。</p>
<h4 id="2-移动app到系统app目录下，修改权限"><a href="#2-移动app到系统app目录下，修改权限" class="headerlink" title="2.移动app到系统app目录下，修改权限"></a>2.移动app到系统app目录下，修改权限</h4><p>只有系统目录下的app才有root权限。</p>
<p>假设需要逆向的app是<code>YOUR_APP.app</code>。把app移动到系统app目录下：<code>mv -f /var/containers/Bundle/Application/xxxxxxxxxxxxx/YOUR_APP.app /Applications/YOUR_APP.app</code>。</p>
<p>然后修改文件权限：</p>
<p><code>cd /Applications</code></p>
<p><code>chown -R root:wheel YOUR_APP.app</code></p>
<p><code>chmod 4755 YOUR_APP.app/YOUR_APP</code></p>
<p>移动后，用<code>uicache</code>刷新app图标，用<code>killall SpringBoard</code>重启<code>SpringBoard</code>。</p>
<h4 id="3-使用引导程序启动app"><a href="#3-使用引导程序启动app" class="headerlink" title="3.使用引导程序启动app"></a>3.使用引导程序启动app</h4><p>最终的目的就是使用引导程序用<code>execve</code>启动app，在启动前设置环境变量。</p>
<p>首先重命名原来的二进制文件：<code>mv YOUR_APP.app/YOUR_APP   YOUR_APP.app/YOUR_APP_Orig</code>。</p>
<p>然后制作引导程序，随便创建一个iOS工程，替换main.m里的内容为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        NSString* string = [[NSBundle mainBundle] pathForResource:@&quot;YOUR_APP_Orig&quot; ofType:nil];//YOUR_APP_Orig是所要启动的二进制文件名</div><div class="line">        argv[0] = (char*)[string UTF8String];</div><div class="line">        char *envp[] =</div><div class="line">        &#123;</div><div class="line">            &quot;HOME=/var/root&quot;,</div><div class="line">            &quot;LOGNAME=root&quot;,</div><div class="line">            &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/bin/X11:/usr/games&quot;,</div><div class="line">            &quot;USER=root&quot;,</div><div class="line">            &quot;MallocStackLogging=1&quot;,</div><div class="line">            &quot;MallocStackLoggingNoCompact=1&quot;</div><div class="line">            0</div><div class="line">        &#125;;</div><div class="line">        execve([string UTF8String], argv, envp);</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译后，取出二进制文件，重命名为<code>YOUR_APP</code>，复制到越狱设备的<code>/Application/YOUR_APP.app/</code>目录下。</p>
<p>给引导程序设置执行权限：<code>chmod +x /Application/YOUR_APP.app/YOUR_APP</code>。</p>
<p>最后重启SpringBoard：<code>killall SpringBoard</code>。</p>
<p>这样，每次启动app就都会使用引导程序间接启动app。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>步骤繁琐。</li>
<li>有些app重签名很麻烦。</li>
<li>越狱后的系统分区容量很小，很容易就被占满了，想要测试大一点的app就麻烦了。</li>
<li>无法使用<code>debugserver</code>唤醒app，调试启动过程。因为<code>YOUR_APP</code>和<code>YOUR_APP_Orig</code>是两个进程，第一个在<code>execve</code>执行完就退出了。</li>
<li>把app放到系统目录下有时候会引起crash。</li>
</ul>
<h3 id="方法2：debugserver参数"><a href="#方法2：debugserver参数" class="headerlink" title="方法2：debugserver参数"></a>方法2：debugserver参数</h3><p>方法1实在是太麻烦了，有时候遇上重签名失败的app就更麻烦了。但其实还有另一个更直接的方法。就是使用debugserver的命令。</p>
<p>debugserver是动态调试工具，参考：<a href="http://gslab.qq.com/article-159-1.html" target="_blank" rel="external">IOS平台lldb动态调试介绍</a>。</p>
<p>安装好后，在越狱设备上输入<code>debugserver *:1234 /var/containers/Bundle/Application/589822B6-BFDA-4A3D-A71C-AD0D30BA6077/WeChat.app/WeChat</code>就能唤醒app进行调试。</p>
<p>但是网上的教程都没有提到，其实debugserver还有一个隐藏的参数<code>--env</code>(<code>-env</code>,<code>-e</code>都可以)，就是用来设置进程的环境变量的：</p>
<p><code>debugserver *:1234 /var/containers/Bundle/Application/589822B6-BFDA-4A3D-A71C-AD0D30BA6077/WeChat.app/WeChat -env MallocStackLogging=1 -env MallocStackLoggingNoCompact=1</code></p>
<p>当时我想debugserver会不会有设置环境变量的功能，没想到随便试了个<code>-env</code>就成功了。后来在debugserver的源码里也发现了它的存在：<a href="https://llvm.org/svn/llvm-project/lldb/trunk/tools/debugserver/source/debugserver.cpp" target="_blank" rel="external">debugserver.cpp</a>（搜索<code>g_long_options</code>可以找到<code>env</code>）。</p>
<p>这样，即使app没有重签名，也可以直接调试了。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>这里使用一个重签名，并且恢复了符号表的微信进行测试。</p>
<p>比如找到微信查看表情的界面，打印出内存地址为<code>0x108795c20</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;MMEmoticonView: 0x108795c20; frame = (276.25 404.25; 215.5 215.5); autoresize = LM+RM+TM+BM; layer = &lt;CALayer: 0x170828700&gt;&gt;</div></pre></td></tr></table></figure>
<p>第一次使用<code>malloc_info</code>需要在lldb里导入<code>lldb.macosx.heap</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(lldb) command script import lldb.macosx.heap</div><div class="line">&quot;malloc_info&quot;, &quot;ptr_refs&quot;, &quot;cstr_refs&quot;, &quot;find_variable&quot;, and &quot;objc_refs&quot; commands have been installed, use the &quot;--help&quot; options on these commands for detailed help.</div></pre></td></tr></table></figure>
<p>使用<code>malloc_info</code>打印创建堆栈：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">(lldb) malloc_info -s 0x108795c20</div><div class="line">0x0000000108795c20: malloc(   480) -&gt; 0x108795c20 MMEmoticonView.UIView.UIResponder.NSObject.isa</div><div class="line">stack[0]: addr = 0x108795c20, type=malloc, frames:</div><div class="line">     [0] 0x000000018374e0ac libsystem_malloc.dylib`calloc + 40</div><div class="line">     [1] 0x000000018318b624 libobjc.A.dylib`class_createInstance + 76</div><div class="line">     [2] 0x0000000183199ae4 libobjc.A.dylib`_objc_rootAlloc + 52</div><div class="line">     [3] 0x00000001026d8fd4 WeChat`-[MMImageBrowseView InitEmoticonView:] + 432</div><div class="line">     [4] 0x000000010245e950 WeChat`-[MMEmotionMsgBrowseViewController initImageViewWithFrame:] + 404</div><div class="line">     [5] 0x000000010245ea74 WeChat`-[MMEmotionMsgBrowseViewController setupImageView] + 156</div><div class="line">     [6] 0x000000010245e024 WeChat`-[MMEmotionMsgBrowseViewController initView] + 224</div><div class="line">     [7] 0x000000010245d76c WeChat`-[MMEmotionMsgBrowseViewController viewDidLoad] + 112</div><div class="line">     [8] 0x000000018a5f7924 UIKit`-[UIViewController loadViewIfRequired] + 1056</div><div class="line">     [9] 0x000000018a60f4b4 UIKit`-[UIViewController __viewWillAppear:] + 132</div><div class="line">     [10] 0x00000001026e05f8 WeChat`-[MMUIViewController beginAppearanceTransition:animated:] + 92</div><div class="line">     [11] 0x000000018a7975b4 UIKit`-[UINavigationController _startCustomTransition:] + 1136</div><div class="line">     [12] 0x000000018a6afe74 UIKit`-[UINavigationController _startDeferredTransitionIfNeeded:] + 676</div><div class="line">     [13] 0x000000018a6afadc UIKit`-[UINavigationController __viewWillLayoutSubviews] + 64</div><div class="line">     [14] 0x000000018a6afa40 UIKit`-[UILayoutContainerView layoutSubviews] + 188</div><div class="line">     [15] 0x000000018a5f4a80 UIKit`-[UIView(CALayerDelegate) layoutSublayersOfLayer:] + 1196</div><div class="line">     [16] 0x0000000187aa29d8 QuartzCore`-[CALayer layoutSublayers] + 148</div><div class="line">     [17] 0x0000000187a974cc QuartzCore`CA::Layer::layout_if_needed(CA::Transaction*) + 292</div><div class="line">     [18] 0x0000000187a9738c QuartzCore`CA::Layer::layout_and_display_if_needed(CA::Transaction*) + 32</div><div class="line">     [19] 0x0000000187a143e0 QuartzCore`CA::Context::commit_transaction(CA::Transaction*) + 252</div><div class="line">     [20] 0x0000000187a3ba68 QuartzCore`CA::Transaction::commit() + 512</div><div class="line">     [21] 0x0000000187a3c488 QuartzCore`CA::Transaction::observer_callback(__CFRunLoopObserver*, unsigned long, void*) + 120</div><div class="line">     [22] 0x00000001846f60c0 CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__ + 32</div><div class="line">     [23] 0x00000001846f3cf0 CoreFoundation`__CFRunLoopDoObservers + 372</div><div class="line">     [24] 0x00000001846f4180 CoreFoundation`__CFRunLoopRun + 1024</div><div class="line">     [25] 0x00000001846222b8 CoreFoundation`CFRunLoopRunSpecific + 444</div><div class="line">     [26] 0x00000001860d6198 GraphicsServices`GSEventRunModal + 180</div><div class="line">     [27] 0x000000018a6627fc UIKit`-[UIApplication _run] + 684</div><div class="line">     [28] 0x000000018a65d534 UIKit`UIApplicationMain + 208</div><div class="line">     [29] 0x00000001000ebea4 WeChat`-[WATemplateMsgMngSwitchCell .cxx_destruct] + 372</div><div class="line">     [30] 0x00000001836055b8 libdyld.dylib`start + 4</div></pre></td></tr></table></figure>
<p>这样就直接找到表情界面所在的类，以及在哪里初始化了。</p>
<p>这样的话，只要能找到一个对象，就能快速定位到其所在模块。比原来打log，打断点一步步回溯高效多了。</p>
<h2 id="恢复符号表"><a href="#恢复符号表" class="headerlink" title="恢复符号表"></a>恢复符号表</h2><p>建议在对app重签名时恢复符号表。恢复符号表后，就能直接在堆栈中看到方法名，免去了计算偏移量然后在hopper里查找的麻烦。</p>
<p>参考：<a href="http://blog.imjun.net/posts/restore-symbol-of-iOS-app/" target="_blank" rel="external">iOS符号表恢复&amp;逆向支付宝</a>, <a href="https://github.com/tobefuturer/restore-symbol" target="_blank" rel="external">restore-symbol</a>。</p>
<h2 id="其他几个调试命令"><a href="#其他几个调试命令" class="headerlink" title="其他几个调试命令"></a>其他几个调试命令</h2><h3 id="ptr-refs"><a href="#ptr-refs" class="headerlink" title="ptr_refs"></a>ptr_refs</h3><p>可以在内存中找出哪些地址引用了某个指针，也就相当于查看某个变量在哪里被引用。</p>
<h3 id="cstr-refs"><a href="#cstr-refs" class="headerlink" title="cstr_refs"></a>cstr_refs</h3><p>在内存中寻找某个C String在哪里被引用。</p>
<h3 id="find-variable"><a href="#find-variable" class="headerlink" title="find_variable"></a>find_variable</h3><p>在当前栈帧上寻找某个局部变量在哪里被引用。</p>
<h3 id="objc-refs"><a href="#objc-refs" class="headerlink" title="objc_refs"></a>objc_refs</h3><p>在内存中寻找某个类的实例。</p>
<h2 id="转到Xcode中调试"><a href="#转到Xcode中调试" class="headerlink" title="转到Xcode中调试"></a>转到Xcode中调试</h2><p>如果想要在Xcode中调试并开启<code>malloc stack</code>，则需要先用<code>debugserver</code>启动app，在终端的lldb里连接上以后，再用<code>process detach</code>断开连接。接下来用Xcode的<code>Attach to Process</code>就可以了，参考：<a href="https://zuikyo.github.io/2017/05/04/iOS逆向：用Xcode直接调试第三方app/" target="_blank" rel="external">iOS逆向：用Xcode直接调试第三方app</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;lldb有一个内存调试工具malloc stack，开启以后就可以查看某个内存地址的malloc和free记录，追踪对象是在哪里创建的。&lt;/p&gt;
&lt;p&gt;这个工具可以打印出对象创建的堆栈，而在逆向时，也经常需要追踪某些方法的调用栈，如果可以随时打印出某个对象的创建记录，也就能
    
    </summary>
    
      <category term="逆向工程" scheme="http://yoursite.com/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS逆向：用Xcode直接调试第三方app</title>
    <link href="http://yoursite.com/2017/05/04/iOS%E9%80%86%E5%90%91%EF%BC%9A%E7%94%A8Xcode%E7%9B%B4%E6%8E%A5%E8%B0%83%E8%AF%95%E7%AC%AC%E4%B8%89%E6%96%B9app/"/>
    <id>http://yoursite.com/2017/05/04/iOS逆向：用Xcode直接调试第三方app/</id>
    <published>2017-05-04T12:48:00.000Z</published>
    <updated>2017-05-05T02:19:48.950Z</updated>
    
    <content type="html"><![CDATA[<p>一般动态调试app时，都是在终端里用lldb直接调试，但是用Xcode的<code>Attach to Process</code>也可以连接到真机上的进程进行调试。但是只能调试用自己的证书签名的app。</p>
<p>在Xcode上调试的优点：</p>
<ul>
<li>有UI界面，查看堆栈更直接，可以用Xcode打断点。</li>
<li>可以使用<code>debug gauges</code>里的Disk和Network等工具。</li>
<li>输入lldb命令时有自动补全。</li>
<li>可以使用Xcode的<code>Debug UI Hierarchy</code>功能，直接查看app的界面布局。</li>
<li>可以使用Xcode的<code>Debug Memory Graph</code>功能，查看当前内存中存在的所有对象，以及对象之间的引用关系。</li>
</ul>
<p>步骤如下。</p>
<h2 id="1-重签名需要逆向的app"><a href="#1-重签名需要逆向的app" class="headerlink" title="1.重签名需要逆向的app"></a>1.重签名需要逆向的app</h2><p>重签名后才能用Xcode attach。而重签名前需要对app进行砸壳。这些步骤就不再重复了。</p>
<p>额外说一句，在砸壳后建议进行一下恢复符号表的操作。恢复符号表后，在调试时就能直接在堆栈中看到方法名，免去了计算偏移量然后在hopper里查找的麻烦。参考：<a href="http://blog.imjun.net/posts/restore-symbol-of-iOS-app/" target="_blank" rel="external">iOS符号表恢复&amp;逆向支付宝</a>, <a href="https://github.com/tobefuturer/restore-symbol" target="_blank" rel="external">restore-symbol</a>。</p>
<h2 id="2-Attach-to-Process"><a href="#2-Attach-to-Process" class="headerlink" title="2.Attach to Process"></a>2.Attach to Process</h2><p>重签名后安装到越狱设备上，启动app，在Xcode中随便打开一个工程，选择越狱设备，就可以在<code>Debug-&gt;Attach to Process</code>中找到正在运行的进程名和进程id，点击后就会开始连接。大概过1分钟就会连接上。</p>
<h2 id="3-查看UI"><a href="#3-查看UI" class="headerlink" title="3.查看UI"></a>3.查看UI</h2><p>连接上后，就可以点击使用Xcode的<code>Debug UI Hierarchy</code>来查看界面布局：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1865432-b3652b738ff07228.jpg" alt="UI Hierarchy"></p>
<p>注意，<code>Debug UI Hierarchy</code>对Xcode版本似乎有要求，在调试重签名app时，Xcode8.3.2可以，而Xcode8.2就没有这个功能按钮。</p>
<h2 id="4-查看内存信息"><a href="#4-查看内存信息" class="headerlink" title="4.查看内存信息"></a>4.查看内存信息</h2><p>点击<code>Debug Memory Graph</code>按钮，可以查看当前内存中存在的数据。打印地址，查看引用关系，可以配合<code>malloc stack</code>进行追踪。如果打开了<code>malloc stack</code>，就可以直接在右边显示这个对象的创建堆栈。参考：<a href="https://zuikyo.github.io/2017/05/04/iOS逆向：在任意app上开启malloc%20stack追踪内存来源/" target="_blank" rel="external">iOS逆向：在任意app上开启malloc%20stack追踪内存来源</a>。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1865432-d599a5233b28e245.jpg" alt="Memory Graph"></p>
<h2 id="5-查看正在使用的文件"><a href="#5-查看正在使用的文件" class="headerlink" title="5.查看正在使用的文件"></a>5.查看正在使用的文件</h2><p><code>debug gauges</code>中的Disk工具可以查看app当前打开的文件。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1865432-80d24111380e2e44.jpg" alt="Open Files"></p>
<h2 id="5-instrument调试"><a href="#5-instrument调试" class="headerlink" title="5.instrument调试"></a>5.instrument调试</h2><p>类似的，也可以用instrument调试重签名后的app，不过并不是所有工具都可以使用，对逆向的帮助不大。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般动态调试app时，都是在终端里用lldb直接调试，但是用Xcode的&lt;code&gt;Attach to Process&lt;/code&gt;也可以连接到真机上的进程进行调试。但是只能调试用自己的证书签名的app。&lt;/p&gt;
&lt;p&gt;在Xcode上调试的优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
    
    </summary>
    
      <category term="逆向工程" scheme="http://yoursite.com/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>私有API-修复iOS10不弹出&quot;是否允许xxx访问数据&quot;导致app无法联网的bug</title>
    <link href="http://yoursite.com/2017/02/05/%E7%A7%81%E6%9C%89API-%E4%BF%AE%E5%A4%8DiOS%2010%E4%B8%8D%E5%BC%B9%E5%87%BA%E6%98%AF%E5%90%A6%E5%85%81%E8%AE%B8xxx%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%87%B4app%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91%E7%9A%84bug/"/>
    <id>http://yoursite.com/2017/02/05/私有API-修复iOS 10不弹出是否允许xxx访问数据导致app无法联网的bug/</id>
    <published>2017-02-05T15:38:00.000Z</published>
    <updated>2017-05-03T08:32:26.330Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>iOS 10有一个系统bug：app在第一次安装时，第一次联网操作会弹出一个授权框，提示”是否允许xxx访问数据？”。而有时候系统并不会弹出授权框，导致app无法联网。</p>
<p>详细情况见：</p>
<p><a href="http://www.jianshu.com/p/6cbde1b8b922" target="_blank" rel="external">iOS 10 的坑：新机首次安装 app，请求网络权限“是否允许使用数据”</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/22738261" target="_blank" rel="external">iOS 10 不提示「是否允许应用访问数据」，导致应用无法使用的解决方案</a></p>
<p>关键点总结：</p>
<ul>
<li>只有iOS 10以上、国行机型、有蜂窝网络功能的设备存在这个授权问题，WiFi版的iPad没有这个问题；</li>
<li>由于授权框是在有网络操作时才弹出的，这就导致app第一次网络访问必定失败；</li>
<li>当出现不弹出授权框的bug时，去设置里更改任意app的蜂窝网络权限，或者打开无线局域网助理，让系统更新一下蜂窝网络相关的数据，可以解决这个bug。</li>
</ul>
<p>这个系统bug出现时，对用户来说是很麻烦的，app也需要提供详细的提示语来应对这种情况，十分不优雅。</p>
<h1 id="修复方法"><a href="#修复方法" class="headerlink" title="修复方法"></a>修复方法</h1><p>春节有点空，找到了几个相关的私有API来修复这个bug。</p>
<h2 id="弹出授权框"><a href="#弹出授权框" class="headerlink" title="弹出授权框"></a>弹出授权框</h2><p>首先找到的是一个能直接弹出授权框的API。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//Image: /System/Library/PrivateFrameworks/FTServices.framework/FTServices</div><div class="line"></div><div class="line">@interface FTNetworkSupport : NSObject</div><div class="line">+ (id)sharedInstance;</div><div class="line">- (bool)dataActiveAndReachable;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>头文件参考：<a href="https://github.com/JaviSoto/iOS10-Runtime-Headers/blob/master/PrivateFrameworks/FTServices.framework/FTNetworkSupport.h" target="_blank" rel="external">FTNetworkSupport.h</a></p>
<p>当app之前没有请求过网络权限时，调用<code>dataActiveAndReachable</code>会弹出”是否允许xxx访问数据？”的授权框，如果网络权限已经确定，则不会弹出。</p>
<h3 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h3><p>由于<code>FTNetworkSupport</code>是在<code>PrivateFrameworks</code>目录下，app并没有加载这个库，所以要使用里面的类前，需要用<code>dlopen</code>加载<code>FTServices.framework</code>,简单示意如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#import &lt;dlfcn.h&gt;</div><div class="line"></div><div class="line">//加载FTServices.framework</div><div class="line">void * FTServicesHandle = dlopen(&quot;/System/Library/PrivateFrameworks/FTServices.framework/FTServices&quot;, RTLD_LAZY);</div><div class="line">Class NetworkSupport = NSClassFromString(@&quot;FTNetworkSupport&quot;);</div><div class="line">id networkSupport = [NetworkSupport performSelector:NSSelectorFromString(@&quot;sharedInstance&quot;)];</div><div class="line">[networkSupport performSelector:NSSelectorFromString(@&quot;dataActiveAndReachable&quot;)];</div><div class="line">//卸载FTServices.framework</div><div class="line">dlclose(FTServicesHandle);</div></pre></td></tr></table></figure>
<p>这个API能解决网络权限导致第一个联网操作失败的问题，但是它还是存在有时候不会弹出授权框的bug。</p>
<h2 id="让系统更新蜂窝网络权限数据"><a href="#让系统更新蜂窝网络权限数据" class="headerlink" title="让系统更新蜂窝网络权限数据"></a>让系统更新蜂窝网络权限数据</h2><p>既然更改任意app的蜂窝网络权限后，能让app弹出授权框，那么只要找到一个方法，能让系统更新一下网络权限相关的数据就可以了。</p>
<p>用<code>hopper</code>反编译一下系统的设置app用到的库<code>PreferencesUI.framework</code>，找到了里面修改app网络权限的API。用到的是<code>CoreTelephony.framework</code>里的两个私有C函数：</p>
<p><code>CTServerConnection* _CTServerConnectionCreateOnTargetQueue(CFAllocatorRef, NSString *, dispatch_queue_t, void*/*一个block类型的参数*/)</code></p>
<p><code>void _CTServerConnectionSetCellularUsagePolicy(CTServerConnection *, NSString *, NSDictionary *)</code></p>
<p>大部分时间都花在测试这两个函数上了。几个月前我也研究过这两个函数尝试修复这个bug，但是那时候发现没什么作用，就不了了之了。</p>
<h3 id="调用方式-1"><a href="#调用方式-1" class="headerlink" title="调用方式"></a>调用方式</h3><p>要调用私有C函数，需要用<code>dlsym</code>，简单示意如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">void *CoreTelephonyHandle = dlopen(&quot;/System/Library/Frameworks/CoreTelephony.framework/CoreTelephony&quot;, RTLD_LAZY);</div><div class="line"></div><div class="line">//用函数指针来调用私有C函数，用符号名从库里寻找函数地址</div><div class="line">CFTypeRef (*connectionCreateOnTargetQueue)(CFAllocatorRef, NSString *, dispatch_queue_t, void*) = dlsym(CoreTelephonyHandle, &quot;_CTServerConnectionCreateOnTargetQueue&quot;);</div><div class="line">int (*changeCellularPolicy)(CFTypeRef, NSString *, NSDictionary *) = dlsym(CoreTelephonyHandle, &quot;_CTServerConnectionSetCellularUsagePolicy&quot;);</div><div class="line"></div><div class="line">//使用设置app的bundle id进行伪装</div><div class="line">CFTypeRef connection = connectionCreateOnTargetQueue(kCFAllocatorDefault,@&quot;com.apple.Preferences&quot;,dispatch_get_main_queue(),NULL);</div><div class="line">//请求修改本app的网络权限为allowed，不会真的修改，只能触发系统更新一下相关的数据</div><div class="line">changeCellularPolicy(connection, @&quot;需要授权的app的bundle id&quot;, @&#123;@&quot;kCTCellularUsagePolicyDataAllowed&quot;:@YES&#125;);</div><div class="line"></div><div class="line">dlclose(CoreTelephonyHandle);</div></pre></td></tr></table></figure>
<p>注意，在声明connectionCreateOnTargetQueue和changeCellularPolicy函数指针时，参数类型要严格对应，如果类型错误，可能会导致系统对参数执行错误的内存管理，出现crash。<code>CTServerConnection</code>是私有的，是<code>CFTypeRef</code>的子类，所以这里可以用<code>CFTypeRef</code>来代替。</p>
<h3 id="出现了玄学"><a href="#出现了玄学" class="headerlink" title="出现了玄学"></a>出现了玄学</h3><p><code>_CTServerConnectionSetCellularUsagePolicy</code>函数的第二个参数是需要修改的app的bundle id。在测试时，发现传入这个参数时，对象必须是用字面量语法创建的<code>NSString</code>，例如<code>@&quot;com.who.testDemo&quot;</code>，当传入<code>[NSBundle mainBundle].bundleIdentifier</code>这种动态生成的<code>NSString</code>时，仍然会出现不弹出授权框的bug，也就是并没有修复成功。连续测试5-10次就能重现。</p>
<p>不过，用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSMutableString *bundleIdentifier = [NSMutableString stringWithString:@&quot;com.who&quot;];</div><div class="line">[bundleIdentifier appendString:@&quot;.testDemo&quot;];</div></pre></td></tr></table></figure>
<p>这样的字符串也没问题。相同点是最终都是来自字面量语法创建的<code>NSString</code>。</p>
<p>这个玄学问题目前还没有找到原因。</p>
<p>研究了一下字面量创建出的<code>NSString</code>，的确是有些特殊的。参考：<a href="http://bou.io/ConstantStringsInObjC.html" target="_blank" rel="external">Constant Strings in Objective-C</a>。它是一个<code>__NSCFConstantString</code>类型的字符串，在app的整个生命周期内，这个对象的内存都不会被释放。难道iOS的XPC对使用到的字符串还有要求？</p>
<p>时间有限，这个问题以后再研究吧。</p>
<h2 id="用控制台跟踪进程间通信"><a href="#用控制台跟踪进程间通信" class="headerlink" title="用控制台跟踪进程间通信"></a><a name="debug-trace"></a>用控制台跟踪进程间通信</h2><p>这几个私有API都用了进程间通信，要进行调试跟踪有点麻烦。</p>
<p>可以使用Mac上的控制台查看设备的实时log，寻找通信行为。打开控制台app，在左侧选择连接到Mac的iOS设备，就可以看到设备log了。</p>
<p>下面是调用了<code>_CTServerConnectionSetCellularUsagePolicy</code>之后的log，传入bundle id时用的是字面量创建的字符串：<br><img src="http://upload-images.jianshu.io/upload_images/1865432-e5eec32d03c2fa7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用字面量字符串传入bundle id"><br>高亮的那行是测试demo打的log，可以认为就是在这里调用了<code>_CTServerConnectionSetCellularUsagePolicy</code>，<br>可以看到，调用之后系统更新了本app的权限状态。<code>CommCenter</code>就是这几个私有API通信的对应进程，用于管理设备的网络。参考<a href="https://www.theiphonewiki.com/wiki//System/Library/Frameworks/CoreTelephony.Framework/Support/CommCenter" target="_blank" rel="external">CommCenter - The iPhone Wiki</a>。</p>
<p>下面是用<code>[NSBundle mainBundle].bundleIdentifier</code>传入<code>_CTServerConnectionSetCellularUsagePolicy</code>的第二个参数时的log：<br><img src="http://upload-images.jianshu.io/upload_images/1865432-87dfca01425cbad0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用动态创建的字符串传入bundle id"><br>没有看到系统更新app权限的相关log，进程间通信可能失败了。因此可以确定，使用<code>_CTServerConnectionSetCellularUsagePolicy</code>时必须传入字面量语法创建的字符串。</p>
<h1 id="检查网络权限情况"><a href="#检查网络权限情况" class="headerlink" title="检查网络权限情况"></a>检查网络权限情况</h1><p>由于<code>dataActiveAndReachable</code>里面有异步操作，所以不能立即用<code>dlclose</code>卸载<code>FTServices.framework</code>。解决方法是监听到蜂窝权限开启时再卸载。</p>
<p><code>CoreTelephony</code>里的<code>CTCellularData</code>可以用来监测app的蜂窝网络权限，并且这不是个私有API。你也可以用它来帮助用户检测蜂窝权限是否被关闭，并给出提示，防止出现用户关了网络权限导致app无法联网的情况。</p>
<p><code>CTCellularData</code>的头文件如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSUInteger, CTCellularDataRestrictedState) &#123;</div><div class="line">	kCTCellularDataRestrictedStateUnknown,//权限未知</div><div class="line">	kCTCellularDataRestricted,//蜂窝权限被关闭，有 网络权限完全关闭 or 只有WiFi权限 两种情况</div><div class="line">	kCTCellularDataNotRestricted//蜂窝权限开启</div><div class="line">&#125;;</div><div class="line"></div><div class="line">@interface CTCellularData : NSObject</div><div class="line">///权限更改时的回调</div><div class="line">@property (copy, nullable) CellularDataRestrictionDidUpdateNotifier cellularDataRestrictionDidUpdateNotifier;</div><div class="line">///当前的蜂窝权限</div><div class="line">@property (nonatomic, readonly) CTCellularDataRestrictedState restrictedState;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>使用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#import &lt;CoreTelephony/CTCellularData.h&gt;</div><div class="line"></div><div class="line">CTCellularData *cellularDataHandle = [[CTCellularData alloc] init];</div><div class="line">cellularDataHandle.cellularDataRestrictionDidUpdateNotifier = ^(CTCellularDataRestrictedState state) &#123;</div><div class="line">        //蜂窝权限更改时的回调</div><div class="line">    &#125;;</div></pre></td></tr></table></figure>
<p>使用时需要注意的关键点：</p>
<ul>
<li><code>CTCellularData</code>只能检测蜂窝权限，不能检测WiFi权限。</li>
<li>一个<code>CTCellularData</code>实例新建时，<code>restrictedState</code>是<code>kCTCellularDataRestrictedStateUnknown</code>，之后在<code>cellularDataRestrictionDidUpdateNotifier</code>里会有一次回调，此时才能获取到正确的权限状态。</li>
<li>当用户在设置里更改了app的权限时，<code>cellularDataRestrictionDidUpdateNotifier</code>会收到回调，如果要停止监听，必须将<code>cellularDataRestrictionDidUpdateNotifier</code>设置为<code>nil</code>。</li>
<li>赋值给<code>cellularDataRestrictionDidUpdateNotifier</code>的block并不会自动释放，即便你给一个局部变量的<code>CTCellularData</code>实例设置监听，当权限更改时，还是会收到回调，所以记得将block置<code>nil</code>。</li>
</ul>
<h1 id="检测国行机型和是否有蜂窝功能"><a href="#检测国行机型和是否有蜂窝功能" class="headerlink" title="检测国行机型和是否有蜂窝功能"></a>检测国行机型和是否有蜂窝功能</h1><p>非国行机型，以及没有蜂窝功能的设备是不需要进行修复的。因此也要寻找相关的私有API进行检测。</p>
<p>用到的私有API如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//Image: /System/Library/PrivateFrameworks/AppleAccount.framework/AppleAccount</div><div class="line"></div><div class="line">@interface AADeviceInfo : NSObject</div><div class="line">///是否有蜂窝功能</div><div class="line">- (bool)hasCellularCapability;</div><div class="line">///设备的区域代码，例如国行机就是CH</div><div class="line">- (id)regionCode;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>头文件参考：<a href="https://github.com/JaviSoto/iOS10-Runtime-Headers/blob/master/PrivateFrameworks/AppleAccount.framework/AADeviceInfo.h" target="_blank" rel="external">AADeviceInfo.h</a></p>
<p>使用方式和<code>FTServices.framework</code>类似，不再重复。</p>
<h1 id="测试修复是否成功的方法"><a href="#测试修复是否成功的方法" class="headerlink" title="测试修复是否成功的方法"></a>测试修复是否成功的方法</h1><p>我的测试方式是每次运行都修改项目的<code>bundle identifier</code>和<code>display name</code>，让系统每次都把它当做一个新app，使用<code>Release</code>模式，测试是否每次都能够弹出授权框。由于需要不断修改<code>bundle identifier</code>，写了个脚本在每次build时自动运行，会自动累加几个地方的<code>bundle identifier</code>后面的数字。demo里已经附带了这个脚本。</p>
<p>你也可以测试一下不执行修复时，进行联网操作是否会弹出授权框。我的测试结果是大约运行5-10次时，就会出现不弹出授权框的bug。需要把项目改为<code>Release</code>模式才能出现，<code>Debug</code>模式下不会出bug。</p>
<p>注意，由于build后自动累加的关系，<code>ZIKCellularAuthorization.h</code>里的<code>AppBundleIdentifier</code>是下一次app运行时的值。如果你觉得这个脚本把你搞晕了，可以在<code>Build Phases/Run Script</code>里关掉，在<code>sh ${PROJECT_DIR}/IncreaseBundleId.sh</code>前面加个<code>#</code>注释掉就行了。</p>
<p>没有测试覆盖安装同一个<code>bundle identifier</code>的app，或者更新了版本号的app是否也会出现这个bug，现在是认为只有第一次安装时才会出现bug。</p>
<h1 id="工具代码和Demo"><a href="#工具代码和Demo" class="headerlink" title="工具代码和Demo"></a>工具代码和Demo</h1><p>地址在<a href="https://github.com/Zuikyo/ZIKCellularAuthorization" target="_blank" rel="external">ZIKCellularAuthorization</a>，用到的私有API已经经过混淆。测试前记得先把<code>Build Configuration</code>改为<code>Release</code>模式。有帮助请点个Star~</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.jianshu.com/p/6cbde1b8b922" target="_blank" rel="external">iOS 10 的坑：新机首次安装 app，请求网络权限“是否允许使用数据”</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/22738261" target="_blank" rel="external">iOS 10 不提示「是否允许应用访问数据」，导致应用无法使用的解决方案</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;iOS 10有一个系统bug：app在第一次安装时，第一次联网操作会弹出一个授权框，提示”是否允许xxx访问数据？”。而有时
    
    </summary>
    
      <category term="私有API" scheme="http://yoursite.com/categories/%E7%A7%81%E6%9C%89API/"/>
    
      <category term="bug修复" scheme="http://yoursite.com/categories/%E7%A7%81%E6%9C%89API/bug%E4%BF%AE%E5%A4%8D/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS Crash分析必备：符号化系统库方法</title>
    <link href="http://yoursite.com/2016/12/18/iOS%20Crash%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%BF%85%E5%A4%87%EF%BC%9A%E7%AC%A6%E5%8F%B7%E5%8C%96%E7%B3%BB%E7%BB%9F%E5%BA%93%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2016/12/18/iOS Crash日志分析必备：符号化系统库方法/</id>
    <published>2016-12-17T20:52:00.000Z</published>
    <updated>2017-05-03T08:47:03.780Z</updated>
    
    <content type="html"><![CDATA[<p>如果你有过分析iOS崩溃日志的经验，一定经常看到日志里出现很多<code>&lt;redacted&gt;</code>的字段。这篇文章就是帮助开发者将这些字段符号化为对应的系统库方法名。</p>
<p>如果你已经掌握了这方面的知识，就直接去下面的<a href="#wang-pan">网盘下载地址</a>目录，下载我整理好的系统库符号文件吧。</p>
<h2 id="符号化的作用"><a href="#符号化的作用" class="headerlink" title="符号化的作用"></a>符号化的作用</h2><p>当获取到app的crash日志时，第一步就是将其符号化。作用是把日志堆栈中的方法调用显示出来，对于来自app内部的方法，还能直接给出方法对应.m文件的所在行。</p>
<p>符号化前（这里项目的<code>Build Settings</code>里的<code>Strip Style</code>设为了<code>Debugging Symbols</code>，所以这里能直接看到<code>MyApp</code>的方法名。更多和symbol相关的设置，请看<a href="http://www.jianshu.com/p/11710e7ab661" target="_blank" rel="external">这里</a>）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Thread 7:</div><div class="line">0   libsystem_kernel.dylib          0x000000018efb416c 0x18efb3000 + 4460 (mach_msg_trap + 8)</div><div class="line">1   libsystem_kernel.dylib          0x000000018efb3fdc 0x18efb3000 + 4060 (mach_msg + 72)</div><div class="line">2   MyApp                           0x000000010091e558 0x1000bc000 + 8791384 (ksmachexc_i_handleExceptions + 148)</div><div class="line">3   libsystem_pthread.dylib         0x000000018f097860 0x18f094000 + 14432 (&lt;redacted&gt; + 240)</div><div class="line">4   libsystem_pthread.dylib         0x000000018f097770 0x18f094000 + 14192 (_pthread_start + 284)</div></pre></td></tr></table></figure>
<p>符号化后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Thread 7:</div><div class="line">0   libsystem_kernel.dylib          0x000000018efb416c mach_msg_trap + 8</div><div class="line">1   libsystem_kernel.dylib          0x000000018efb3fdc mach_msg + 72</div><div class="line">2   MyApp                           0x000000010091e558 ksmachexc_i_handleExceptions (KSCrashSentry_MachException.c:233)</div><div class="line">3   libsystem_pthread.dylib         0x000000018f097860 _pthread_body + 240</div><div class="line">4   libsystem_pthread.dylib         0x000000018f097770 _pthread_body + 0</div></pre></td></tr></table></figure>
<p>可以发现，frame 3里<code>libsystem_pthread.dylib</code>的<code>&lt;redacted&gt;</code>变成了<code>_pthread_body</code>，frame 2里<code>MyApp</code>的<code>ksmachexc_i_handleExceptions</code>变成了更为完整的<code>ksmachexc_i_handleExceptions (KSCrashSentry_MachException.c:233)</code>，直接给出了方法及其所在文件和行数。</p>
<p>详细的符号化方法，请参考<a href="http://wufawei.com/2014/03/symbolicating-ios-crash-logs/" target="_blank" rel="external">符号化iOS Crash文件的3种方法</a>。这里就不重复了。</p>
<p>需要注意的是，很多时候，crash日志里并不会有MyApp的调用，而全都是系统库的调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Thread 0 name:  Dispatch queue: com.apple.main-thread</div><div class="line">Thread 0 Crashed:</div><div class="line">0   libobjc.A.dylib                 0x000000018b816f30 0x18b7fc000 + 110384 (objc_msgSend + 16)</div><div class="line">1   UIKit                           0x0000000192e0a79c 0x192c05000 + 2119580 (&lt;redacted&gt; + 72)</div><div class="line">2   UIKit                           0x0000000192c4db48 0x192c05000 + 297800 (&lt;redacted&gt; + 312)</div><div class="line">3   UIKit                           0x0000000192c4d988 0x192c05000 + 297352 (&lt;redacted&gt; + 160)</div><div class="line">4   QuartzCore                      0x00000001900d6404 0x18ffc5000 + 1119236 (&lt;redacted&gt; + 260)</div><div class="line">5   libdispatch.dylib               0x000000018bc551c0 0x18bc54000 + 4544 (&lt;redacted&gt; + 16)</div><div class="line">6   libdispatch.dylib               0x000000018bc59d6c 0x18bc54000 + 23916 (_dispatch_main_queue_callback_4CF + 1000)</div><div class="line">7   CoreFoundation                  0x000000018cd79f2c 0x18cc9d000 + 905004 (&lt;redacted&gt; + 12)</div><div class="line">8   CoreFoundation                  0x000000018cd77b18 0x18cc9d000 + 895768 (&lt;redacted&gt; + 1660)</div><div class="line">9   CoreFoundation                  0x000000018cca6048 0x18cc9d000 + 36936 (CFRunLoopRunSpecific + 444)</div><div class="line">10  GraphicsServices                0x000000018e729198 0x18e71d000 + 49560 (GSEventRunModal + 180)</div><div class="line">11  UIKit                           0x0000000192c80628 0x192c05000 + 505384 (&lt;redacted&gt; + 684)</div><div class="line">12  UIKit                           0x0000000192c7b360 0x192c05000 + 484192 (UIApplicationMain + 208)</div><div class="line">13  MyApp                           0x0000000100016e54 0x100004000 + 77396 (_mh_execute_header + 77396)</div><div class="line">14  libdyld.dylib                   0x000000018bc885b8 0x18bc84000 + 17848 (&lt;redacted&gt; + 4)</div></pre></td></tr></table></figure>
<p>这时候就必须符号化系统库了。符号化后的日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Thread 0 name:  Dispatch queue: com.apple.main-thread</div><div class="line">Thread 0 Crashed:</div><div class="line">0   libobjc.A.dylib                 0x000000018b816f30 objc_msgSend + 16</div><div class="line">1   UIKit                           0x0000000192e0a79c -[UISearchDisplayController _sendDelegateDidBeginDidEndSearch] + 72</div><div class="line">2   UIKit                           0x0000000192c4db48 -[UIViewAnimationState sendDelegateAnimationDidStop:finished:] + 312</div><div class="line">3   UIKit                           0x0000000192c4d988 -[UIViewAnimationState animationDidStop:finished:] + 160</div><div class="line">4   QuartzCore                      0x00000001900d6404 CA::Layer::run_animation_callbacks(void*) + 260</div><div class="line">5   libdispatch.dylib               0x000000018bc551c0 _dispatch_client_callout + 16</div><div class="line">6   libdispatch.dylib               0x000000018bc59d6c _dispatch_main_queue_callback_4CF + 1000</div><div class="line">7   CoreFoundation                  0x000000018cd79f2c __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__ + 12</div><div class="line">8   CoreFoundation                  0x000000018cd77b18 __CFRunLoopRun + 1660</div><div class="line">9   CoreFoundation                  0x000000018cca6048 CFRunLoopRunSpecific + 444</div><div class="line">10  GraphicsServices                0x000000018e729198 GSEventRunModal + 180</div><div class="line">11  UIKit                           0x0000000192c80628 -[UIApplication _run] + 684</div><div class="line">12  UIKit                           0x0000000192c7b360 UIApplicationMain + 208</div><div class="line">13  MyApp                           0x0000000100016e54 main (main.m:15)</div><div class="line">14  libdyld.dylib                   0x000000018bc885b8 start + 4</div></pre></td></tr></table></figure>
<p>可以看出是<code>UISearchController</code>的<code>delegate</code>导致的问题，检查一下就发现<code>UISearchDisplayController</code>的<code>delegate</code>是<code>assign</code>的，是由于点击搜索条的同时pop了界面导致的crash。</p>
<p>从这里可以发现，符号化系统库是很有必要的。</p>
<p>##如何符号化系统库</p>
<p>符号化自己app的方法名，需要编译ipa时生成的dySYM文件。而要将系统库的<code>&lt;redacted&gt;</code>符号化为完整的方法名，也需要系统库的符号文件。</p>
<h3 id="1-匹配对应的符号文件版本"><a href="#1-匹配对应的符号文件版本" class="headerlink" title="1. 匹配对应的符号文件版本"></a>1. 匹配对应的符号文件版本</h3><p>系统库符号文件不是通用的，而是对应crash所在设备的系统版本和CPU型号的。</p>
<p>crash日志中有这样两个信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Code Type:       ARM-64</div><div class="line">OS Version:      iOS 10.2 (14C82)</div></pre></td></tr></table></figure>
<p><code>Code Type</code>表示此设备的CPU为<code>armv7</code>、<code>armv7s</code>还是<code>arm64</code>。</p>
<p><code>OS Version</code>表示此设备的系统版本号，括号中的字符串代表了此系统的build号。可以在这里查找build号：<a href="https://en.wikipedia.org/wiki/IOS_SDK" target="_blank" rel="external">iOS SDK</a>，<a href="https://en.wikipedia.org/wiki/IOS_version_history#iOS_10" target="_blank" rel="external">iOS version history</a>。</p>
<h3 id="2-将对应版本的符号文件放到指定目录"><a href="#2-将对应版本的符号文件放到指定目录" class="headerlink" title="2. 将对应版本的符号文件放到指定目录"></a>2. 将对应版本的符号文件放到指定目录</h3><p>这时候，把获取到的对应版本的符号文件放到Mac的<code>~/Library/Developer/Xcode/iOS DeviceSupport</code>目录下，再使用<a href="http://wufawei.com/2014/03/symbolicating-ios-crash-logs/" target="_blank" rel="external">符号化iOS Crash文件的3种方法</a>里提到的Xcode自带的符号化工具<code>symbolicatecrash</code>进行符号化。这个工具会自动搜索系统库符号文件。</p>
<h2 id="获取系统符号文件的4个方法"><a href="#获取系统符号文件的4个方法" class="headerlink" title="获取系统符号文件的4个方法"></a>获取系统符号文件的4个方法</h2><h3 id="从真机上获取"><a href="#从真机上获取" class="headerlink" title="从真机上获取"></a>从真机上获取</h3><p>大部分系统库符号文件只能从真机上获取，苹果也没有提供下载。<br>当你用Xcode第一次连接某台设备进行真机调试时，会看到Xcode显示<code>Processing symbol files</code>，这时候就是在拷贝真机上的符号文件到Mac系统的<code>/Users/xxx/Library/Developer/Xcode/iOS DeviceSupport</code>目录下。</p>
<p>目录下的<code>10.2(14C82)</code>这样的文件夹就是对应的符号文件，通常都有1-3GB的大小，很占用空间，动不动就累积成3、40GB。很多讲清理Mac垃圾文件的教程都会说要删除这个目录下的文件，真是坑爹。正确做法是做成压缩包保存到外部硬盘里，需要符号化的时候再重新解压到此目录。</p>
<h3 id="寻找苹果官方的下载地址"><a href="#寻找苹果官方的下载地址" class="headerlink" title="寻找苹果官方的下载地址"></a>寻找苹果官方的下载地址</h3><p>之前watch的调试出现bug时，有人找出过几个watch的符号文件下载地址。见<a href="https://forums.developer.apple.com/thread/3380" target="_blank" rel="external">No symbols for paired Apple Watch</a>。<br>但是我尝试按照对应的命名格式，并没有找到iOS符号文件的下载地址。</p>
<h3 id="从已解密的固件中提取符号文件"><a href="#从已解密的固件中提取符号文件" class="headerlink" title="从已解密的固件中提取符号文件"></a>从已解密的固件中提取符号文件</h3><p>某些已经被破解的固件可以直接提取系统文件，但是未破解的固件（较新的固件和<code>arm64</code>的固件），无法用这种方式获取。</p>
<p>固件解密步骤：</p>
<p>1.下载对应版本的.ipsw固件，直接解压，解压后里面有几个<code>.dmg</code>格式的镜像文件，最大的<code>.dmg</code>文件就是系统镜像。<br>2.从<a href="https://www.theiphonewiki.com/wiki/Firmware_Keys" target="_blank" rel="external">Firmware_Keys</a>找到对应固件的解密key（页面上<code>Root Filesystem</code>字段的key）。<br>3.用一个<code>dmg</code>工具进行解密，<a href="http://modmyi.com/attachments/forums/general-verizon-sprint-cdma-iphone-chat/643832d1372672304-cant-decrypt-ios-7-beta-help-dmg.zip" target="_blank" rel="external">下载地址</a>。使用方式：<code>cd</code>到解压后的ipsw文件夹，执行<code>./dmg extract xxx-xxxx-xxx.dmg dec.dmg -k &lt;key&gt;</code>。<code>extract</code>后面跟两个参数，分别是系统镜像dmg的名字和解密后的文件名，-k 后面填写第2步获取到的key，如果key不对，解密会失败。<br>4.等待。最终会生成一个<code>dec.dmg</code>文件，双击打开即可加载系统镜像。</p>
<p>提取符号文件方法：<br>参考<a href="http://crash.163.com/#news/!newsId=31" target="_blank" rel="external">聊聊从iOS固件提取系统库符号</a>中的<code>二、系统库符号提取</code>部分。</p>
<h3 id="下载旧版本Xcode，提取SDK"><a href="#下载旧版本Xcode，提取SDK" class="headerlink" title="下载旧版本Xcode，提取SDK"></a>下载旧版本Xcode，提取SDK</h3><p>旧版本的Xcode里包含了对应的iPhoneSDK，可以从中获得符号文件。<br>路径是<code>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/</code>。里面的<code>System/Library</code>里就可以看到framework，而且同时包含了<code>armv7</code>,<code>armv7s</code>,<code>arm64</code>3个平台的版本。</p>
<p><code>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/version.plist</code>可以查看是哪个版本。把<code>iPhoneOS.sdk</code>文件夹的名字改成对应的<code>CFBundleVersion (ProductBuildVersion)</code>格式，然后在里面加一层<code>Symbols</code>子文件夹，把<code>System</code>,<code>Library</code>,<code>usr</code>都放进<code>Symbols</code>里，就可以和其他符号文件一样使用了。</p>
<p>但是当iOS版本只包含了bug修复，而没有改变API，Xcode就不会有附带对应的SDK，还是需要从真机上获取。而且从Xcode7开始，苹果用<code>tbd</code>文件代替了真机符号文件，所以这个方法也失效了。<br>参考：<a href="http://stackoverflow.com/questions/14941773/xcode-software-image-for-user-ios-in-order-to-symbolicate-ios-calls" target="_blank" rel="external">Xcode software image for user iOS in order to symbolicate iOS calls</a>, <a href="http://stackoverflow.com/a/28408052/6380485" target="_blank" rel="external">Missing iOS symbols at “~/Library/Developer/Xcode/iOS DeviceSupport”</a>。</p>
<h2 id="获取符号文件的难题"><a href="#获取符号文件的难题" class="headerlink" title="获取符号文件的难题"></a>获取符号文件的难题</h2><p>这个时候，游戏就开始了：</p>
<ul>
<li>很多时候crash日志只给出了系统的调用栈，不能直接定位到自己app的代码，因此需要符号化系统库。</li>
<li>用户的crash来自各种系统版本，需要对应版本的系统符号文件才能符号化。</li>
<li>系统库符号文件只能从真机上获取，苹果没有提供下载。</li>
<li>从<code>iOS 7.0(11A465)</code>到<code>iOS 10.2(14C92)</code>一共有50个build版本，公司的测试机是不会覆盖到这么变态的完整度的。</li>
<li>同一个版本，有时候会给iPhone和iPad、甚至6和6s提供不同build的固件。</li>
<li>某些版本是某些机子的特供版，例如<code>10.0.3(14A551)</code>是iPhone 7和 7 Plus独有的，这就更加大了收集难度。</li>
<li>同一个iOS版本可能有多个build，例如<code>10.1(14B72)</code>和<code>10.1(14B72c)</code>，苹果觉得更新幅度太小，就没有提升版本号。</li>
<li>除了build号的区别，符号文件在不同CPU平台上也有区别，意味着来自4s(<code>armv7</code>)和6s(<code>arm64</code>)的符号文件，即便build号是一样的，也无法通用。所以50个build号又要翻倍，达到了88个，所以精确来说我只是收集了（63/88）的进度。幸运的是，<code>arm64</code>机型的系统库里附带了<code>armv7s</code>。</li>
</ul>
<p>规则好厉害的收集游戏啊。收集品其实还有稀有度的区别，其中最厉害的应该是<code>10.0</code>，这是iPhone 7和7 Plus独有的出厂系统，而且没有固件可以下载，因此即便有iPhone 7也不能通过刷机来得到<code>10.0</code>。</p>
<p>其实我一直很奇怪为什么很少见到开发者抱怨找不到系统符号文件，从而召集大家进行收集并分享，猜测可能的原因是：</p>
<ul>
<li>懒。遇到无法符号化的问题，没有去解决。</li>
<li>有些公司可能很早就开始对crash日志自动符号化了，因此很早就开始收集符号文件。只要一直跟着苹果的每一个版本升级，收集起来还是挺简单的。而这些资源，开发者并不会注意到可以共享出来。</li>
<li>crash收集和符号化使用的是第三方服务，第三方平台会帮助符号化系统库。</li>
</ul>
<p>但是我找了一下，没有找到一家明确声明了能够符号化所有系统库的第三方平台。从腾讯的Bugly论坛里也能发现，有些系统方法并没有符号化出来，系统库是缺失的。（<strong>update</strong>：找到了一个国外的平台，在<a href="http://stackoverflow.com/questions/12058901/ios-system-symbol-symbolication-service" target="_blank" rel="external">stack overflow</a>上说能符号化所有版本的系统库，但是是收费服务，我也没有测试）</p>
<p>在公司小组里，大部分时候都是我来分析crash日志，所以当遇到缺少系统符号文件的情况，就会十分无奈。很多时候，没有符号化的crash日志根本无法提供有用信息。</p>
<h2 id="系统符号文件下载地址"><a href="#系统符号文件下载地址" class="headerlink" title="系统符号文件下载地址"></a>系统符号文件下载地址</h2><h3 id="暴力收集"><a href="#暴力收集" class="headerlink" title="暴力收集"></a>暴力收集</h3><p>收集不全一直让我很不爽。之前搜刮了组内的测试机，只收集到了有限的几个（感谢无私提供iPhone 7让我刷机降级的同事）。终于，这周末特意跑去了一趟二手机市场寻找旧版本的设备来拷贝，总算是收集得完整了一点，但是也花了我121块钱。</p>
<p>心情总算愉悦了。</p>
<p>其中大部分都是拷贝自<code>arm64</code>设备的，<code>armv7</code>的符号文件收集我是放弃了。有哪位大侠有兴趣把这个游戏玩通关的吗？还有 tvOS 和 watchOS的符号，我也放弃了。<br>(update:又花了些时间从Xcode的SDK和固件里提取了<code>armv7s</code>和<code>armv7</code>的固件，现在只剩下几个<code>arm64</code>的版本了)。</p>
<p>整理了一下传到了网盘，地址见下方，有需要的去下载吧。</p>
<h3 id="目前还缺少的符号文件"><a href="#目前还缺少的符号文件" class="headerlink" title="目前还缺少的符号文件"></a>目前还缺少的符号文件</h3><p>如果有人有这几个符号文件的，恳请你分享！</p>
<p>分享可以直接贴下载地址，也可以提交到这个github项目<a href="https://github.com/Zuikyo/iOS-System-Symbols" target="_blank" rel="external">iOS-System-Symbols</a>。如果我得到了新的符号文件，也会在这个项目里更新。</p>
<table>
<thead>
<tr>
<th>缺失符号的版本</th>
<th>缺失的CPU版本</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>10.0(14A346)</td>
<td>arm64</td>
<td>iPhone 7 和 7 Plus独占，出厂自带系统</td>
</tr>
<tr>
<td>9.3.2(13F72)</td>
<td>arm64</td>
<td>iPad Pro 9.7寸独占，修复了变砖的问题</td>
</tr>
<tr>
<td>9.3(13E237)</td>
<td>arm64</td>
<td>5s, iPad Air 和 iPad mini2独占，修复了不能激活的问题</td>
</tr>
<tr>
<td>9.3(13E234)</td>
<td>arm64</td>
<td>6s, 6s Plus 和 iPad Pro 9.7寸 独占</td>
</tr>
<tr>
<td>8.1.1 (12B435)</td>
<td>arm64</td>
<td>5s, iPad Air 和 iPad mini2 独占</td>
</tr>
<tr>
<td>8.0.1(12A402)</td>
<td>arm64</td>
<td><code>8.0.1</code>有导致变砖的bug，发布后很快就停止推送了</td>
</tr>
<tr>
<td>7.1.2 (11D257)</td>
<td>arm64</td>
<td></td>
</tr>
<tr>
<td>7.0.2(11A501)</td>
<td>arm64</td>
<td></td>
</tr>
<tr>
<td>7.0.1(11A470a)</td>
<td>arm64</td>
<td>5s 独占</td>
</tr>
</tbody>
</table>
<p>注意，arm64，armv7s，armv7版本的文件都是在同一个文件里的（例如<code>/Symbols/System/Library/Frameworks/UIKit.framework/UIKit</code>），Xcode在拷贝armv7的符号文件时，如果<code>iOS DeviceSupport</code>目录里已经有<code>arm64</code>或<code>armv7s</code>的符号文件，则会自动进行合并。因此如果你要分享一个<code>armv7</code>版本的符号文件，请先把arm64等其他版本的拷贝到<code>/Users/zhangweike/Library/Developer/Xcode/iOS DeviceSupport/</code>里，然后再用Xcode进行合并后再压缩分享。</p>
<h3 id="网盘下载地址"><a href="#网盘下载地址" class="headerlink" title="网盘下载地址"></a><a name="wang-pan"></a>网盘下载地址</h3><p><strong>网盘链接: <a href="https://pan.baidu.com/s/1nvfi4g5" target="_blank" rel="external">https://pan.baidu.com/s/1nvfi4g5</a> 密码: <code>79m8</code></strong></p>
<p>如果是在国外，可以用Google Driver：<br><a href="https://drive.google.com/drive/folders/0B-0LZDbSzubRaUdMdTJQc1ZzMUU?usp=sharing" target="_blank" rel="external">google drive分享(7.0.3-9.2)</a><br>,<br><a href="https://drive.google.com/drive/folders/0B5oBYvBG2NS7aDVTR1JzX2JXaFE?usp=sharing" target="_blank" rel="external">google drive分享(9.2.1-10.2)</a></p>
<p>如果我得到了新的符号文件，会在这个项目里更新：<a href="https://github.com/Zuikyo/iOS-System-Symbols" target="_blank" rel="external">iOS-System-Symbols</a>。</p>
<p>我把里面的那几个<code>dyld_shared_cache_xxxx</code>大文件单独拿出来了，目的是减小压缩包大小。如果只是符号化的话，用不到这几个文件，只是在真机调试的时候才需要。</p>
<h3 id="符号文件版本列表"><a href="#符号文件版本列表" class="headerlink" title="符号文件版本列表"></a>符号文件版本列表</h3><p>这些是我已经收集到的符号文件，包括了对应的CPU信息。iOS10系统开始不支持<code>armv7</code>的机器。但是iOS9以下还是支持<code>armv7</code>的，这里很多都缺失了<code>armv7</code>。</p>
<p>查看是否带有对应CPU架构的符号文件的方式：到<code>10.2 (14C92)/Symbols/System/Library/Caches/com.apple.dyld</code>这样的目录下，会有对应的<code>dyld_shared_cache_arm64</code>，<code>dyld_shared_cache_armv7s</code>，<code>dyld_shared_cache_armv7</code>文件，如果缺失了，就说明对应的CPU架构符号文件还不存在。（经过试验，这几个大文件并不影响符号化，只是在真机调试的时候才有用，因此如果嫌太占用空间，可以删去）。</p>
<table>
<thead>
<tr>
<th>版本</th>
<th>已收集到的CPU版本</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>10.2 (14C92)</td>
<td>arm64,armv7s</td>
<td></td>
</tr>
<tr>
<td>10.1.1 (14B150)</td>
<td>arm64,armv7s</td>
<td></td>
</tr>
<tr>
<td>10.1.1 (14B100)</td>
<td>arm64,armv7s</td>
<td></td>
</tr>
<tr>
<td>10.1 (14B72c)</td>
<td>arm64,armv7s</td>
<td></td>
</tr>
<tr>
<td>10.1 (14B72)</td>
<td>arm64,armv7s</td>
<td></td>
</tr>
<tr>
<td>10.0.3 (14A551)</td>
<td>arm64,armv7s</td>
<td></td>
</tr>
<tr>
<td>10.0.2 (14A456)</td>
<td>arm64,armv7s</td>
<td></td>
</tr>
<tr>
<td>10.0.1 (14A403)</td>
<td>arm64,armv7s</td>
<td></td>
</tr>
<tr>
<td><strong>10.0(14A346)</strong></td>
<td><strong>none</strong></td>
<td>iPhone 7 和 7 Plus独占，出厂自带系统</td>
</tr>
<tr>
<td>9.3.5 (13G36)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>9.3.4 (13G35)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>9.3.3 (13G34)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td><strong>9.3.2(13F72)</strong></td>
<td><strong>none</strong></td>
<td>iPad Pro 9.7寸独占，修复了变砖的问题</td>
</tr>
<tr>
<td>9.3.2 (13F69)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>9.3.1 (13E238)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>9.3(13E237)</td>
<td>armv7s,armv7</td>
<td>5s和更旧机型独占，修复了不能激活的问题</td>
</tr>
<tr>
<td>9.3(13E236)</td>
<td>armv7</td>
<td>iPad2独占，修复了不能激活的问题</td>
</tr>
<tr>
<td><strong>9.3(13E234)</strong></td>
<td><strong>none</strong></td>
<td>6s, 6s Plus and iPad Pro 9.7寸独占</td>
</tr>
<tr>
<td>9.3 (13E233)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>9.2.1 (13D20)</td>
<td>arm64,armv7s</td>
<td>iPhone 6 和更新的机型独占</td>
</tr>
<tr>
<td>9.2.1 (13D15)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>9.2 (13C75)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>9.1 (13B143)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>9.0.2(13A452)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>9.0.1(13A404)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>9.0 (13A344)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>8.4.1 (12H321)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>8.4 (12H143)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>8.3 (12F70)</td>
<td>arm64,armv7s,armv7</td>
<td>iPhone独占</td>
</tr>
<tr>
<td>8.3 (12F69)</td>
<td>arm64,armv7s,armv7</td>
<td>iPad独占</td>
</tr>
<tr>
<td>8.2 (12D508)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>8.1.3 (12B466)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>8.1.2 (12B440)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>8.1.1 (12B436)</td>
<td>arm64,armv7s</td>
<td>iPhone 6 和更新的机型独占</td>
</tr>
<tr>
<td>8.1.1 (12B435)</td>
<td>armv7s,armv7</td>
<td>5s和更旧机型独占</td>
</tr>
<tr>
<td>8.1 (12B411)</td>
<td>arm64,armv7s,armv7</td>
<td>iPhone独占</td>
</tr>
<tr>
<td>8.1 (12B410)</td>
<td>arm64,armv7s,armv7</td>
<td>iPad独占</td>
</tr>
<tr>
<td>8.0.2 (12A405)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>8.0.1(12A402)</td>
<td>armv7s,armv7</td>
<td><code>8.0.1</code>有导致变砖的bug，发布后很快就停止推送了</td>
</tr>
<tr>
<td>8.0 (12A366)</td>
<td>arm64,armv7s</td>
<td>6 Plus独占</td>
</tr>
<tr>
<td>8.0 (12A365)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>7.1.2 (11D257)</td>
<td>armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>7.1.1 (11D201)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>7.1 (11D167)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>7.0.6 (11B651)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>7.0.4 (11B554a)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>7.0.3 (11B511)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>7.0.2(11A501)</td>
<td>armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>7.0.1(11A470a)</td>
<td>armv7s</td>
<td>5s 和 5c 独占</td>
</tr>
<tr>
<td>7.0(11A465)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="机型对应CPU架构"><a href="#机型对应CPU架构" class="headerlink" title="机型对应CPU架构"></a>机型对应CPU架构</h3><table>
<thead>
<tr>
<th>CPU</th>
<th>机型</th>
</tr>
</thead>
<tbody>
<tr>
<td>armv6</td>
<td>iPhone, iPhone2, iPhone3G, iPod Touch 1 and 2</td>
</tr>
<tr>
<td>armv7</td>
<td>iPhone3GS, iPhone4, iPhone4S，iPad, iPad2, iPad3(The New iPad), iPad mini，iPod Touch 3G, iPod Touch4, iPod Touch5</td>
</tr>
<tr>
<td>armv7s</td>
<td>iPhone5, iPhone5C, iPad4(iPad with Retina Display)</td>
</tr>
<tr>
<td>arm64</td>
<td>iPhone5S, iPad Air, iPad mini2(iPad mini with Retina Display), iPhone6, iPhone6s, iPhone7, iPhone7s and any new device in the future</td>
</tr>
</tbody>
</table>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>最后再次呼吁一下，如果谁有上面缺失的符号文件，就请共享一下吧。虽然只是做一点微小的工作，但是能够有很大帮助。</p>
<p>不觉得填满上面那个列表会很爽吗？</p>
<h3 id="额外提示"><a href="#额外提示" class="headerlink" title="额外提示"></a>额外提示</h3><p>其实这些符号文件就是真机上的系统库，包括了完整的系统库二进制文件。有时候要反编译某些系统framework，但是模拟器SDK里没有对应的framework（比如只有真机上才有的<code>CoreMotion.framework</code>），就可以在这些真机上的系统库里找到了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.jianshu.com/p/11710e7ab661" target="_blank" rel="external">http://www.jianshu.com/p/11710e7ab661</a></li>
<li><a href="http://wufawei.com/2014/03/symbolicating-ios-crash-logs/" target="_blank" rel="external">符号化iOS Crash文件的3种方法</a></li>
<li><a href="https://en.wikipedia.org/wiki/IOS_SDK" target="_blank" rel="external">iOS SDK</a></li>
<li><a href="https://en.wikipedia.org/wiki/IOS_version_history#iOS_10" target="_blank" rel="external">iOS version history</a></li>
<li><a href="https://forums.developer.apple.com/thread/3380" target="_blank" rel="external">No symbols for paired Apple Watch</a></li>
<li><a href="http://crash.163.com/#news/!newsId=31" target="_blank" rel="external">聊聊从iOS固件提取系统库符号</a></li>
<li><a href="http://stackoverflow.com/questions/14941773/xcode-software-image-for-user-ios-in-order-to-symbolicate-ios-calls" target="_blank" rel="external">Xcode software image for user iOS in order to symbolicate iOS calls</a></li>
<li><a href="http://stackoverflow.com/a/28408052/6380485" target="_blank" rel="external">Missing iOS symbols at “~/Library/Developer/Xcode/iOS DeviceSupport”</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你有过分析iOS崩溃日志的经验，一定经常看到日志里出现很多&lt;code&gt;&amp;lt;redacted&amp;gt;&lt;/code&gt;的字段。这篇文章就是帮助开发者将这些字段符号化为对应的系统库方法名。&lt;/p&gt;
&lt;p&gt;如果你已经掌握了这方面的知识，就直接去下面的&lt;a href=&quot;#wan
    
    </summary>
    
      <category term="调试技巧" scheme="http://yoursite.com/categories/%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/"/>
    
      <category term="crash分析" scheme="http://yoursite.com/categories/%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/crash%E5%88%86%E6%9E%90/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>约束冲突调试工具：解决iOS7调试难题</title>
    <link href="http://yoursite.com/2016/12/13/%E7%BA%A6%E6%9D%9F%E5%86%B2%E7%AA%81%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2016/12/13/约束冲突调试工具/</id>
    <published>2016-12-13T13:43:29.000Z</published>
    <updated>2017-05-03T08:35:22.900Z</updated>
    
    <content type="html"><![CDATA[<p><em>功能</em>：</p>
<ul>
<li>在非调试模式下，获取出错的具体约束。</li>
<li>监测约束冲突，并获取出错的view和viewController。</li>
<li>监测iOS7上layoutSubViews导致的crash问题</li>
</ul>
<h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><h3 id="iOS7对Auto-Layout的支持问题"><a href="#iOS7对Auto-Layout的支持问题" class="headerlink" title="iOS7对Auto Layout的支持问题"></a>iOS7对Auto Layout的支持问题</h3><ul>
<li>iOS7的约束有一些奇怪的bug，对Auto Layout支持并不完美。</li>
<li>在出现约束冲突时，系统会尝试修复约束。iOS7和iOS8的修复结果有可能不一样。</li>
<li>如果view的<code>layoutSubviews</code>里没有调用<code>[super layoutSubviews]</code>，那么在往这个view上添加子view时，在iOS7以下会crash。例如<code>UITableView</code>，<code>UITableViewCell</code>。</li>
</ul>
<h3 id="iOS7的调试问题"><a href="#iOS7的调试问题" class="headerlink" title="iOS7的调试问题"></a>iOS7的调试问题</h3><ul>
<li>Xcode7虽然不能使用iOS7模拟器调试，但是还能使用iOS7真机调试。而Xcode8已经连iOS7的真机调试都不支持了。</li>
<li>Xcode8中编辑过的xib文件在Xcode7上会有兼容性问题，需要手动删除xib中的<code>&lt;capability name=&quot;documents saved in the Xcode 8 format&quot; minToolsVersion=&quot;8.0&quot;/&gt;</code>这一行才能在Xcode7上编译。如果要继续使用Xcode7调试，就需要修改这些xib，十分麻烦。</li>
<li>内网开发时，无法进行真机调试，如果要用模拟器调试，需要另一台低版本的Mac OSX系统的机子以安装Xcode6，同时也会遇到Xcode的兼容性问题，因此遇到iOS7的约束问题十分麻烦，如果没有环境的话只能靠猜。</li>
<li>约束冲突导致的crash往往在堆栈上无法得到有用的信息，因为是在系统库里crash，无法直接看出是哪个界面的约束出错。如果是在Xcode里调试，还能使用llvm的内存命令进行调试，但是在真机上就没办法了。</li>
</ul>
<h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>如果app能用代码监测到约束冲突，就可以在非调试模式下捕获到有用的信息，帮助快速定位问题。<br>当发生约束冲突时，控制台会输出这样的提示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">**Unable to simultaneously satisfy constraints.**</div><div class="line">    Probably at least one of the constraints in the following list is one you don&apos;t want. Try this: (1) look at each constraint and try to figure out which you don&apos;t expect; (2) find the code that added the unwanted constraint or constraints and fix it. (Note: If you&apos;re seeing NSAutoresizingMaskLayoutConstraints that you don&apos;t understand, refer to the documentation for the UIView property translatesAutoresizingMaskIntoConstraints)</div><div class="line">(</div><div class="line">    &quot;&lt;NSLayoutConstraint:0x7fc82d3e18a0 H:[UIView:0x7fc82aba1210(768)]&gt;&quot;,</div><div class="line">    &quot;&lt;NSLayoutConstraint:0x7fc82d6369e0 H:[UIView:0x7fc82aba1210]-(0)-|   (Names: &apos;|&apos;:UIView:0x7fc82d6b9f80 )&gt;&quot;,</div><div class="line">    &quot;&lt;NSLayoutConstraint:0x7fc82d636a30 H:|-(0)-[UIView:0x7fc82aba1210]   (Names: &apos;|&apos;:UIView:0x7fc82d6b9f80 )&gt;&quot;,</div><div class="line">    &quot;&lt;NSLayoutConstraint:0x7fc82d3e7fd0 &apos;UIView-Encapsulated-Layout-Width&apos; H:[UIView:0x7fc82d6b9f80(50)]&gt;&quot;</div><div class="line">)</div><div class="line"></div><div class="line">Will attempt to recover by breaking constraint</div><div class="line">&lt;NSLayoutConstraint:0x7fc82d3e18a0 H:[UIView:0x7fc82aba1210(768)]&gt;</div><div class="line"></div><div class="line">Make a symbolic breakpoint at UIViewAlertForUnsatisfiableConstraints to catch this in the debugger.</div><div class="line">The methods in the UIConstraintBasedLayoutDebugging category on UIView listed in &lt;UIKit/UIView.h&gt; may also be helpful.</div></pre></td></tr></table></figure>
<p>提示我们在<code>UIViewAlertForUnsatisfiableConstraints</code>上打断点调试。<br>这是一个检测到出错约束时，进行处理的C函数。上面那串控制台的log就是在这个函数里输出的。</p>
<p>于是可以尝试用method swizzling替换系统库的方法，记录出现冲突时的信息。<br>监测iOS7的crash问题也是同理。</p>
<h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><h3 id="获取UIView"><a href="#获取UIView" class="headerlink" title="获取UIView"></a>获取UIView</h3><p>runtime无法替换私有C函数，而调用栈里<code>NSISEngine</code>的那几个方法都没附带什么有用的信息，于是用hopper反编译<code>UIKit.framework</code>，找到使用<code>UIViewAlertForUnsatisfiableConstraints</code>的地方，是<code>-[UIView engine:willBreakConstraint:dueToMutuallyExclusiveConstraints:]</code>。</p>
<p>这个方法附带了出错约束的信息，也可以获取到冲突所在的UIView，于是也能通过UIView获取对应的viewController。接下来只要hook这个方法就可以了。</p>
<h3 id="获取view-controller"><a href="#获取view-controller" class="headerlink" title="获取view controller"></a>获取view controller</h3><p>获取view对应的view controller的方法有两种。</p>
<ul>
<li>使用<code>UIView</code>的私有API:<code>_viewDelegate</code>。</li>
<li>使用<code>UIResponder</code>的<code>nextResponder</code>：</li>
</ul>
<p>&gt;<br>The UIResponder class does not store or set the next responder automatically, instead returning nil by default. Subclasses must override this method to set the next responder. <strong>UIView implements this method by returning the UIViewController object that manages it (if it has one) or its superview (if it doesn’t)</strong>; UIViewController implements the method by returning its view’s superview; UIWindow returns the application object, and UIApplication returns nil.<br>&gt;</p>
<p>参考:<a href="http://stackoverflow.com/questions/1372977/given-a-view-how-do-i-get-its-viewcontroller" target="_blank" rel="external">Given a view, how do I get its viewController?</a></p>
<p>我选择了第二种方式。</p>
<h3 id="监测iOS7约束导致的crash"><a href="#监测iOS7约束导致的crash" class="headerlink" title="监测iOS7约束导致的crash"></a>监测iOS7约束导致的crash</h3><p>当你在实现自定义view的<code>layoutSubviews</code>方法时，记住：</p>
<ul>
<li>调用<code>[super layoutSubviews]</code></li>
<li>不要在<code>layoutSubviews</code>里增加约束</li>
</ul>
<p>如果不遵守这两条，当你向这个view上增加子view时，在iOS6和iOS7上会crash，控制台会输出提示：<code>&#39;Auto Layout still required after executing - layoutSubviews..&#39;</code> 。iOS8开始则不会crash。</p>
<p>某些系统控件，例如<code>UITableView</code>，<code>UITableViewCell</code>没有调用<code>[super layoutSubviews]</code>，所以在iOS6和iOS7上不能在它们上面增加子view，除非你用method swizlling修复它们的<code>layoutSubviews</code>方法。</p>
<p>经过反编译分析，<code>&#39;Auto Layout still required after executing - layoutSubviews..&#39;</code>发生在<code>UIView</code>的<code>layoutSublayersOfLayer:</code>里，发生错误之前会用<code>-[UIView _wantsWarningForMissingSuperLayoutSubviews]</code>来监测是否调用了<code>[super layoutSubviews]</code>，如果没有则抛出异常。<br>因此只需要hook<code>_wantsWarningForMissingSuperLayoutSubviews</code>就可以了。</p>
<h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p>设置监听方式如下，返回约束冲突所在的view，viewController，系统尝试打破的约束，目前所有的约束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">[ZIKConstraintsGuard monitorUnsatisfiableConstraintWithHandler:^(UIView *view, UIViewController *viewController, NSLayoutConstraint *constraintToBreak, NSArray&lt;NSLayoutConstraint *&gt; *currentConstraints) &#123;</div><div class="line">    NSLog(@&quot;检测到约束冲突！&quot;);</div><div class="line">    NSString *className = NSStringFromClass([viewController class]);</div><div class="line">    if ([className hasPrefix:@&quot;UI&quot;] &amp;&amp; ![className isEqualToString:@&quot;UIApplication&quot;]) &#123;</div><div class="line">    	  //使用某些系统控件时会出现约束冲突，例如UIAlertController</div><div class="line">        NSLog(@&quot;ignore conflict in UIKit:%@&quot;,viewController);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    NSLog(@&quot;冲突所在的viewController:\n%@ \nview:\n%@&quot;,viewController,view);</div><div class="line">    //使用recursiveDescription来打印view的层级，注意这是private API</div><div class="line">    NSLog(@&quot;view hierarchy:\n%@&quot;,[view valueForKeyPath:@&quot;recursiveDescription&quot;]);</div><div class="line">    NSLog(@&quot;目前所有的约束:\n%@&quot;,currentConstraints);</div><div class="line">    NSLog(@&quot;系统尝试打破的约束:\n%@&quot;,constraintToBreak);</div><div class="line">    </div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>打印结果如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">检测到约束冲突！</div><div class="line"></div><div class="line">冲突所在的viewController:</div><div class="line">&lt;MyViewController: 0x100201ba0&gt; </div><div class="line">view:</div><div class="line">&lt;UIView: 0x10020cbb0; frame = (0 0; 375 667); autoresize = W+H; gestureRecognizers = &lt;NSArray: 0x170242b50&gt;; layer = &lt;UIWindowLayer: 0x17002b240&gt;&gt;</div><div class="line"></div><div class="line">view hierarchy:</div><div class="line"></div><div class="line">&lt;UIView: 0x10020cbb0; frame = (0 0; 375 667); autoresize = W+H; gestureRecognizers = &lt;NSArray: 0x170242b50&gt;; layer = &lt;UIWindowLayer: 0x17002b240&gt;&gt;</div><div class="line">   | &lt;UIView: 0x10020fd00; frame = (0 0; 375 667); autoresize = W+H; layer = &lt;CALayer: 0x17002b780&gt;&gt;</div><div class="line">   |    | &lt;_UILayoutGuide: 0x1002100a0; frame = (0 0; 0 0); hidden = YES; layer = &lt;CALayer: 0x17002b820&gt;&gt;</div><div class="line">   |    | &lt;_UILayoutGuide: 0x100210650; frame = (0 0; 0 0); hidden = YES; layer = &lt;CALayer: 0x17002b8e0&gt;&gt;</div><div class="line">   |    | &lt;UITableView: 0x10081cc00; frame = (100 100; 100 100); clipsToBounds = YES; gestureRecognizers = &lt;NSArray: 0x170243e70&gt;; layer = &lt;CALayer: 0x17002bf20&gt;; contentOffset: &#123;0, 0&#125;; contentSize: &#123;0, 0&#125;&gt;</div><div class="line">   |    |    | &lt;UITableViewWrapperView: 0x10080fe00; frame = (0 0; 100 100); gestureRecognizers = &lt;NSArray: 0x1702441a0&gt;; layer = &lt;CALayer: 0x17002bf80&gt;; contentOffset: &#123;0, 0&#125;; contentSize: &#123;100, 100&#125;&gt;</div><div class="line"></div><div class="line">目前所有的约束:</div><div class="line">(</div><div class="line">    &quot;&lt;NSLayoutConstraint:0x17008a500 UITableView:0x10081cc00.top == UITableView:0x10081cc00.top + 10   (active)&gt;&quot;</div><div class="line">)</div><div class="line"></div><div class="line">系统尝试打破的约束:</div><div class="line">&lt;NSLayoutConstraint:0x17008a500 UITableView:0x10081cc00.top == UITableView:0x10081cc00.top + 10   (active)&gt;</div></pre></td></tr></table></figure>
<p>这样就能根据记录到的内存地址，准确地找到是哪个界面的哪个控件的约束出错了，即便在iOS7上crash，也能在crash之前记录到错误信息。</p>
<h2 id="需要注意的问题"><a href="#需要注意的问题" class="headerlink" title="需要注意的问题"></a>需要注意的问题</h2><ul>
<li>某些系统控件本身存在约束冲突的问题，例如在使用<code>UIAlertController</code>的时候。目前是在检测到冲突时，再检测viewController的类型前缀，如果是<code>UI</code>前缀则忽略。</li>
<li>同一个约束冲突有时候会有多次回调。这些回调来自处理auto layout的不同阶段，例如添加重复约束时、<code>addSubview</code>时，<code>layoutSubLayer</code>时等。</li>
</ul>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>工具地址在此：<a href="https://github.com/Zuikyo/ZIKConstraintsGuard" target="_blank" rel="external">ZIKConstraintsGuard</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;功能&lt;/em&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在非调试模式下，获取出错的具体约束。&lt;/li&gt;
&lt;li&gt;监测约束冲突，并获取出错的view和viewController。&lt;/li&gt;
&lt;li&gt;监测iOS7上layoutSubViews导致的crash问题&lt;/li&gt;
&lt;/u
    
    </summary>
    
      <category term="调试技巧" scheme="http://yoursite.com/categories/%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>@inerface的11条规范写法</title>
    <link href="http://yoursite.com/2016/12/07/interface%E7%9A%84%E8%A7%84%E8%8C%83%E5%86%99%E6%B3%95/"/>
    <id>http://yoursite.com/2016/12/07/interface的规范写法/</id>
    <published>2016-12-07T00:55:29.000Z</published>
    <updated>2016-12-07T03:33:02.790Z</updated>
    
    <content type="html"><![CDATA[<p>总结一些interface声明时的规范，相关宏的介绍，定义方法时有用的修饰符，编写注释的规范，最终写出一个合格的头文件。</p>
<ul>
<li><a href="#readwrite">1.读写权限</a><ul>
<li><a href="#readwrite-1">1.1实例变量的@public,@protected,@private关键字</a></li>
<li><a href="#readwrite-2">1.2属性的readonly,readwrite关键字</a></li>
</ul>
</li>
<li><a href="#forward-declaration">2.前向声明</a></li>
<li><a href="#private">3.只暴露必要的接口和实现</a><ul>
<li><a href="#private-1">3.1不要暴露任何只在类内部使用的私有方法</a></li>
<li><a href="#private-2">3.2不要在头文件里声明类内部遵循的protocol</a></li>
</ul>
</li>
<li><a href="#nullability">4.nullability说明</a></li>
<li><a href="#enum">5.定义枚举</a><ul>
<li><a href="#enum-1">5.1 NS_ENUM</a></li>
<li><a href="#enum-2">5.2 NS_OPTIONS</a></li>
<li><a href="#enum-3">5.3 字符串枚举</a></li>
</ul>
</li>
<li><a href="#extern">6.使用extern向外部提供只读常量</a></li>
<li><a href="#protected">7.向子类和category提供父类的私有属性</a></li>
<li><a href="#designated-initializer">8.标明designated initializer</a></li>
<li><a href="#version-control">9.API版本控制</a><ul>
<li><a href="#version-control-1">9.1 available</a></li>
<li><a href="#version-control-2">9.2 unavailable</a></li>
<li><a href="#version-control-3">9.3 deprecated</a></li>
</ul>
</li>
<li><a href="#keywords">10.额外的修饰符</a><ul>
<li><a href="#keywords-1">10.1泛型</a></li>
<li><a href="#keywords-2">10.2 NS_REQUIRES_SUPER</a></li>
<li><a href="#keywords-3">10.3 NS_NOESCAPE</a></li>
</ul>
</li>
<li><a href="#comment">11.写注释</a><ul>
<li><a href="#comment-1">11.1单行注释</a></li>
<li><a href="#comment-2">11.2多行注释</a></li>
<li><a href="#comment-3">11.3枚举注释</a></li>
<li><a href="#comment-4">11.4几个注释约定</a></li>
</ul>
</li>
</ul>
<hr>
<h2 id="1-读写权限"><a href="#1-读写权限" class="headerlink" title="1.读写权限"></a><a name="readwrite"></a>1.读写权限</h2><p>.h文件里的声明是用于暴露给外部的接口，而类内部的私有方法、私有属性和实例变量，应该放到.m文件的interface extension里。</p>
<h3 id="1-1-实例变量的-public-protected-private关键字"><a href="#1-1-实例变量的-public-protected-private关键字" class="headerlink" title="1.1 实例变量的@public,@protected,@private关键字"></a><a name="readwrite-1"></a>1.1 实例变量的@public,@protected,@private关键字</h3><p>这3个关键字用于修饰实例变量，不能用于修饰属性。当错误地使用了实例变量时，Xcode会报错提示。</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>@private</td>
<td>作用范围只能在自身类</td>
</tr>
<tr>
<td>@protected</td>
<td>作用范围在自身类和继承自己的子类，什么都不写，默认是此属性。</td>
</tr>
<tr>
<td>@public</td>
<td>作用范围最大，在任何地方。</td>
</tr>
</tbody>
</table>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//SearchManager.h</div><div class="line">@interface SearchManager : NSObject &#123;</div><div class="line">    @public    NSInteger *state;</div><div class="line">    @public    NSInteger *timeout;</div><div class="line">    @protected id *searchAPI;</div><div class="line">    @private   id _privateIvar;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>由于会暴露私有变量，并且没有@property的一些高级关键字，很少在头文件里声明实例变量。优先使用@property。</p>
<h3 id="1-2-属性的readonly-readwrite关键字"><a href="#1-2-属性的readonly-readwrite关键字" class="headerlink" title="1.2 属性的readonly,readwrite关键字"></a><a name="readwrite-2"></a>1.2 属性的readonly,readwrite关键字</h3><p>头文件中的属性是用于描述这个对象的一系列特性集合。<br>声明@property时，在.h里使用readonly，让外部只有读的权限，在.m里使用readwrite，使内部拥有读写权限。</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//SearchManager.h</div><div class="line">@interface SearchManager : NSObject</div><div class="line">@property (nonatomic, readonly) NSInteger * state;</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//SearchManager.m</div><div class="line">@interface SearchManager : NSObject</div><div class="line">@property (nonatomic, readwrite) NSInteger * state;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h2 id="2-前向声明"><a href="#2-前向声明" class="headerlink" title="2.前向声明"></a><a name="forward-declaration"></a>2.前向声明</h2><p>当在@interface的接口里用到了其他类，不要在.h里直接导入类的头文件，这样会让使用此头文件的地方也导入这些不必要的其他头文件。正确的做法是使用关键字<code>@class</code>进行前向声明。当然，如果是继承了父类，还是需要import父类的头文件。<br>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//SearchManager.h</div><div class="line">#import &quot;SearchManagerBase.h&quot;//导入父类的头文件</div><div class="line"></div><div class="line">@class LocationModel;//前向声明LocationModel类</div><div class="line"></div><div class="line">typedef void(^LocationSearchCompletionHandler)(LocationModel *location, NSError *error);</div><div class="line">@interface LocationSearchManager : SearchManagerBase</div><div class="line">- (void)searchLocationWithKeyword:(NSString *)keyword completionHandler:(LocationSearchCompletionHandler)completionHandler;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>使用@class会告诉编译器有这么一个类存在，但是现在并不关心这个类的具体实现，等到调用者在.m里使用的时候再import这个类即可。使用@class和@protocol分别声明一个类和一个protocol。<br>使用前向引用的原因有两个：</p>
<ul>
<li>提升编译效率。<br>如果import了<code>LocationModel.h</code>，那么当<code>LocationModel.h</code>的内容发生变化时，所有import了<code>LocationModel.h</code>的地方都需要重新编译。如果.m引用了<code>SearchManager.h</code>，但是并没有使用<code>LocationModel</code>，就会增加不必要的编译，降低开发效率。</li>
<li>解决交叉引用的问题。<br>如果类A的头文件import了B，类B的头文件import了A，这样在编译时会报错：“can not find interface declaration”，这是因为Objective-C不允许交叉引用。</li>
</ul>
<h2 id="3-只暴露必要的接口和实现"><a href="#3-只暴露必要的接口和实现" class="headerlink" title="3.只暴露必要的接口和实现"></a><a name="private"></a>3.只暴露必要的接口和实现</h2><h3 id="3-1不要暴露任何只在类内部使用的私有方法"><a href="#3-1不要暴露任何只在类内部使用的私有方法" class="headerlink" title="3.1不要暴露任何只在类内部使用的私有方法"></a><a name="private-1"></a>3.1不要暴露任何只在类内部使用的私有方法</h3><p>头文件里只声明那些给外部使用的公开方法，并且在设计时需要考虑到可测试性，遵循单一职责。<br>私有方法只定义在类内部，并且为了进行区别，建议在私有方法前加上前缀，例如<code>- (void)p_myPrivateMethod</code>。<br>由于Apple在它的编码规范里声明了，Apple公司拥有下划线的方法前缀，就像它拥有<code>NS</code>,<code>UI</code>这些类名前缀一样，因此不建议我们的私有方法直接使用下划线作为前缀。否则，当你在继承Cocoa Touch的类时，有可能会覆盖父类的私有方法，造成难以调试的错误。</p>
<h3 id="3-2不要在头文件里声明类内部遵循的protocol"><a href="#3-2不要在头文件里声明类内部遵循的protocol" class="headerlink" title="3.2不要在头文件里声明类内部遵循的protocol"></a><a name="private-2"></a>3.2不要在头文件里声明类内部遵循的protocol</h3><p><strong>错误</strong>的示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//SearchManager.h</div><div class="line">@interface SearchManager : NSObject&lt;NSCoding, UITableViewDelegate&gt;</div><div class="line">@property (nonatomic, readonly) NSInteger * state;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p><code>UITableViewDelegate</code>是类内部使用时遵循的protocol，没有必要暴露给外部，因此应该放到.m文件里。<br>而<code>NSCoding</code>则描述了类的特性，用于告诉外部本类可以使用归档，因此应该放在头文件里。</p>
<h2 id="4-nullability说明"><a href="#4-nullability说明" class="headerlink" title="4.nullability说明"></a><a name="nullability"></a>4.nullability说明</h2><p>在声明时，可以使用下列关键字描述对象是否可以为nil。</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>nullable</td>
<td>可空，用于描述objc对象</td>
</tr>
<tr>
<td>nonnull</td>
<td>不可空，用于描述objc对象</td>
</tr>
<tr>
<td>null_unspecified</td>
<td>不确定，用于描述objc对象</td>
</tr>
<tr>
<td>null_resettable</td>
<td>set可空，get不为空。仅用于property</td>
</tr>
<tr>
<td>_Nullable</td>
<td>可空，用于描述C指针和block</td>
</tr>
<tr>
<td>_Nonnull</td>
<td>不可空，用于描述C指针和block</td>
</tr>
<tr>
<td>_Null_unspecified</td>
<td>不确定，用于描述C指针和block</td>
</tr>
</tbody>
</table>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//SearchManager.h</div><div class="line">#import &quot;SearchManagerBase.h&quot;</div><div class="line">@class LocationModel;</div><div class="line"></div><div class="line">typedef void(^LocationSearchCompletionHandler)(LocationModel *_Nullable location, NSError *_Nullable error);</div><div class="line">@interface LocationSearchManager : SearchManagerBase</div><div class="line">- (void)searchLocationWithKeyword:(nonnull NSString *)keyword completionHandler:(LocationSearchCompletionHandler _Nonnull)completionHandler;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>如果向一个使用nonnull修饰的值赋空，编译器会给出警告。<br>在开发时，大部分时候使用的都是nonnull，因此Apple提供了一对宏<code>NS_ASSUME_NONNULL_BEGIN</code>和<code>NS_ASSUME_NONNULL_END</code>来进行快速修饰，写在两个宏之间的属性、方法，均会使用<code>nonnull</code>修饰。<br>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//LocationSearchManager.h</div><div class="line"></div><div class="line">#import &quot;SearchManagerBase.h&quot;</div><div class="line">@class LocationModel;</div><div class="line"></div><div class="line">NS_ASSUME_NONNULL_BEGIN</div><div class="line">typedef void(^LocationSearchCompletionHandler)(LocationModel *_Nullable location, NSError *_Nullable error);</div><div class="line">@interface LocationSearchManager : SearchManagerBase</div><div class="line">- (void)searchLocationWithKeyword:(NSString *)keyword completionHandler:(LocationSearchCompletionHandler)completionHandler;</div><div class="line">@end</div><div class="line">NS_ASSUME_NONNULL_END</div></pre></td></tr></table></figure>
<h2 id="5-定义枚举"><a href="#5-定义枚举" class="headerlink" title="5.定义枚举"></a><a name="enum"></a>5.定义枚举</h2><p>关于NS_ENUM和NS_OPTIONS的区别，参考<a href="http://nshipster.cn/ns_enum-ns_options/" target="_blank" rel="external">这里</a>。<br>简单来说，NS_OPTIONS提供了按位掩码的功能。</p>
<h3 id="5-1-NS-ENUM"><a href="#5-1-NS-ENUM" class="headerlink" title="5.1 NS_ENUM"></a><a name="enum-1"></a>5.1 NS_ENUM</h3><p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSInteger,SearchState) &#123;</div><div class="line">    SearchStateNotSearch,</div><div class="line">    SearchStateSearching,</div><div class="line">    SearchStateSearchFinished,</div><div class="line">    SearchStateSearchFailed</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="5-2-NS-OPTIONS"><a href="#5-2-NS-OPTIONS" class="headerlink" title="5.2 NS_OPTIONS"></a><a name="enum-2"></a>5.2 NS_OPTIONS</h3><p>示例代码，参考<code>NSKeyValueObserving.h</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">typedef NS_OPTIONS(NSUInteger, NSKeyValueObservingOptions) &#123;</div><div class="line">    NSKeyValueObservingOptionNew,</div><div class="line">    NSKeyValueObservingOptionOld,</div><div class="line">    NSKeyValueObservingOptionInitial,</div><div class="line">    NSKeyValueObservingOptionPrior</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在使用时就可以用<code>|</code>组合多个option：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[_webView addObserver:self forKeyPath:@&quot;title&quot; options:NSKeyValueObservingOptionInitial | NSKeyValueObservingOptionNew context:NULL];</div></pre></td></tr></table></figure></p>
<h3 id="5-3-字符串枚举"><a href="#5-3-字符串枚举" class="headerlink" title="5.3 字符串枚举"></a><a name="enum-3"></a>5.3 字符串枚举</h3><p>当使用字典作为参数传递，或者作为返回值时，往往难以直接提供字典的key，现在使用字符串枚举即可解决这个问题。<br>示例代码，参考<code>NSKeyValueObserving.h</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//使用NS_STRING_ENUM宏，定义了一个枚举类型</div><div class="line">typedef NSString * NSKeyValueChangeKey NS_STRING_ENUM;</div><div class="line"></div><div class="line">FOUNDATION_EXPORT NSKeyValueChangeKey const NSKeyValueChangeKindKey;</div><div class="line">FOUNDATION_EXPORT NSKeyValueChangeKey const NSKeyValueChangeNewKey;</div><div class="line">FOUNDATION_EXPORT NSKeyValueChangeKey const NSKeyValueChangeOldKey;</div><div class="line">FOUNDATION_EXPORT NSKeyValueChangeKey const NSKeyValueChangeIndexesKey;</div><div class="line">FOUNDATION_EXPORT NSKeyValueChangeKey const NSKeyValueChangeNotificationIsPriorKey;</div><div class="line"></div><div class="line">//使用泛型，声明了change参数用到的key，是在NSKeyValueChangeKey的枚举范围中</div><div class="line">- (void)observeValueForKeyPath:(nullable NSString *)keyPath ofObject:(nullable id)object change:(nullable NSDictionary&lt;NSKeyValueChangeKey, id&gt; *)change context:(nullable void *)context;</div></pre></td></tr></table></figure>
<h2 id="6-使用extern向外部提供只读常量"><a href="#6-使用extern向外部提供只读常量" class="headerlink" title="6.使用extern向外部提供只读常量"></a><a name="extern"></a>6.使用extern向外部提供只读常量</h2><p>这不关@interface的事，但是和头文件有关，就放在一起说明了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//SearchManager.h</div><div class="line">extern NSString *const SearchErrorDomain;</div><div class="line">extern NSInteger SearchDefaultTimeout;</div><div class="line"></div><div class="line">@interface SearchManager : NSObject</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//SearchManager.m</div><div class="line">NSString *const SearchErrorDomain = @&quot;SearchErrorDomain&quot;;</div><div class="line">const NSInteger SearchDefaultTimeout = 20;</div><div class="line"></div><div class="line">@interface SearchManager()</div><div class="line">@end</div></pre></td></tr></table></figure>
<h2 id="7-向子类和category提供父类的私有属性"><a href="#7-向子类和category提供父类的私有属性" class="headerlink" title="7.向子类和category提供父类的私有属性"></a><a name="protected"></a>7.向子类和category提供父类的私有属性</h2><p>由于类的头文件只存放那些暴露给外部的属性和方法，在遇到这些情况时，会遇到障碍：</p>
<ul>
<li>在子类里或者category里，想要使用父类定义在.m里的私有属性。</li>
<li>在类的头文件里属性是readonly，但是在子类或者category里，需要readwrite权限。<br>由于这些属性并没有暴露在头文件里，因此需要另外建立一个私有头文件，用来存放这些需要暴露给子类和category的属性。<br>可以参考Apple官方的<code>UIGestureRecognizerSubclass.h</code>。<br>示例代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//SearchManager.h</div><div class="line">@interface SearchManager : NSObject</div><div class="line">///外部访问，只有读权限</div><div class="line">@property (nonatomic, readonly) SearchState *state;</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//SearchManager.m</div><div class="line">@interface SearchManager()</div><div class="line">///内部使用，有读写权限</div><div class="line">@property (nonatomic, assign) SearchState *state;</div><div class="line">///只在内部使用的私有属性</div><div class="line">@property (nonatomic, strong) id searchAPI;</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">///暴露给子类和category的私有属性和私有方法</div><div class="line">//SearchManagerInternal.h</div><div class="line">///限制使用此头文件，防止被别的类误用</div><div class="line">#ifdef SEARCHMANAGER_PROTECTED_ACCESS</div><div class="line"></div><div class="line">#import &quot;SearchManager.h&quot;</div><div class="line">@interface SearchManager()</div><div class="line">///在internal.h里，重新声明为readwrite权限</div><div class="line">@property (nonatomic, readwrite, assgin) SearchState *state;</div><div class="line">///暴露私有属性</div><div class="line">@property (nonatomic, strong) id searchAPI;</div><div class="line">///暴露私有方法</div><div class="line">- (void)p_privateMethod;</div><div class="line">@end</div><div class="line"></div><div class="line">#else</div><div class="line">#error Only be included by SearchManager&apos;s subclass or category!</div><div class="line">#endif</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">///category的实现文件</div><div class="line">//SearchManager+Category.m</div><div class="line">///声明私有头文件的使用权限</div><div class="line">#define SEARCHMANAGER_PROTECTED_ACCESS</div><div class="line">///导入私有头文件</div><div class="line">#import &quot;SearchManagerInternal.h&quot;</div><div class="line"></div><div class="line">@implementation SearchManager(Category)</div><div class="line">- (void)categoryMethod &#123;</div><div class="line">    //拥有了读写权限</div><div class="line">    self.state = SearchStateSearching;</div><div class="line">    //可以访问私有属性</div><div class="line">    [self.searchAPI startSearch];</div><div class="line">    //可以使用私有方法</div><div class="line">    [self p_privateMethod];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p><code>SearchManagerInternal.h</code>其实也是公开的，其他类也能够导入并使用，只能在开发时进行约定。如果想要限制其他类导入，并且提示错误，<code>Internal.h</code>可以使用如下方式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#ifdef MYCLASS_PROTECTED_ACCESS</div><div class="line">//声明部分</div><div class="line">#else</div><div class="line">#error Only be included by MYCLASS&apos;s subclass or category!</div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>这样在别的类内意外地导入了<code>Internal.h</code>时就会产生编译警告，并且无法直接使用。缺点是需要在所有使用到<code>Internal.h</code>的地方都<code>#define MYCLASS_PROTECTED_ACCESS</code>。</p>
<h2 id="8-标明designated-initializer"><a href="#8-标明designated-initializer" class="headerlink" title="8.标明designated initializer"></a><a name="designated-initializer"></a>8.标明designated initializer</h2><p>指定初始化方法，即接收参数最多的那个初始化方法，其他初始化方法调用它即可，这样设计的目的是为了保证所有初始化方法都正确地初始化实例变量。<br>在方法后面加上<code>NS_DESIGNATED_INITIALIZER</code>宏即可。这样，当你子类化这个类时，在子类的初始化方法里如果没有正确地调用父类的designated initializer，编译器就会给出警告。<br>实例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@interface WKWebView : UIView</div><div class="line">- (instancetype)initWithFrame:(CGRect)frame configuration:(WKWebViewConfiguration *)configuration NS_DESIGNATED_INITIALIZER;</div><div class="line">- (nullable instancetype)initWithCoder:(NSCoder *)coder NS_DESIGNATED_INITIALIZER;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>关于designated initializer更详细的说明，参考:</p>
<ul>
<li><a href="https://github.com/100mango/zen/blob/master/Objective-C%20拾遗：designated%20initializer/Objective-C%20拾遗：designated%20initializer.md" target="_blank" rel="external">Objective-C 拾遗：designated initializer</a></li>
<li><a href="http://www.starfelix.com/blog/2014/04/13/zheng-que-bian-xie-designated-initializerde-ji-ge-yuan-ze/" target="_blank" rel="external">正确编写Designated Initializer的几个原则</a></li>
</ul>
<h2 id="9-API版本控制"><a href="#9-API版本控制" class="headerlink" title="9.API版本控制"></a><a name="version-control"></a>9.API版本控制</h2><p>在更新接口，或者开发framework时，需要标明版本信息，告诉使用者此接口的平台限制、操作系统版本、是否可用、是否已弃用等。<br>苹果给出了几个自带的宏用于标明版本，Xcode在检测到错误使用时会给出警告。只需要在方法名后面加上对应的宏即可。</p>
<h3 id="9-1-available"><a href="#9-1-available" class="headerlink" title="9.1 available"></a><a name="version-control-1"></a>9.1 available</h3><p>声明本接口最低支持的操作系统版本。<br>当你的接口使用了新系统的API，例如iOS8以上才有的UIAlertController，但是项目的deployment target却是iOS7时，需要标明此接口的版本信息，让使用者进行兼容。<br>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//SearchManager.h</div><div class="line"></div><div class="line">typedef NS_ENUM(NSInteger,SearchState) &#123;</div><div class="line">    SearchStateNotSearch,</div><div class="line">    SearchStateSearching,</div><div class="line">    SearchStateSearchFinished,</div><div class="line">    SearchStateSearchFailed</div><div class="line">&#125; NS_ENUM_AVAILABLE_IOS(2_0);//此枚举在iOS2.0以上才能使用</div><div class="line"></div><div class="line">NS_CLASS_AVAILABLE_IOS(2_0) //此类在iOS2.0以上才能使用</div><div class="line">@interface SearchManager : NSObject</div><div class="line">- (void)reSearch NS_AVAILABLE_IOS(5_0);//此方法在iOS5.0以上才能使用</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这几个宏有对应平台的版本，例如NS_AVAILABLE_MAC, NS_AVAILABLE_IOS, NS_AVAILABLE_IPHONE。<br>iOS10开始提供了新的available宏<code>API_AVAILABLE</code>，用来统一macOS、iOS、watchOS、tvOS几个平台。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">API_AVAILABLE(macos(10.10))</div><div class="line">API_AVAILABLE(macos(10.9), ios(10.0))</div><div class="line">API_AVAILABLE(macos(10.4), ios(8.0), watchos(2.0), tvos(10.0))</div></pre></td></tr></table></figure>
<h3 id="9-2-unavailable"><a href="#9-2-unavailable" class="headerlink" title="9.2 unavailable"></a><a name="version-control-2"></a>9.2 unavailable</h3><p>声明此接口不可用，大多数时候是用于声明所在平台限制。<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@interface SearchManager : NSObject</div><div class="line">- (void)searchInWatch NS_UNAVAILABLE;//不能用此接口</div><div class="line">- (void)searchInHostApp NS_EXTENSION_UNAVAILABLE_IOS;//extension里不能用此接口</div><div class="line">- (void)search __TVOS_PROHIBITED;//tvOS里不能用此接口，可修饰枚举，类，方法，参数</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>iOS10开始提供了新的unavailable宏<code>API_UNAVAILABLE</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">API_UNAVAILABLE(macos)</div><div class="line">API_UNAVAILABLE(watchos, tvos)</div></pre></td></tr></table></figure>
<h3 id="9-3-deprecated"><a href="#9-3-deprecated" class="headerlink" title="9.3 deprecated"></a><a name="version-control-3"></a>9.3 deprecated</h3><p>声明此接口已经被弃用，可以同时加注释注明替代接口。<br>当deployment target版本号设置成大于或等于方法被弃用的版本号时，Xcode会给出警告。<br>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//注明废弃类</div><div class="line">NS_CLASS_DEPRECATED_IOS(2_0, 9_0, &quot;UIAlertView is deprecated. Use UIAlertController with a preferredStyle of UIAlertControllerStyleAlert instead&quot;)</div><div class="line">@interface UIAlertView : UIView</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//注明废弃API</div><div class="line">@interface UIViewController : UIResponder</div><div class="line">- (void)viewDidUnload NS_DEPRECATED_IOS(3_0,6_0);</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//注明废弃枚举</div><div class="line">typedef NS_ENUM(NSInteger, UIStatusBarStyle) &#123;</div><div class="line">    UIStatusBarStyleDefault                                     = 0, // Dark content, for use on light backgrounds</div><div class="line">    UIStatusBarStyleLightContent     NS_ENUM_AVAILABLE_IOS(7_0) = 1, // Light content, for use on dark backgrounds</div><div class="line">    </div><div class="line">    UIStatusBarStyleBlackTranslucent NS_ENUM_DEPRECATED_IOS(2_0, 7_0, &quot;Use UIStatusBarStyleLightContent&quot;) = 1,</div><div class="line">    UIStatusBarStyleBlackOpaque      NS_ENUM_DEPRECATED_IOS(2_0, 7_0, &quot;Use UIStatusBarStyleLightContent&quot;) = 2,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>iOS10开始提供了新的deprecated宏<code>API_DEPRECATED</code>和<code>API_DEPRECATED_WITH_REPLACEMENT</code>。前者可以注明弃用原因，后者可以注明替代接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">API_DEPRECATED(&quot;No longer supported&quot;, macos(10.4, 10.8))</div><div class="line">API_DEPRECATED(&quot;No longer supported&quot;, macos(10.4, 10.8), ios(2.0, 3.0), watchos(2.0, 3.0), tvos(9.0, 10.0))</div><div class="line"></div><div class="line">API_DEPRECATED_WITH_REPLACEMENT(&quot;-setName:&quot;, tvos(10.0, 10.4), ios(9.0, 10.0))</div><div class="line">API_DEPRECATED_WITH_REPLACEMENT(&quot;SomeClassName&quot;, macos(10.4, 10.6), watchos(2.0, 3.0))</div></pre></td></tr></table></figure>
<h2 id="10-额外的修饰符"><a href="#10-额外的修饰符" class="headerlink" title="10.额外的修饰符"></a><a name"keywords"=""></a>10.额外的修饰符</h2><h3 id="10-1-泛型"><a href="#10-1-泛型" class="headerlink" title="10.1 泛型"></a><a name"keywords-1"=""></a>10.1 泛型</h3><p>在声明时，对集合类型的对象增加泛型的修饰，就可以声明集合内存储的数据类型。<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, strong) NSMutableArray&lt;NSString *&gt; *myArray;</div></pre></td></tr></table></figure>
<p>当你向<code>myArray</code>里放入一个非<code>NSString *</code>类型的对象时，编译器会给出警告。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property(nonatomic, strong) NSMutableArray&lt;__kindof UIView *&gt; * viewArray;</div></pre></td></tr></table></figure>
<p><code>_kindof</code>只限定了存储类型为<code>UIView</code>，因此也可以存储<code>UIView</code>的子类，例如<code>UIButton</code>。<br>更详细的介绍，参考:<a href="https://my.oschina.net/u/2340880/blog/514804" target="_blank" rel="external">Objective—C语言的新魅力——Nullability、泛型集合与类型延拓</a></p>
<h3 id="10-2-NS-REQUIRES-SUPER"><a href="#10-2-NS-REQUIRES-SUPER" class="headerlink" title="10.2 NS_REQUIRES_SUPER"></a><a name"keywords-2"=""></a>10.2 NS_REQUIRES_SUPER</h3><p><code>NS_REQUIRES_SUPER</code>宏用于声明子类在重载父类的这个方法时，需要调用父类的方法。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)viewWillAppear:(BOOL)animated NS_REQUIRES_SUPER;</div></pre></td></tr></table></figure>
<h3 id="10-3-NS-NOESCAPE"><a href="#10-3-NS-NOESCAPE" class="headerlink" title="10.3 NS_NOESCAPE"></a><a name"keywords-3"=""></a>10.3 NS_NOESCAPE</h3><p><code>NS_NOESCAPE</code>用于修饰方法中的block类型参数，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface NSArray: NSObject</div><div class="line">- (NSArray *)sortedArrayUsingComparator:(NSComparator NS_NOESCAPE)cmptr</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>作用是告诉编译器，<code>cmptr</code>这个block在<code>sortedArrayUsingComparator:</code>方法返回之前就会执行完毕，而不是被保存起来在之后的某个时候再执行。<br>类似于这样的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)performWithLock:(NS_NOESCAPE void (^)())block &#123;  // exposed as @noescape to Swift</div><div class="line">    [myLock lock];</div><div class="line">    block();</div><div class="line">    [myLock unlock];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译器知道之后，就会相应地做一些优化，例如去掉一些多余的对<code>self</code>的捕获、retain、release操作。因为block的存活范围仅限于本方法内，没有必要再在block内保留<code>self</code>了。<br>更详细的介绍，参考<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0012-add-noescape-to-public-library-api.md" target="_blank" rel="external">这里</a>。</p>
<h2 id="11-写注释"><a href="#11-写注释" class="headerlink" title="11.写注释"></a><a name="comment"></a>11.写注释</h2><p>头文件就是文档，需要让使用者快速知道这个类的作用。一个好的方法名可以让使用者快速理解，但大部分时候还是需要相应的注释。<br>写好格式化注释后，当光标停留在方法名和属性上时，在Xcode右侧的Quick Help栏里会出现注释内容，按住<code>option</code>并单击，也会弹出注释框。</p>
<h3 id="11-1单行注释"><a href="#11-1单行注释" class="headerlink" title="11.1单行注释"></a><a name="comment-1"></a>11.1单行注释</h3><p>直接在方法或者属性声明的上一行使用<code>///</code>，后面加注释，同时兼容Xcode和appleDoc。Xcode也支持<code>//!</code>，但是appleDoc不支持。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//SearchManagerBase.h</div><div class="line"></div><div class="line">///搜索manager的基类</div><div class="line">@interface SearchManagerBase : NSObject</div><div class="line">///搜索状态</div><div class="line">@property (nonatomic, readonly) NSInteger * state;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="11-2多行注释"><a href="#11-2多行注释" class="headerlink" title="11.2多行注释"></a><a name="comment-2"></a>11.2多行注释</h3><p>多行注释使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> 注释内容</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>Xcode8提供了快速生成格式化注释的快捷键：<code>option</code>+<code>command</code>+<code>/</code>。如果方法有参数，会自动添加@param关键字，用于描述对应的参数。<br>Apple提供了官方的headDoc语法，但是很多都已经在Xcode中失效了，而且有些关键字也和appleDoc不兼容。下面几种列举出了在Xcode中仍然有效的一些关键字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> 演示苹果headDoc的语法。这里可以写方法简介</div><div class="line"> </div><div class="line"> @brief 方法的简介(appleDoc不支持此关键字)</div><div class="line"> @discussion 方法的详细说明</div><div class="line"> </div><div class="line"> @code //示例代码(这个在Xcode里常用，但是appleDoc不支持此关键字)</div><div class="line"> UIView *view;</div><div class="line"> @endcode</div><div class="line"> </div><div class="line"> @bug       存在的bug的说明</div><div class="line"> @note      需要注意的提示</div><div class="line"> @warning   警告</div><div class="line"> @since     iOS7.0</div><div class="line"> @exception 方法会抛出的异常的说明</div><div class="line"> </div><div class="line"> @attention 注意，从这里开始往下的关键字，appleDoc都不支持</div><div class="line"> @author    编写者</div><div class="line"> @copyright 版权</div><div class="line"> @date      日期</div><div class="line"> @invariant 不变量</div><div class="line"> @post      后置条件</div><div class="line"> @pre       前置条件</div><div class="line"> @remarks   备注</div><div class="line"> @todo      todo text</div><div class="line"> @version   版本</div><div class="line"> */</div><div class="line">- (void)sampleMethod;</div></pre></td></tr></table></figure>
<p>在Xcode中，就会显示为这样：<br><img src="http://upload-images.jianshu.io/upload_images/1865432-dfc9a9b1de31ec47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="comment.png"></p>
<h3 id="11-3-枚举注释"><a href="#11-3-枚举注释" class="headerlink" title="11.3 枚举注释"></a><a name="comment-3"></a>11.3 枚举注释</h3><p>如果要给枚举注释，需要在每个枚举值前注释，按照如下格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">///搜索状态</div><div class="line">typedef NS_ENUM(NSInteger,SearchState) &#123;</div><div class="line">    ///没有开始搜索</div><div class="line">    SearchStateNotSearch,</div><div class="line">    ///搜索中</div><div class="line">    SearchStateSearching,</div><div class="line">    ///搜索结束</div><div class="line">    SearchStateSearchFinished,</div><div class="line">    ///搜索失败</div><div class="line">    SearchStateSearchFailed</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="11-4-几个注释约定"><a href="#11-4-几个注释约定" class="headerlink" title="11.4 几个注释约定"></a><a name="comment-4"></a>11.4 几个注释约定</h3><p>需要注释的内容：</p>
<ul>
<li>尽量为类添加描述，即便只有一句话。</li>
<li>标明某些参数和属性的默认值，比如超时time。</li>
<li>如果属性是KVO兼容的，即外部可以使用KVO监听此属性，则在属性注释里声明。</li>
<li>回调block参数需要说明回调所在的线程，避免让使用者在block里进行多余的线程判断。</li>
<li>如果需要的话，说明使用此API需要的前置条件，防止被错误地调用。</li>
<li>对使用了method swizzling的API进行统一形式的标注，方便遇到runtime的bug时进行排查。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://blog.sunnyxx.com/2014/04/13/objc_dig_interface/" target="_blank" rel="external">http://blog.sunnyxx.com/2014/04/13/objc_dig_interface/</a></li>
<li><a href="http://blog.sunnyxx.com/2015/06/12/objc-new-features-in-2015/" target="_blank" rel="external">http://blog.sunnyxx.com/2015/06/12/objc-new-features-in-2015/</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结一些interface声明时的规范，相关宏的介绍，定义方法时有用的修饰符，编写注释的规范，最终写出一个合格的头文件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#readwrite&quot;&gt;1.读写权限&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#readwrite-1&quot;&gt;
    
    </summary>
    
      <category term="代码规范" scheme="http://yoursite.com/categories/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>私有API-iOS10 openURL方法跳转到设置界面失效的解决方法</title>
    <link href="http://yoursite.com/2016/10/10/%E7%A7%81%E6%9C%89API-iOS10%20openURL%E6%96%B9%E6%B3%95%E8%B7%B3%E8%BD%AC%E5%88%B0%E8%AE%BE%E7%BD%AE%E7%95%8C%E9%9D%A2%E5%A4%B1%E6%95%88%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2016/10/10/私有API-iOS10 openURL方法跳转到设置界面失效的解决方法/</id>
    <published>2016-10-10T00:48:29.000Z</published>
    <updated>2017-05-03T08:23:01.770Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在iOS10之前，跳转到系统设置界面的某个指定界面的方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//打开定位服务界面</div><div class="line">NSURL*url=[NSURL URLWithString:@&quot;prefs:root=Privacy&amp;path=LOCATION&quot;];</div><div class="line">if ([[UIApplication sharedApplication] canOpenURL:url]) &#123;</div><div class="line">    [[UIApplication sharedApplication] openURL:url];</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>但是在iOS10上，调用canOpenURL:打开系统设置界面时控制台会报如下错误，并且无法跳转：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-canOpenURL: failed for URL: &quot;Prefs:root=Privacy&amp;path=LOCATION&quot; - error: &quot;The operation couldn’t be completed. (OSStatus error -10814.)&quot;</div></pre></td></tr></table></figure></p>
<p>原因是iOS10只允许如下方式跳转到设置里自己app的界面，对跳转到其他界面做了限制：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[UIApplication sharedApplication] openURL:[NSURL URLWithString:UIApplicationOpenSettingsURLString]];</div></pre></td></tr></table></figure></p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>可以使用<code>MobileCoreServices.framework</code>里的私有API:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (BOOL)openSensitiveURL:(id)arg1 withOptions:(id)arg2;</div></pre></td></tr></table></figure></p>
<p>头文件参考：<a href="https://github.com/JaviSoto/iOS10-Runtime-Headers/blob/master/Frameworks/MobileCoreServices.framework/LSApplicationWorkspace.h" target="_blank" rel="external">LSApplicationWorkspace.h</a><br>使用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//注意首字母改成了大写，prefs-&gt;Prefs</div><div class="line">NSURL*url=[NSURL URLWithString:@&quot;Prefs:root=Privacy&amp;path=LOCATION&quot;];</div><div class="line">Class LSApplicationWorkspace = NSClassFromString(@&quot;LSApplicationWorkspace&quot;);</div><div class="line">[[LSApplicationWorkspace performSelector:@selector(defaultWorkspace)] performSelector:@selector(openSensitiveURL:withOptions:) withObject:url withObject:nil];</div></pre></td></tr></table></figure></p>
<p><code>MobileCoreServices.framework</code>不是私有库，所以直接使用<code>performSelector:</code>即可调用私有API。</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li>iOS10的系统URLScheme改成了首字母大写，使用小写的方式会无法打开。</li>
<li>使用私有API的app无法通过App Store审核。你也可以尝试把私有类名和selector字符串混淆一下，绕过审核。例如<a href="http://blog.csdn.net/wenmingzheng/article/details/50475671" target="_blank" rel="external">这位仁兄</a>用ASCII混淆的方法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (UIView *)statusBarView &#123; </div><div class="line">    UIView *statusBar = nil; </div><div class="line">    NSData *data = [NSData dataWithBytes:(unsigned char [])&#123;0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x42, 0x61, 0x72&#125; length:9]; </div><div class="line">    NSString *key = [[NSString alloc] initWithData:data encoding:NSASCIIStringEncoding]; </div><div class="line">    id object = [UIApplication sharedApplication]; </div><div class="line">    if ([object respondsToSelector:NSSelectorFromString(key)]) &#123;</div><div class="line">        statusBar = [object valueForKey:key]; </div><div class="line">    &#125;</div><div class="line">    return statusBar; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不过，还是不建议使用私有API，因为它是不可靠的。也许某天苹果就把它移除了。</p>
<h4 id="update"><a href="#update" class="headerlink" title="update:"></a><em>update:</em></h4><ul>
<li>还有一步遗漏了，app需要添加一个<code>Prefs</code>的URL Schemes，即添加到<code>info.plist</code>的<code>LSApplicationQueriesSchemes</code>项中。</li>
</ul>
<h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><p><a href="http://stackoverflow.com/a/39102075/6380485" target="_blank" rel="external">http://stackoverflow.com/a/39102075/6380485</a><br><a href="https://www.zhihu.com/question/50635906/answer/125195317" target="_blank" rel="external">https://www.zhihu.com/question/50635906/answer/125195317</a><br><a href="https://github.com/cyanzhong/app-tutorials/blob/master/schemes.md" target="_blank" rel="external">iOS10系统URLScheme</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;在iOS10之前，跳转到系统设置界面的某个指定界面的方式如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;ta
    
    </summary>
    
      <category term="私有API" scheme="http://yoursite.com/categories/%E7%A7%81%E6%9C%89API/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
</feed>
