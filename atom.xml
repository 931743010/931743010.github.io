<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zuik&#39;s blog</title>
  <subtitle>写点别人没写过的</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-01-24T01:47:46.110Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zuik</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS VIPER架构实践(三)：面向接口的路由设计</title>
    <link href="http://yoursite.com/2017/09/27/iOS%20VIPER%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5(%E4%B8%89)%EF%BC%9A%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E8%B7%AF%E7%94%B1%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2017/09/27/iOS VIPER架构实践(三)：基于接口的路由设计/</id>
    <published>2017-09-27T15:36:00.000Z</published>
    <updated>2018-01-24T01:47:46.110Z</updated>
    
    <content type="html"><![CDATA[<p>路由是实现模块间解耦的一个有效工具。如果要进行组件化开发，路由是必不可少的一部分。目前iOS上绝大部分的路由工具都是基于URL匹配的，优缺点都很明显。这篇文章里将会给出一个更加原生和安全的设计，这个设计的特点是：</p>
<ul>
<li>路由时用protocol寻找模块</li>
<li><strong>可以对模块进行固定的依赖注入和运行时依赖注入</strong></li>
<li><strong>支持不同模块间进行接口适配和转发，因此无需和某个固定的protocol关联</strong></li>
<li><strong>充分解耦的同时，增加类型安全</strong></li>
<li>支持移除已执行的路由</li>
<li>封装UIKit界面跳转方法，可以一键跳转和移除</li>
<li>支持storyboard，支持其他任意模块</li>
<li>可以检测界面跳转时的大部分错误</li>
</ul>
<p>如果你想要一个能够充分解耦、类型安全、有依赖注入功能的路由器，那这个就是目前所能找到的最佳方案。</p>
<p>这个路由工具是为了实践VIPER模式而设计的，目的是为VIPER提供依赖注入功能，不过它也可以用于MVC、MVP、MVVM，没有任何限制。</p>
<p>工具和Demo地址：<a href="https://github.com/Zuikyo/ZIKRouter" target="_blank" rel="external">ZIKRouter</a>。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li>Router的作用<ul>
<li>路由缺失时的情况</li>
<li>寻找模块</li>
<li>声明依赖和接口</li>
<li>Builder和依赖注入</li>
</ul>
</li>
<li>现有的Router<ul>
<li>URL Router<ul>
<li>优点<ul>
<li>极高的动态性</li>
<li>统一多端路由规则</li>
<li>适配URL scheme</li>
</ul>
</li>
<li>缺点<ul>
<li>不适合通用模块</li>
<li>安全性差</li>
<li>维护困难</li>
</ul>
</li>
</ul>
</li>
<li>Protocol Router<ul>
<li>优点 <ul>
<li>安全性好，维护简单  </li>
<li>适用于所有模块</li>
<li>优雅地声明依赖</li>
</ul>
</li>
<li>缺点<ul>
<li>动态性有限</li>
<li>需要额外适配URL Scheme</li>
</ul>
</li>
<li>Protocol是否会导致耦合？<ul>
<li>业务设计的互相关联</li>
<li><code>Required Interface</code> 和 <code>Provided Interface</code></li>
</ul>
</li>
</ul>
</li>
<li>Target-Action<ul>
<li>优点</li>
<li>缺点</li>
</ul>
</li>
<li>UIStoryboardSegue</li>
<li>总结</li>
</ul>
</li>
<li>ZIKRouter的特性<ul>
<li>离散式管理</li>
<li>自由定义路由参数</li>
<li>移除已执行的路由</li>
<li>通过protocol获取对应模块<ul>
<li>Protocol作为匹配标识</li>
<li>多对一匹配</li>
</ul>
</li>
<li>依赖注入和依赖声明<ul>
<li>固定依赖和运行时依赖</li>
<li>直接在头文件中声明</li>
</ul>
</li>
<li>使用泛型指明特定router</li>
<li>类型安全<ul>
<li>传入正确的protocol</li>
<li>泛型的协变和逆变</li>
</ul>
</li>
<li>用Adapter兼容接口<ul>
<li>为<code>Provided</code>模块添加<code>Required Interface</code></li>
<li>用中介者转发接口</li>
</ul>
</li>
<li>封装UIKit跳转和移除方法<ul>
<li>封装iOS的路由方法</li>
<li>识别<code>adaptative</code>类型的路由</li>
<li>支持自定义路由</li>
<li>关于extension里的跳转方法</li>
</ul>
</li>
<li>支持storyboard</li>
<li>AOP</li>
<li>路由错误检查</li>
<li>支持任意模块</li>
<li>性能</li>
</ul>
</li>
<li>项目地址和Demo</li>
</ul>
<h2 id="Router的作用"><a href="#Router的作用" class="headerlink" title="Router的作用"></a>Router的作用</h2><p>首先，我们需要梳理清楚，为什么我们需要Router，Router能带来什么好处，解决什么问题？我们需要一个什么样的Router？</p>
<h3 id="路由缺失时的情况"><a href="#路由缺失时的情况" class="headerlink" title="路由缺失时的情况"></a>路由缺失时的情况</h3><p>没有路由时，界面跳转的代码就很容易产生模块间耦合。</p>
<p>iOS中执行界面跳转时，用的是UIViewController上提供的跳转方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[sourceViewController.navigationController pushViewController:destinationViewController animated:YES];</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[sourceViewController presentViewController:destinationViewController animated:YES completion:nil];</div></pre></td></tr></table></figure>
<p>如果是直接导入destinationViewController的头文件进行引用，就会导致和destinationViewController模块产生耦合。类似的，一个模块引用另一个模块时也会产生这样的耦合。因此我们需要一个方式来获取destinationViewController，但又不能对其产生直接引用。</p>
<p>这时候就需要路由提供的”寻找模块”的功能。以某种动态的方式获取目的模块。</p>
<p>那么路由是怎么解决模块耦合的呢？在上一篇VIPER讲解里，路由有这几个主要职责：</p>
<ul>
<li>寻找指定模块，执行具体的路由操作</li>
<li>声明模块的依赖</li>
<li>声明模块的对外接口</li>
<li>对模块内各部分进行依赖注入</li>
</ul>
<p>通过这几个功能，就能实现模块间的完全解耦。</p>
<h3 id="寻找模块"><a href="#寻找模块" class="headerlink" title="寻找模块"></a>寻找模块</h3><p>路由最重要的功能就是给出一种寻找某个指定模块的方案。这个方案是松耦合的，获取到的模块在另一端可以随时被另一个相同功能的模块替换，从而实现两个模块之间的解耦。</p>
<p>寻找模块的实现方式其实只有有限的几种：</p>
<ul>
<li>用一个字符串identifier来标识某个对应的界面（URL Router、UIStoryboardSegue）</li>
<li>利用Objective-C的runtime特性，直接调用目的模块的方法（CTMediator）</li>
<li>用一个protocol来和某个界面进行匹配（蘑菇街的第二种路由和阿里的BeeHive），这样就可以更安全的对目的模块进行传参</li>
</ul>
<p>这几种方案的优劣将在之后逐一细说。</p>
<h3 id="声明依赖和接口"><a href="#声明依赖和接口" class="headerlink" title="声明依赖和接口"></a>声明依赖和接口</h3><p>一个模块A有时候需要使用其他模块的功能，例如最通用的log功能，不同的app有不同的log模块，如果模块A对通用性要求很高，log方法就不能在模块A里写死，而是应该通过外部调用。这时这个模块A就依赖于一个log模块了。App在使用模块A的时候，需要知道它的依赖，从而在使用模块A之前，对其注入依赖。</p>
<p>当通过cocoapods这样的包管理工具来配置不同模块间的依赖时，一般模块之间是强耦合的，模块是一一对应的，当需要替换一个模块时会很麻烦，容易牵一发而动全身。如果是一个单一功能模块，的确需要依赖其他特定的各种库时，那这样做没有问题。但是如果是一个业务模块中引用了另一个业务模块，就应该尽量避免互相耦合。因为不同的业务模块一般是由不同的人负责，应该避免出现一个业务模块的简单修改（例如调整了方法或者属性的名字）导致引用了它的业务模块也必须修改的情况。</p>
<p>这时候，业务模块就需要在代码里声明自己需要依赖的模块，让app在使用时提供这些模块，从而充分解耦。</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@protocol ZIKLoginServiceInput &lt;NSObject&gt;</div><div class="line">- (void)loginWithAccount:(NSString *)account</div><div class="line">                password:(NSString *)password</div><div class="line">                 success:(void(^_Nullable)(void))successHandler</div><div class="line">                   error:(void(^_Nullable)(void))errorHandler;</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@interface ZIKNoteListViewController ()</div><div class="line">//笔记界面需要登录后才能查看，因此在头文件中声明，让外部在使用的时候设置此属性</div><div class="line">@property (nonatomic, strong) id&lt;ZIKLoginServiceInput&gt; loginService;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这个声明依赖的工作其实是模块的Builder的职责。一个界面模块大部分情况下都不止有一个UIViewController，也有其他一些Manager或者Service，而这些角色都是有各自的依赖的，都统一由模块的Builder声明，再在Builder内部设置依赖。不过在上一篇文章的VIPER讲解里，我们把Builder的职责也放到了Router里，让每个模块单独提供一个自己的Router。因此在这里，Router是一个离散的设计，而不是一个单例Router掌管所有的路由。这样的好处就是每个模块可以充分定制和控制自己的路由过程。</p>
<p>可以声明依赖，也就可以同时声明模块的对外接口。这两者很相似，所以不再重复说明。</p>
<h3 id="Builder和依赖注入"><a href="#Builder和依赖注入" class="headerlink" title="Builder和依赖注入"></a>Builder和依赖注入</h3><p>执行路由的同时用Builder进行模块构建，构建的时候就对模块内各个角色进行依赖注入。当你调用某个模块的时候，需要的不是某个简单的具体类，而是一个构建完毕的模块中的某个具体类。在使用这个模块前，模块需要做一些初始化的操作，比如VIPER里设置各个角色之间的依赖关系，就是一个初始化操作。因此使用路由去获取某个模块中的类，必定需要通过模块的Builder进行。很多路由工具都缺失了这部分功能。</p>
<p>你可以把依赖注入简单地看成对目的模块传参。在进行界面跳转和使用某个模块时，经常需要设置目的模块的一些参数，例如设置delegate回调。这时候就必须调用一些目的模块的方法，或者传递一些对象。由于每个模块需要的参数都不一样，目前大部分Router都是使用字典包裹参数进行传递。但其实还有更好、更安全的方案，下面将会进行详解。</p>
<p>你也可以把Router、Builder和Dependency Injector分开，不过如果Router是一个离散型的设计，那么都交给各自的Router去做也很合理，同时能够减少代码量，也能够提供细粒度的AOP。</p>
<h2 id="现有的Router"><a href="#现有的Router" class="headerlink" title="现有的Router"></a>现有的Router</h2><p>梳理完了路由的职责，现在来比较一下现有的各种Router方案。关于各个方案的具体实现细节我就不再展开看，可以参考这篇详解的文章：<a href="http://www.jianshu.com/p/76da56b3bd55" target="_blank" rel="external">iOS 组件化 —— 路由设计思路分析</a>。</p>
<h3 id="URL-Router"><a href="#URL-Router" class="headerlink" title="URL Router"></a>URL Router</h3><p>目前绝大多数的Router都是用一串URL来表示需要打开的某个界面，代码上看来大概是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//注册某个URL，和路由处理进行匹配保存</div><div class="line">[URLRouter registerURL:@&quot;settings&quot; handler:^(NSDictionary *userInfo) &#123;</div><div class="line">	UIViewController *sourceViewController = userInfo[@&quot;sourceViewController&quot;];</div><div class="line">	//获取其他参数</div><div class="line">	id param = userInfo[@&quot;param&quot;];</div><div class="line">	//获取需要的界面</div><div class="line">	UIViewController *settingViewController = [[SettingViewController alloc] init];</div><div class="line">	[sourceViewController.navigationController pushViewController: settingViewController animated:YES];</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//调用路由</div><div class="line">[URLRouter openURL:@&quot;myapp://noteList/settings?debug=true&quot; userInfo:params completion:^(NSDictionary *info) &#123;</div><div class="line"></div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>传递一串URL就能打开noteList界面的settings界面，用字典包裹需要传递的参数，有时候还会把UIKit的push、present等方法进行简单封装，提供给调用者。</p>
<p>这种方式的优点和缺点都很突出。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><h5 id="极高的动态性"><a href="#极高的动态性" class="headerlink" title="极高的动态性"></a>极高的动态性</h5><p>这是动态性最高的方案，甚至可以在运行时随时修改路由规则，指向不同的界面。也可以很轻松地支持多级页面的跳转。</p>
<p>如果你的app是电商类app，需要经常做活动，app内的跳转规则经常变动，那么就很适合使用URL的方案。</p>
<h5 id="统一多端路由规则"><a href="#统一多端路由规则" class="headerlink" title="统一多端路由规则"></a>统一多端路由规则</h5><p>URL的方案是最容易跨平台实现的，iOS、Andorid、web、PC都按照URL来进行路由时，也就可以统一管理多端的路由规则，降低多端各自维护和修改的成本，让不懂技术的运营人员也可以简单快速地修改路由。</p>
<p>和上一条一样，这也是一个和业务强相关的优点。如果你有统一多端的业务需求，使用URL也很合适。</p>
<h5 id="适配URL-scheme"><a href="#适配URL-scheme" class="headerlink" title="适配URL scheme"></a>适配URL scheme</h5><p>iOS中的URL scheme可以跨进程通信，从app外打开app内的某个指定页面。当app内的页面都能使用URL打开时，也就直接兼容了URL scheme，无需再做额外的工作。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><h5 id="不适合通用模块"><a href="#不适合通用模块" class="headerlink" title="不适合通用模块"></a>不适合通用模块</h5><p>URL Router的设计只适合UI模块，不适合其他功能性模块的组件。功能性模块的调用并不需要如此强的动态特性，除非是有模块热更新的需求，否则一个模块的调用在一个版本里应该总是稳定不变的，即便要进行模块间解耦，也不应该用这种方式。</p>
<h5 id="安全性差"><a href="#安全性差" class="headerlink" title="安全性差"></a>安全性差</h5><p>字符串匹配的方式无法进行编译时检查，当页面配置出错时，只能在运行时才能发现。如果某个开发人员不小心在字符串里加了一个空格，编译时也无法发现。你可以用宏定义来减少这种出错的几率。</p>
<h5 id="维护困难"><a href="#维护困难" class="headerlink" title="维护困难"></a>维护困难</h5><p>没有高效地声明接口的方式，只能从文档里查找，编写时必须仔细对照字符串及其参数类型。</p>
<p>传参通过字典来进行，参数类型无法保证，而且也无法准确地知道所调用的接口需要哪些参数。当目的模块进行了接口升级，修改了参数类型和数量，那所有用到的地方都要一一修改，并且没有编译器的帮助，你无法知道是否遗漏了某些地方。这将会给维护和重构带来极大的成本。</p>
<p>针对这个问题，蘑菇街的选择是用另一个Router，用protocol来获取目的模块，再进行调用，增加安全性。</p>
<h3 id="Protocol-Router"><a href="#Protocol-Router" class="headerlink" title="Protocol Router"></a>Protocol Router</h3><p>这个方案也很容易理解。把之前的字符串匹配改成了protocol匹配，就能获取到一个实现了某个protocol的对象。</p>
<p>开源方案里只看到了<a href="https://github.com/alibaba/BeeHive" target="_blank" rel="external">BeeHive</a>实现了这样的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id&lt;ZIKLoginServiceInput&gt; loginService = [[BeeHive shareInstance] createService:@protocol(ZIKLoginServiceInput)];</div></pre></td></tr></table></figure>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><h5 id="安全性好，维护简单"><a href="#安全性好，维护简单" class="headerlink" title="安全性好，维护简单"></a>安全性好，维护简单</h5><p>再对这个对象调用protocol中的方法，就十分安全了。在重构和修改时，有了编译器的类型检查，效率更高。</p>
<h5 id="适用于所有模块"><a href="#适用于所有模块" class="headerlink" title="适用于所有模块"></a>适用于所有模块</h5><p>Protocol更加符合OC和Swift原生的设计思想，任何模块都可以使用，而不局限于UI模块。</p>
<h5 id="优雅地声明依赖"><a href="#优雅地声明依赖" class="headerlink" title="优雅地声明依赖"></a>优雅地声明依赖</h5><p>模块A需要用到登录模块，但是它要怎么才能声明这种依赖关系呢？如果使用Protocol Router，那就只需要在头文件里定义一个属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, string) id&lt;ZIKLoginServiceInput&gt; *loginService;</div></pre></td></tr></table></figure>
<p>如果这个依赖是必需依赖，而不是一个可选依赖，那就添加到初始化参数里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface ModuleA ()</div><div class="line">- (instancetype)initWithLoginService:(id&lt;ZIKLoginServiceInput&gt;)loginService;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>问题是，如果这样的依赖很多，那么初始化方法就会变得很长。因此更好的做法是由Builder进行固定的依赖注入，再提供给外部。目前BeeHive并没有提供依赖注入的功能。</p>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><h5 id="动态性有限"><a href="#动态性有限" class="headerlink" title="动态性有限"></a>动态性有限</h5><p>你可以维护一份protocol和模块的对照表，使用动态的protocol来尝试动态地更改路由规则，也可以在Protocol Router之上封装一层URL Router专门用于动态性的需求。</p>
<h5 id="需要额外适配URL-Scheme"><a href="#需要额外适配URL-Scheme" class="headerlink" title="需要额外适配URL Scheme"></a>需要额外适配URL Scheme</h5><p>使用了Protocol Router就需要再额外处理URL Scheme了。不过这样也是正常的，解析URL Scheme本来就应该放到另一个单独的模块里。</p>
<h4 id="Protocol是否会导致耦合？"><a href="#Protocol是否会导致耦合？" class="headerlink" title="Protocol是否会导致耦合？"></a>Protocol是否会导致耦合？</h4><p>很多谈到这种方案的文章都会指出，和URL Router相比，Protocol Router会导致调用者引用目的模块的protocol，因此会产生”耦合”。我认为这是对”解耦”的错误理解。</p>
<p>要想避免耦合，首先要弄清楚，我们需要什么程度的解耦。我的定义是：模块A调用了模块B，模块B的接口或者实现在做出简单的修改时，或者模块B被替换为相同功能的模块C时，模块A不需要进行任何修改。这时候就可以认为模块A和模块B是解耦的。</p>
<h5 id="业务设计的互相关联"><a href="#业务设计的互相关联" class="headerlink" title="业务设计的互相关联"></a>业务设计的互相关联</h5><p>有些时候，表达出两个模块之间的关联是有意义的。</p>
<p>当一个界面A需要展示一个登录界面时，它可能需要向登录界面传递一个”提示语”参数，用于在登录界面显示一串提示。这时候，界面A在调用登录界面时，是要求登录界面能够显示这个自定义提示语的，在业务设计中就存在两个模块间的强关联性。这时候，URL Router和Protocol Router没有任何区别，包括下面将要提到的<code>Target-Action</code>路由方式，都存在耦合，但是Protocol Router通过简单地改善，是可以把这部分耦合去除的。</p>
<p>URL Router：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[URLRouter openURL:@&quot;login&quot; userInfo:@&#123;@&quot;message&quot;:@&quot;请登录查看笔记详情&quot;&#125;];</div></pre></td></tr></table></figure>
<p>Protocol Router:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@protocol LoginViewInput &lt;NSObject&gt;</div><div class="line">@property (nonatomic, copy) NSString *message;</div><div class="line">@end</div><div class="line"></div><div class="line">//获取登录界面进行设置</div><div class="line">UIViewController&lt;LoginViewInput&gt; *loginViewController = [ProtocolRouter destinationForProtocol:@protocol(LoginViewInput)];</div><div class="line">loginViewController.message = @&quot;请登录查看笔记详情&quot;;</div></pre></td></tr></table></figure>
<p>由于字典传参的原因，URL Router只不过是把这种接口上的关联隐藏到了字典key里，它在参数字典里使用<code>@&quot;message&quot;</code>时，就是在隐式地使用<code>LoginViewInput</code>的接口。</p>
<p>这种业务设计上导致的模块之间互相关联是不可避免的，也是不需要去隐藏的。隐藏了反而会引来麻烦。如果登录界面的属性名字变了，从<code>NSString *message</code>改成了<code>NSString *notifyString</code>，那么URL Router在register的时候也必须修改传参时的代码。如果register是由登录界面自己执行和处理的，而不是由App Context来处理的，那么此时参数key是固定为<code>@&quot;notifyString&quot;</code>的，那就会要求所有调用者的传参key也修改为<code>notifyString</code>，这种修改如果缺少编译器的帮助会很危险，目前是用宏来减少这种修改导致的工作量。而Protocol Router在修改时就能充分利用编译器进行检查，能够保证100%安全。</p>
<p>因此，URL Router并不能做到解耦，只是隐藏了接口关联而已。一旦遇到了需要修改或者重构的情况，麻烦就出现了，在替换宏的时候，你还必须仔细检查有没有哪里有直接使用字符串的key。只是简单地修改名字还是可控的，如果是需要增加参数呢？这时候就根本无法检查哪里遗漏了参数传递了。这就是字典传参的坏处。</p>
<p>关于这部分的讨论，也可以参考Peak大佬的文章：<a href="http://mrpeak.cn/blog/module/" target="_blank" rel="external">iOS组件化方案</a>。</p>
<p>Protocol Router在这种情况下也需要作出修改，但是它能帮助你安全高效地进行重构。而且只要稍加改进，也可以完全无需修改。解决方法就是把Protocol分离为<code>Required Interface</code>和<code>Provided Interface</code>。</p>
<h5 id="Required-Interface-和-Provided-Interface"><a href="#Required-Interface-和-Provided-Interface" class="headerlink" title="Required Interface 和 Provided Interface"></a><code>Required Interface</code> 和 <code>Provided Interface</code></h5><p>模块的接口其实是有<code>Required Interface</code>和<code>Provided Interface</code>的区别的。<code>Required Interface</code>就是调用者需要用到的接口，<code>Provided Interface</code>就是实际的被调用者提供的接口。</p>
<p>在UML的<a href="http://www.uml-diagrams.org/component-diagrams.html" target="_blank" rel="external">组件图</a>中，就很明确地表现出了这两者的概念。下图中的半圆就是<code>Required Interface</code>，框外的圆圈就是<code>Provided Interface</code>：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5879294-6309bffe07ebf178.png?imageMogr2/auto-orient/strip%7CimageView2/2" alt="组件图"></p>
<p>那么如何实施<code>Required Interface</code>和<code>Provided Interface</code>？上一篇文章里已经讨论过，应该由App Context在一个adapter里进行接口适配，从而使得调用者可以继续在内部使用<code>Required Interface</code>，adapter负责把<code>Required Interface</code>和修改后的<code>Provided Interface</code>进行适配。</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@protocol ModuleARequiredLoginViewInput &lt;NSObject&gt;</div><div class="line">@property (nonatomic, copy) NSString *message;</div><div class="line">@end</div><div class="line"></div><div class="line">//Module A中的调用代码</div><div class="line">UIViewController&lt;ModuleARequiredLoginViewInput&gt; *loginViewController = [ProtocolRouter destinationForProtocol:@protocol(LoginViewInput)];</div><div class="line">loginViewController.message = @&quot;请登录查看笔记详情&quot;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//Login Module Provided Interface</div><div class="line">@protocol ProvidedLoginViewInput &lt;NSObject&gt;</div><div class="line">@property (nonatomic, copy) NSString *notifyString;</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//App Context 中的 Adapter，用Objective-C的category或者Swift的extension进行接口适配</div><div class="line">@interface LoginViewController (ModuleAAdapte) &lt;ModuleARequiredLoginViewInput&gt;</div><div class="line">@property (nonatomic, copy) NSString *message;</div><div class="line">@end</div><div class="line">@implementation LoginViewController (ModuleAAdapte)</div><div class="line">- (void)setMessage:(NSString *)message &#123;</div><div class="line">	self.notifyString = message;</div><div class="line">&#125;</div><div class="line">- (NSString *)message &#123;</div><div class="line">	return self.notifyString;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>用category、extension、NSProxy等技术兼容新旧接口，工作全部由模块的使用和装配者<code>App Context</code>完成。如果<code>LoginViewController</code>已经有了自己的<code>message</code>属性，这时候就说明新的登录模块是不可兼容的，必须有某一方做出修改。当然，接口适配能做的事情是有限的，例如一个接口从同步变成了异步，那么这时候两个模块也是不能兼容的。</p>
<p>因此，如果模块需要进行解耦，那么它的接口在设计的时候就应该十分仔细，尽量不要在参数中引入太多其他的模块依赖。</p>
<p>只有存在<code>Required Interface</code>和<code>Provided Interface</code>概念的设计，才能做到彻底的解耦。目前的路由方案都缺失了这一部分。</p>
<h3 id="Target-Action"><a href="#Target-Action" class="headerlink" title="Target-Action"></a>Target-Action</h3><p><a href="https://casatwy.com/iOS-Modulization.html" target="_blank" rel="external">CTMediator</a>的方案，把对模块的调用封装到Target-Action中，利用了Objective-C的runtime特性，省略了Target-Action的注册和绑定工作，直接通过CTMediator中介者调用目的模块的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">@implementation CTMediator (CTMediatorModuleAActions)</div><div class="line">- (UIViewController *)CTMediator_viewControllerForDetail</div><div class="line">&#123;</div><div class="line">    UIViewController *viewController = [self performTarget:kCTMediatorTargetA</div><div class="line">                                                    action:kCTMediatorActionNativFetchDetailViewController</div><div class="line">                                                    params:@&#123;@&quot;key&quot;:@&quot;value&quot;&#125;</div><div class="line">                                         shouldCacheTarget:NO</div><div class="line">                                        ];</div><div class="line">    if ([viewController isKindOfClass:[UIViewController class]]) &#123;</div><div class="line">        // view controller 交付出去之后，可以由外界选择是push还是present</div><div class="line">        return viewController;</div><div class="line">    &#125; else &#123;</div><div class="line">        // 这里处理异常场景，具体如何处理取决于产品</div><div class="line">        return [[UIViewController alloc] init];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p><code>-performTarget:action:params:shouldCacheTarget:</code>方法通过<code>NSClassFromString</code>，获取目的模块提供的Target类，再调用Target提供的Action，实现了方法调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">@implementation CTMediator</div><div class="line">- (id)performTarget:(NSString *)targetName action:(NSString *)actionName params:(NSDictionary *)params shouldCacheTarget:(BOOL)shouldCacheTarget</div><div class="line">&#123;</div><div class="line">    </div><div class="line">    NSString *targetClassString = [NSString stringWithFormat:@&quot;Target_%@&quot;, targetName];</div><div class="line">    NSString *actionString = [NSString stringWithFormat:@&quot;Action_%@:&quot;, actionName];</div><div class="line">    Class targetClass;</div><div class="line">    </div><div class="line">    NSObject *target = self.cachedTarget[targetClassString];</div><div class="line">    if (target == nil) &#123;</div><div class="line">        targetClass = NSClassFromString(targetClassString);</div><div class="line">        target = [[targetClass alloc] init];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    SEL action = NSSelectorFromString(actionString);</div><div class="line">    </div><div class="line">    if (target == nil) &#123;</div><div class="line">        // 这里是处理无响应请求的地方之一，这个demo做得比较简单，如果没有可以响应的target，就直接return了。实际开发过程中是可以事先给一个固定的target专门用于在这个时候顶上，然后处理这种请求的</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (shouldCacheTarget) &#123;</div><div class="line">        self.cachedTarget[targetClassString] = target;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if ([target respondsToSelector:action]) &#123;</div><div class="line">        return [self safePerformAction:action target:target params:params];</div><div class="line">    &#125; else &#123;</div><div class="line">        // 有可能target是Swift对象</div><div class="line">        actionString = [NSString stringWithFormat:@&quot;Action_%@WithParams:&quot;, actionName];</div><div class="line">        action = NSSelectorFromString(actionString);</div><div class="line">        if ([target respondsToSelector:action]) &#123;</div><div class="line">            return [self safePerformAction:action target:target params:params];</div><div class="line">        &#125; else &#123;</div><div class="line">            // 这里是处理无响应请求的地方，如果无响应，则尝试调用对应target的notFound方法统一处理</div><div class="line">            SEL action = NSSelectorFromString(@&quot;notFound:&quot;);</div><div class="line">            if ([target respondsToSelector:action]) &#123;</div><div class="line">                return [self safePerformAction:action target:target params:params];</div><div class="line">            &#125; else &#123;</div><div class="line">                // 这里也是处理无响应请求的地方，在notFound都没有的时候，这个demo是直接return了。实际开发过程中，可以用前面提到的固定的target顶上的。</div><div class="line">                [self.cachedTarget removeObjectForKey:targetClassString];</div><div class="line">                return nil;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul>
<li>实现简洁，整个实现的代码量很少</li>
<li>省略了路由注册的步骤，可以减少一部分内存消耗和时间消耗，但是也略微降低了调用时的性能</li>
<li>使用场景不局限于界面模块，所有模块都可以通过中介者调用</li>
</ul>
<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>在调用action时使用字典传参，无法保证类型安全，维护困难</li>
<li>直接使用runtime互相调用，难以明确地区分<code>Required Interface</code>和<code>Provided Interface</code>，因此其实无法实现完全解耦。和URL Router一样，在目的模块变化时，调用模块也必须做出修改</li>
<li>过于依赖runtime特性，和Swift的类型安全设计是不兼容的，也无法跨平台多端实现</li>
</ul>
<h3 id="UIStoryboardSegue"><a href="#UIStoryboardSegue" class="headerlink" title="UIStoryboardSegue"></a>UIStoryboardSegue</h3><p>苹果的storyboard其实也有一套路由API，只不过它的局限性很大。在这里简单介绍一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">@implementation SourceViewController</div><div class="line"></div><div class="line">- (void)showLoginViewController &#123;</div><div class="line">	//调用在storyboard中定义好的segue identifier</div><div class="line">	[self performSegueWithIdentifier:@&quot;presentLoginViewController&quot; sender:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">//perform segue时的回调</div><div class="line">- (BOOL)shouldPerformSegueWithIdentifier:(NSString *)identifier sender:(nullable id)sender &#123;</div><div class="line">    return YES;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//配置目的界面</div><div class="line">- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender &#123;</div><div class="line">    //用[segue destinationViewController]获取目的界面，再对目的界面进行传参</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>UIStoryboardSegue是和storyboard一起使用的，storyboard中定义好了一些界面跳转的参数，比如转场方式（push、present等），在执行路由前，执行路由的UIViewController会收到回调，让调用者配置目的界面的参数。</p>
<p>在storyboard中连接segue，其实是跳转到一个已经配置好界面的view controller，也就是和View相关的参数，都已经做好了依赖注入。但是自定义的依赖，却还是需要在代码中注入，所以又给了我们一个<code>-prepareForSegue:sender:</code>回调。</p>
<p>我不建议使用segue，因为它会导致强耦合。但是我们可以借鉴UIStoryboardSegue的sourceViewController、destinationViewController、封装跳转逻辑到segue子类、对页面执行依赖注入等设计。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结了几个路由工具之后，我的结论是：路由的选择还是以业务需求为先。当对动态性要求极高、或者需要多平台统一路由，则选择URL Router，其他情况下，我更倾向于使用Protocol Router。和Peak大大的结论一致。</p>
<p>Protocol Router目前并没有一个成熟的开源方案。因此我造了个轮子，增加了上面提到的一些需求。</p>
<h2 id="ZIKRouter的特性"><a href="#ZIKRouter的特性" class="headerlink" title="ZIKRouter的特性"></a>ZIKRouter的特性</h2><h3 id="离散式管理"><a href="#离散式管理" class="headerlink" title="离散式管理"></a>离散式管理</h3><p>每个模块都对应一个或者多个router子类，在子类中管理各自的路由过程，包括对象的生成、模块的初始化、路由状态管理、AOP等。路由时，需要使用对应的router子类，而不是一个单例router掌管所有的路由。如果想要避免引用子类带来的耦合，可以用protocol动态获取router子类，或者用父类+泛型在调用者中代替子类。</p>
<p>采用离散式的设计的原因是想让各个模块对路由拥有充分的控制权。</p>
<p>一个router子类的简单实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">@interface ZIKLoginViewRouter : ZIKViewRouter</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ZIKLoginViewRouter</div><div class="line">//app启动时，注册对应的模块和Router</div><div class="line">//不使用+load和+initialize方法，因为在Swift中已经不适用</div><div class="line">+ (void)registerRoutableDestination &#123;</div><div class="line">    [self registerView:[ZIKLoginViewController class]];</div><div class="line">    [self registerViewProtocol:ZIKRoutableProtocol(ZIKLoginViewProtocol)];</div><div class="line">&#125;</div><div class="line">//执行路由时，返回对应的viewController或者UIView</div><div class="line">- (id)destinationWithConfiguration:(ZIKViewRouteConfiguration *)configuration &#123;</div><div class="line">    UIStoryboard *sb = [UIStoryboard storyboardWithName:@&quot;Main&quot; bundle:nil];</div><div class="line">    ZIKLoginViewController *destination = [sb instantiateViewControllerWithIdentifier:@&quot;ZIKLoginViewController&quot;];</div><div class="line">    return destination;</div><div class="line">&#125;</div><div class="line">//检查模块是否已经初始化完毕</div><div class="line">+ (BOOL)destinationPrepared:(UIViewController&lt;ZIKLoginViewProtocol&gt; *)destination &#123;</div><div class="line">    if (destination.loginService != nil) &#123;</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    return NO;</div><div class="line">&#125;</div><div class="line">//初始化工作</div><div class="line">- (void)prepareDestination:(UIViewController&lt;ZIKLoginViewProtocol&gt; *)destination configuration:(__kindof ZIKViewRouteConfiguration *)configuration &#123;</div><div class="line">    if (destination.loginService == nil) &#123;</div><div class="line">        //ZIKLoginService也可以用ZIKServiceRouter动态获取</div><div class="line">        destination.loginService = [ZIKLoginService new];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//路由时的AOP回调</div><div class="line">+ (void)router:(nullable ZIKViewRouter *)router willPerformRouteOnDestination:(id)destination fromSource:(id)source &#123;</div><div class="line">&#125;</div><div class="line">+ (void)router:(nullable ZIKViewRouter *)router didPerformRouteOnDestination:(id)destination fromSource:(id)source &#123;</div><div class="line">&#125;</div><div class="line">+ (void)router:(nullable ZIKViewRouter *)router willRemoveRouteOnDestination:(id)destination fromSource:(id)source &#123;</div><div class="line">&#125;</div><div class="line">+ (void)router:(nullable ZIKViewRouter *)router didRemoveRouteOnDestination:(id)destination fromSource:(id)source &#123;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>你甚至可以在不同情况下返回不同的destination，而调用者对此完全不知情。例如一个alertViewRouter为了兼容UIAlertView和UIAlertController，可以在router内部，iOS8以上使用UIAlertController，iOS8以下则使用UIAlertView。</p>
<p>一切路由的控制都在router类内部，不需要模块做出任何额外的修改。</p>
<h3 id="自由定义路由参数"><a href="#自由定义路由参数" class="headerlink" title="自由定义路由参数"></a>自由定义路由参数</h3><p>路由的配置信息都存储在configuration里，在调用者执行路由的时候传入。基本的跳转方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//跳转到Login界面</div><div class="line">[ZIKLoginViewRouter</div><div class="line">    performFromSource:self //界面跳转时的源界面</div><div class="line">    configuring:^(ZIKViewRouteConfiguration *config) &#123;</div><div class="line">        //跳转类型，支持push、presentModally、presentAsPopover、performSegue、show、showDetail、addChild、addSubview、custom、getDestination</div><div class="line">        config.routeType = ZIKViewRouteTypePush;</div><div class="line">        config.animated = NO;</div><div class="line">        config.prepareDestination = ^(id&lt;ZIKLoginViewProtocol&gt; destination) &#123;</div><div class="line">            //跳转前配置界面</div><div class="line">        &#125;;</div><div class="line">        config.routeCompletion = ^(id&lt;NoteEditorProtocol&gt; destination) &#123;</div><div class="line">         //跳转成功并结束处理</div><div class="line">      &#125;;</div><div class="line">      config.performerErrorHandler = ^(ZIKRouteAction routeAction, NSError * error) &#123;</div><div class="line">         //跳转失败处理，有失败的详细信息</div><div class="line">      &#125;;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>Configuration只能在初始化block里配置，出了block以后就无法修改。你也可以用一个configuration子类添加更多自定义信息。</p>
<p>如果不需要复杂的配置，也可以只用最简单的跳转：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[ZIKLoginViewRouter performFromSource:self routeType:ZIKViewRouteTypePush];</div></pre></td></tr></table></figure>
<h3 id="移除已执行的路由"><a href="#移除已执行的路由" class="headerlink" title="移除已执行的路由"></a>移除已执行的路由</h3><p>你可以先初始化一个router，再交给其他角色执行路由：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//初始化router</div><div class="line">self.loginRouter = [[ZIKLoginViewRouter alloc] initWithConfiguring:^(ZIKViewRouteConfiguration * _Nonnull config) &#123;</div><div class="line">                               config.source = self;</div><div class="line">                               config.routeType = ZIKViewRouteTypePush;</div><div class="line">                           &#125;];</div><div class="line">                           </div><div class="line">//执行路由</div><div class="line">if ([self.loginRouter canPerform] == NO) &#123;</div><div class="line">    NSLog(@&quot;此时无法执行路由:%@&quot;,self.loginRouter);</div><div class="line">    return;</div><div class="line">&#125;</div><div class="line">[self.loginRouter performRouteWithSuccessHandler:^&#123;</div><div class="line">    NSLog(@&quot;performer: push success&quot;);</div><div class="line">&#125; performerErrorHandler:^(ZIKRouteAction routeAction, NSError * _Nonnull error) &#123;</div><div class="line">    NSLog(@&quot;performer: push failed: %@&quot;,error);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>当你需要消除已经展示的界面，或者销毁一个模块时，可以调用移除路由方法一键移除：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">if ([self.loginRouter canRemove] == NO) &#123;</div><div class="line">    NSLog(@&quot;此时无法移除路由:%@&quot;, self.loginRouter);</div><div class="line">    return;</div><div class="line">&#125;</div><div class="line">[self.loginRouter removeRouteWithSuccessHandler:^&#123;</div><div class="line">    NSLog(@&quot;performer: pop success&quot;);</div><div class="line">&#125; performerErrorHandler:^(ZIKRouteAction routeAction, NSError * _Nonnull error) &#123;</div><div class="line">    NSLog(@&quot;performer: pop failed,error:%@&quot;,error);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>从而无需再区分调用pop、dismiss、removeFromParentViewController、removeFromSuperview等方法。</p>
<h3 id="通过protocol获取对应模块"><a href="#通过protocol获取对应模块" class="headerlink" title="通过protocol获取对应模块"></a>通过protocol获取对应模块</h3><h4 id="Protocol作为匹配标识"><a href="#Protocol作为匹配标识" class="headerlink" title="Protocol作为匹配标识"></a>Protocol作为匹配标识</h4><p>我们不想让外部引用<code>ZIKLoginViewRouter</code>头文件导致耦合，调用者只需要获取一个符合了<code>ZIKLoginViewProtocol</code>的view controller，因此只需要根据<code>ZIKLoginViewProtocol</code>获取到对应的router子类，然后在子类上调用父类<code>ZIKViewRouter</code>提供的路由方法即可，这样就可以做到隐藏子类。</p>
<p>使用<code>ZIKViewRouterToView</code>和<code>ZIKViewRouterToModule</code>宏，即可通过protocol获取到对应的router子类，并且子类返回的destination必定符合<code>ZIKLoginViewProtocol</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[ZIKViewRouterToView(ZIKLoginViewProtocol)</div><div class="line">    performFromSource:self</div><div class="line">    configuring:^(ZIKViewRouteConfiguration *config) &#123;</div><div class="line">         config.routeType = ZIKViewRouteTypePush;</div><div class="line">         config.prepareDestination = ^(id&lt;ZIKLoginViewProtocol&gt; destination) &#123;</div><div class="line">             //跳转前配置界面</div><div class="line">         &#125;;</div><div class="line">         config.routeCompletion = ^(id&lt;ZIKLoginViewProtocol&gt; destination) &#123;</div><div class="line">	         //跳转成功并结束处理</div><div class="line">	      &#125;;</div><div class="line"> &#125;];</div></pre></td></tr></table></figure>
<p>这时候<code>ZIKLoginViewProtocol</code>就相当于LoginView模块的唯一identifier，不能再用到其他view controller上。你可以用多个protocol注册同一个router，用于区分<code>requiredProtocol</code>和<code>providedProtocol</code>。</p>
<h4 id="多对一匹配"><a href="#多对一匹配" class="headerlink" title="多对一匹配"></a>多对一匹配</h4><p>有时候，一些第三方的模块或者系统模块并没有提供自己的router，你可以为其封装一个router，此时可以有多个不同的router管理同一个UIViewController或者UIView类。这些router可能提供了不同的功能，比如同样是alertRouter，routerA可能是用于封装UIAlertController，routerB可能是用于兼容UIAlertView和UIAlertController，这时候要如何区分并获取两个不同的router？</p>
<p>像这种提供了独特功能的router，需要你使用configuration的子类，然后让子类conform对应功能的protocol。于是就可以根据configuration的protocol来获取对应的router：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">[ZIKViewRouterToModule(ZIKCompatibleAlertConfigProtocol)</div><div class="line">    performFromSource:self</div><div class="line">    configuring:^(ZIKViewRouteConfiguration&lt;ZIKCompatibleAlertConfigProtocol&gt; * _Nonnull config) &#123;</div><div class="line"> 	config.routeType = ZIKViewRouteTypeCustom;</div><div class="line"> 	config.title = @&quot;Compatible Alert&quot;;</div><div class="line"> 	config.message = @&quot;Test custom route for alert with UIAlertView and UIAlertController&quot;;</div><div class="line"> 	[config addCancelButtonTitle:@&quot;Cancel&quot; handler:^&#123;</div><div class="line">	 	NSLog(@&quot;Tap cancel alert&quot;);</div><div class="line"> 	&#125;];</div><div class="line"> 	[config addOtherButtonTitle:@&quot;Hello&quot; handler:^&#123;</div><div class="line">	 	NSLog(@&quot;Tap hello button&quot;);</div><div class="line"> 	&#125;];</div><div class="line"> 	config.routeCompletion = ^(id _Nonnull destination) &#123;</div><div class="line">	 	NSLog(@&quot;show custom alert complete&quot;);</div><div class="line"> 	&#125;;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>如果模块自己提供了router，并且这个router用于依赖注入，不能被其他router替代，可以声明本router为本模块的唯一指定router，当有多个router尝试管理此模块时，启动时就会产生断言错误。</p>
<h3 id="依赖注入和依赖声明"><a href="#依赖注入和依赖声明" class="headerlink" title="依赖注入和依赖声明"></a>依赖注入和依赖声明</h3><h4 id="固定依赖和运行时依赖"><a href="#固定依赖和运行时依赖" class="headerlink" title="固定依赖和运行时依赖"></a>固定依赖和运行时依赖</h4><p>模块的依赖分为固定依赖和运行时参数依赖。</p>
<p>固定依赖就类似于VIPER各角色之间的依赖关系，是一个模块中固定不变的依赖。这种依赖只需要在router内部的<code>-prepareDestination:configuration:</code>固定配置即可。</p>
<p>运行时依赖就是外部传入的参数，由configuration负责传递，然后同样是在<code>-prepareDestination:configuration:</code>中，获取configuration并配置destination。你可以用一个configuration子类和router配对，这样就能添加更多自定义信息。</p>
<p>如果依赖参数很简单，也可以让router直接对destination进行配置，声明router的destination遵守<code>ZIKLoginViewProtocol</code>，让调用者在<code>prepareDestination</code>里设置destination。但是如果依赖涉及到了model对象的传递，并且由于需要隔离View和Model，destination不能接触到这些model对象，这时候还是需要让configuration传递依赖，在router内部再把model传给负责管理model的角色。</p>
<p>因此，configuration和destination的protocol就负责依赖声明和暴露接口。调用者只需要传入protocol里要求的参数或者调用一些初始化方法即可，至于router内部怎么使用和配置这些依赖，调用者就不用关心了。</p>
<h4 id="直接在头文件中声明"><a href="#直接在头文件中声明" class="headerlink" title="直接在头文件中声明"></a>直接在头文件中声明</h4><p>声明一个protocol是一个router的config protocol或者view protocol时，只需要让这个protocol继承自<code>ZIKViewConfigRoutable</code>或者<code>ZIKViewRoutable</code>即可。这样，所有的依赖声明都可以在头文件里明确表示，不必再从文档中查找。</p>
<h3 id="使用泛型指明特定router"><a href="#使用泛型指明特定router" class="headerlink" title="使用泛型指明特定router"></a>使用泛型指明特定router</h3><p>一个模块可以直接在内部用<code>ZIKViewRouterToModule</code>和<code>ZIKViewRouterToView</code>动态获取router，也可以在头文件里添加一个router属性，让builder注入。</p>
<p>那么一个模块怎么向builder声明自己需要某个特定功能的router呢？答案是父类+泛型。</p>
<p>ZIKRouter支持用泛型指定参数类型。在OC中可以这样使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//注意这个示例代码只是用于演示泛型的意思，实际运行时必须要用一个ZIKViewRouter子类才可以</div><div class="line">[ZIKViewRouter&lt;UIViewController *,ZIKViewRouteConfiguration&lt;ZIKLoginConfigProtocol&gt; *&gt;</div><div class="line">  performFromSource:self</div><div class="line">  configuring:^(ZIKViewRouteConfiguration&lt;ZIKLoginConfigProtocol&gt; *config) &#123;</div><div class="line">    config.routeType = ZIKViewRouteTypePerformSegue;</div><div class="line">    config.configureSegue(^(ZIKViewRouteSegueConfiguration *segueConfig) &#123;</div><div class="line">    	segueConfig.identifier = @&quot;showLoginViewController&quot;;</div><div class="line">    );</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p><code>ZIKViewRouter&lt;UIViewController *, ZIKViewRouteConfiguration&lt;ZIKLoginConfigProtocol&gt; *&gt;</code>就是一个指定了泛型的类，尖括号中指定了router的destination和configuration类型。这一串说明相当于是在声明：这是一个destination为UIViewController类型，用<code>ZIKViewRouteConfiguration&lt;ZIKLoginConfigProtocol&gt; *</code>作为执行路由时的configuration的router类。你可以对configuration再添加protocol，表明这个configuration必须遵守指定的protocol。</p>
<p>这时你就可以用父类+泛型来声明一个router类，这个router类的configuration符合特定的config protocol。而且在写的时候Xcode会给你自动补全。这是一种很好的隐藏子类的方式，而且符合原生的语法。</p>
<p>但是由于OC中的类都是<code>Class</code>类型，因此只能这样声明一个实例属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, strong) ZIKViewRouter&lt;UIViewController *,ZIKViewRouteConfiguration&lt;ZIKLoginConfigProtocol&gt; *&gt; *loginViewRouter;</div></pre></td></tr></table></figure>
<p>Builder只能注入一个router实例，而不是一个router class。因此在OC里一般不这么使用。</p>
<p>但是在Swift这种类型安全语言中这种模式就能更好地发挥作用了，你可以直接注入一个符合某个泛型的router：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//在Builder中注入alertRouter</div><div class="line">swiftSampleViewController.alertRouter = Router.to(RoutableViewModule&lt;ZIKCompatibleAlertConfigProtocol&gt;())</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">class SwiftSampleViewController: UIViewController &#123;    </div><div class="line">    //在Builder里注入alertRouterClass后，就可以直接用这个routerClass执行路由</div><div class="line">    var alertRouter: ViewRouter&lt;Any, ZIKCompatibleAlertConfigProtocol&gt;!</div><div class="line">    </div><div class="line">    @IBAction func testInjectedRouter(_ sender: Any) &#123;</div><div class="line">        self.alertRouter.perform(</div><div class="line">            from: self,</div><div class="line">            configuring: &#123; (config, prepareDestination, prepareModule) in</div><div class="line">            prepareModule(&#123; moduleConfig in</div><div class="line">                //moduleConfig在类型推断时就是ZIKCompatibleAlertConfigProtocol，无需在判断后再强制转换</div><div class="line">                moduleConfig.title = &quot;Compatible Alert&quot;</div><div class="line">                moduleConfig.message = &quot;Test custom route for alert with UIAlertView and UIAlertController&quot;</div><div class="line">                moduleConfig.addCancelButtonTitle(&quot;Cancel&quot;, handler: &#123;</div><div class="line">                print(&quot;Tap cancel alert&quot;)</div><div class="line">                &#125;)</div><div class="line">                moduleConfig.addOtherButtonTitle(&quot;Hello&quot;, handler: &#123;</div><div class="line">                    print(&quot;Tap Hello alert&quot;)</div><div class="line">                &#125;)</div><div class="line">            &#125;)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>声明了<code>ViewRouter&lt;Any, ZIKCompatibleAlertConfigProtocol&gt;</code>的属性后，外部就可以直接注入一个对应的router。可以用这种设计模式来转移、集中获取router的职责。</p>
<p>Router可以在定义的时候限制自己的泛型：</p>
<p>Objective-C:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface ZIKCompatibleAlertViewRouter : ZIKViewRouter&lt;UIViewController *, ZIKViewRouteConfiguration&lt;ZIKCompatibleAlertConfigProtocol&gt; *&gt;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>Swift:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class ZIKCompatibleAlertViewRouter: ZIKViewRouter&lt;UIViewController, ZIKViewRouteConfiguration &amp; ZIKCompatibleAlertConfigProtocol&gt; &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样在传递的时候，就可以让编译器检查router是否正确。</p>
<h3 id="调用安全和类型安全"><a href="#调用安全和类型安全" class="headerlink" title="调用安全和类型安全"></a>调用安全和类型安全</h3><p>上面的演示已经展示了类型安全的处理，由protocol和泛型共同完成了这个类型安全的设计。不过有一些问题还需要特别注意。</p>
<h4 id="编译检查"><a href="#编译检查" class="headerlink" title="编译检查"></a>编译检查</h4><p>使用<code>ZIKViewRouterToModule</code>和<code>ZIKViewRouterToView</code>时，会对传入的protocol进行编译检查。保证传入的protocol是可路由的protocol，不能随意滥用。具体用到的方式有些复杂，而且在Objective-C和Swift上使用了两种方式来实现编译检查，具体实现可以看源代码。</p>
<h4 id="泛型的协变和逆变"><a href="#泛型的协变和逆变" class="headerlink" title="泛型的协变和逆变"></a>泛型的协变和逆变</h4><p>Swift的自定义泛型不支持协变，所以使用起来有点奇怪。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let alertRouterClass: ZIKViewRouter&lt;UIViewController, ZIKViewRouteConfiguration&gt;.Type</div><div class="line"> </div><div class="line"> //编译错误</div><div class="line"> //ZIKCompatibleAlertViewRouter.Type is ZIKViewRouter&lt;UIViewController, ZIKViewRouteConfiguration &amp; ZIKCompatibleAlertConfigProtocol&gt;.Type</div><div class="line"> alertRouterClass = ZIKCompatibleAlertViewRouter.self</div></pre></td></tr></table></figure>
<p>Swift的自定义泛型不支持子类型转为父类型，因此把<code>ZIKViewRouter&lt;UIViewController, ZIKViewRouteConfiguration &amp; ZIKCompatibleAlertConfigProtocol&gt;.Type</code>赋值给<code>ZIKViewRouter&lt;UIViewController, ZIKViewRouteConfiguration&gt;.Type</code>类型时就会出现编译错误。奇怪的是反过来逆变反而没有编译错误。而Swift原生的集合类型是支持协变的。从2015年开始就有人提议Swift对自定义泛型加入协变，到现在也没支持。在Objective-C里自定义泛型是可以正常协变的。</p>
<p>因此在swift里，使用了另一个类来包裹真正的router，而这个类是可以随意指定泛型的。</p>
<h3 id="用Adapter兼容接口"><a href="#用Adapter兼容接口" class="headerlink" title="用Adapter兼容接口"></a>用Adapter兼容接口</h3><p>可以用不同的protocol获取到相同的router。也就是<code>requiredProtocol</code>和<code>providedProtocol</code>只要有声明，都可以获取到同一个router。</p>
<p>首先检查<code>requiredProtocol</code>和<code>providedProtocol</code>，确定两个接口提供的功能是一致的。否则无法兼容。</p>
<h4 id="为Provided模块添加Required-Interface"><a href="#为Provided模块添加Required-Interface" class="headerlink" title="为Provided模块添加Required Interface"></a>为<code>Provided</code>模块添加<code>Required Interface</code></h4><p><code>requiredProtocol</code>是外部的要求目的模块额外兼容的，由App Context在ZIKViewAdapter的子类里进行接口兼容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@protocol ModuleARequiredLoginViewInput &lt;ZIKViewRoutable&gt;</div><div class="line">@property (nonatomic, copy) NSString *message;</div><div class="line">@end</div><div class="line"></div><div class="line">//Module A中的调用代码</div><div class="line">UIViewController&lt;ModuleARequiredLoginViewInput&gt; *loginViewController = [ZIKViewRouterToView(LoginViewInput) makeDestination];</div><div class="line">loginViewController.message = @&quot;请登录查看笔记详情&quot;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//Login Module Provided Interface</div><div class="line">@protocol ProvidedLoginViewInput &lt;NSObject&gt;</div><div class="line">@property (nonatomic, copy) NSString *notifyString;</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//ZIKEditorAdapter.h，ZIKViewAdapter子类</div><div class="line">@interface ZIKEditorAdapter : ZIKViewRouteAdapter</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">//ZIKEditorAdapter.m</div><div class="line">//用Objective-C的category、Swift的extension进行接口适配</div><div class="line">@interface LoginViewController (ModuleAAdapte) &lt;ModuleARequiredLoginViewInput&gt;</div><div class="line">@property (nonatomic, copy) NSString *message;</div><div class="line">@end</div><div class="line">@implementation LoginViewController (ModuleAAdapte)</div><div class="line">- (void)setMessage:(NSString *)message &#123;</div><div class="line">	self.notifyString = message;</div><div class="line">&#125;</div><div class="line">- (NSString *)message &#123;</div><div class="line">	return self.notifyString;</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ZIKEditorAdapter</div><div class="line"></div><div class="line">+ (void)registerRoutableDestination &#123;</div><div class="line">	//注册NoteListRequiredNoteEditorProtocol和ZIKEditorViewRouter匹配</div><div class="line">	[ZIKEditorViewRouter registerViewProtocol:ZIKRoutableProtocol(NoteListRequiredNoteEditorProtocol)];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h4 id="用中介者转发接口"><a href="#用中介者转发接口" class="headerlink" title="用中介者转发接口"></a>用中介者转发接口</h4><p>如果遇到protocol里的一些delegate需要兼容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@protocol ModuleARequiredLoginViewDelegate &lt;NSObject&gt;</div><div class="line">- (void)didFinishLogin;</div><div class="line">@end</div><div class="line"></div><div class="line">@protocol ModuleARequiredLoginViewInput &lt;ZIKViewRoutable&gt;</div><div class="line">@property (nonatomic, copy) NSString *message;</div><div class="line">@property (nonatomic, weak) id&lt;ModuleARequiredLoginViewDelegate&gt; delegate;</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@protocol LoginViewDelegate &lt;NSObject&gt;</div><div class="line">- (void)didLogin;</div><div class="line">@end</div><div class="line"></div><div class="line">@protocol ProvidedLoginViewInput &lt;NSObject&gt;</div><div class="line">@property (nonatomic, copy) NSString *notifyString;</div><div class="line">@property (nonatomic, weak) id&lt;LoginViewDelegate&gt; delegate;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这种情况在OC里可以hook<code>-setDelegate:</code>方法，用<code>NSProxy</code>来进行消息转发，把<code>LoginViewDelegate</code>的消息转发为对应的<code>ModuleARequiredLoginViewDelegate</code>中的消息。</p>
<p>不过Swift里就不适合这么干了，相同方法有不同参数类型时，可以用一个新的router代替真正的router，在新的router里插入一个中介者，负责转发接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@implementation ZIKEditorMediatorViewRouter</div><div class="line">+ (void)registerRoutableDestination &#123;</div><div class="line">	//注册NoteListRequiredNoteEditorProtocol，和新的ZIKEditorMediatorViewRouter配对，而不是目的模块中的ZIKEditorViewRouter</div><div class="line">	//新的ZIKEditorMediatorViewRouter负责调用ZIKEditorViewRouter，插入一个中介者</div><div class="line">	[self registerView:/* mediator的类*/];	</div><div class="line">	[self registerViewProtocol:ZIKRoutableProtocol(NoteListRequiredNoteEditorProtocol)];</div><div class="line">&#125;</div><div class="line">- (id)destinationWithConfiguration:(ZIKViewRouteConfiguration *)configuration &#123;</div><div class="line">   //用ZIKEditorViewRouter获取真正的destination</div><div class="line">   id&lt;ProvidedLoginViewInput&gt; realDestination = [ZIKEditorViewRouter makeDestination];</div><div class="line">    //获取一个负责转发ProvidedLoginViewInput和ModuleARequiredLoginViewInput的mediator</div><div class="line">    id&lt;ModuleARequiredLoginViewInput&gt; mediator = MediatorForDestination(realDestination);</div><div class="line">    return mediator;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>一般来说，并不需要立即把所有的protocol都分离为<code>requiredProtocol</code>和<code>providedProtocol</code>。调用模块和目的模块可以暂时共用protocol，或者只是简单地改个名字，在第一次需要替换模块的时候再对protocol进行分离。</p>
<h3 id="封装UIKit跳转和移除方法"><a href="#封装UIKit跳转和移除方法" class="headerlink" title="封装UIKit跳转和移除方法"></a>封装UIKit跳转和移除方法</h3><h4 id="封装iOS的路由方法"><a href="#封装iOS的路由方法" class="headerlink" title="封装iOS的路由方法"></a>封装iOS的路由方法</h4><p><code>ZIKViewRouter</code>把UIKit中路由相关的方法：</p>
<ul>
<li><code>-pushViewController:animated:</code></li>
<li><code>-presentViewController:animated:completion:</code></li>
<li><code>UIPopoverController</code>的<code>-presentPopoverFromRect:inView:permittedArrowDirections:animated:</code></li>
<li><code>UIPopoverPresentationController</code>的配置</li>
<li><code>-performSegueWithIdentifier:sender:</code></li>
<li><code>-showViewController:sender:</code></li>
<li><code>-showDetailViewController:sender:</code></li>
<li><code>-addChildViewController:</code></li>
<li><code>-addSubview:</code></li>
</ul>
<p>全都统一封装，可以用枚举一键切换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[ZIKViewRouterToView(ZIKLoginViewProtocol)</div><div class="line">    performFromSource:self routeType::ZIKViewRouteTypePush];</div></pre></td></tr></table></figure>
<p>对应的枚举值：</p>
<ul>
<li><code>ZIKViewRouteTypePush</code></li>
<li><code>ZIKViewRouteTypePresentModally</code></li>
<li><code>ZIKViewRouteTypePresentAsPopover</code></li>
<li><code>ZIKViewRouteTypePerformSegue</code></li>
<li><code>ZIKViewRouteTypeShow</code></li>
<li><code>ZIKViewRouteTypeShowDetail</code></li>
<li><code>ZIKViewRouteTypeAddAsChildViewController</code></li>
<li><code>ZIKViewRouteTypeAddAsSubview</code></li>
<li><code>ZIKViewRouteTypeCustom</code></li>
<li><code>ZIKViewRouteTypeGetDestination</code></li>
</ul>
<p>移除路由时，也不必再判断不同情况分别调用<code>-popViewControllerAnimated:</code>、<code>-dismissViewControllerAnimated:completion:</code>、<code>-dismissPopoverAnimated:</code>、<code>-removeFromParentViewController</code>、<code>-removeFromSuperview</code>等方法。</p>
<p><code>ZIKViewRouter</code>会在内部自动调用对应的方法。</p>
<h4 id="识别adaptative类型的路由"><a href="#识别adaptative类型的路由" class="headerlink" title="识别adaptative类型的路由"></a>识别<code>adaptative</code>类型的路由</h4><p><code>-performSegueWithIdentifier:sender:</code>、<code>-showViewController:sender:</code>、<code>-showDetailViewController:sender:</code>这些<code>adaptative</code>的路由方法，系统会根据不同的情况适配<code>UINavigationController</code>和<code>UISplitViewController</code>，选择调用<code>push</code>、<code>present</code>或者其他方式。直接调用时无法明确知道最终调用的是哪个方法，也就无法移除界面。</p>
<p><code>ZIKViewRouter</code>可以识别这些路由方法在调用后真正执行的路由操作，所以你现在也可以在使用这些方法后移除界面。</p>
<h4 id="支持自定义路由"><a href="#支持自定义路由" class="headerlink" title="支持自定义路由"></a>支持自定义路由</h4><p><code>ZIKViewRouter</code>也支持在子类中提供自定义的路由和移除路由方法。只要写好对应的协议即可。</p>
<h4 id="关于extension里的跳转方法"><a href="#关于extension里的跳转方法" class="headerlink" title="关于extension里的跳转方法"></a>关于extension里的跳转方法</h4><p>App extension里还有一些特有的跳转方法，比如<code>Watch</code>扩展里<code>WKInterfaceController</code>的<code>-pushControllerWithName:context:</code>和<code>-popController</code>，<code>Share</code>扩展里<code>SLComposeServiceViewController</code>的<code>-pushConfigurationViewController:</code>和<code>-popConfigurationViewController</code>。</p>
<p>看了一下extension的种类有十几个，懒得一个个去适配了。而且extension里的界面不会特别复杂，不是特别需要路由工具。如果你需要适配extension，可以自己增加，也可以用<code>ZIKViewRouteTypeCustom</code>来适配。</p>
<h3 id="支持storyboard"><a href="#支持storyboard" class="headerlink" title="支持storyboard"></a>支持storyboard</h3><p><code>ZIKViewRouter</code>支持storyboard，这也是和其他Router相比更强的地方。毕竟storyboard有时候也是很好用的，当使用了storyboard的项目中途使用router的时候，总不能为了适配router，把所有使用storyboard的界面都重构吧？</p>
<p>适配storyboard的原理是hook了所有UIViewController的<code>-prepareForSegue:sender:</code>方法，检查destinationViewController是否遵守<code>ZIKRoutableView</code>协议，如果遵守，就说明是一个由router管理的界面，获取注册的对应router类，生成router实例，对其进行依赖注入。如果destination需要传入动态参数，就会调用sourceViewController的<code>-prepareDestinationFromExternal:configuration:</code>方法，让sourceViewController传参。如果有多个router类注册了同一个view controller，则取随机的一个router。</p>
<p>你不需要对现有的模块做任何修改，就可以直接兼容。而且原来view controller中的<code>-prepareForSegue:sender:</code>也能照常使用。</p>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p><code>ZIKViewRouter</code>会在一个界面执行路由和移除路由的时候，对所有注册了此界面的router回调4个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+ (void)router:(nullable ZIKViewRouter *)router willPerformRouteOnDestination:(id)destination fromSource:(id)source &#123;</div><div class="line">&#125;</div><div class="line">+ (void)router:(nullable ZIKViewRouter *)router didPerformRouteOnDestination:(id)destination fromSource:(id)source &#123;</div><div class="line">&#125;</div><div class="line">+ (void)router:(nullable ZIKViewRouter *)router willRemoveRouteOnDestination:(id)destination fromSource:(id)source &#123;</div><div class="line">&#125;</div><div class="line">+ (void)router:(nullable ZIKViewRouter *)router didRemoveRouteOnDestination:(id)destination fromSource:(id)source &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你可以在这些方法中检查界面是否配置正确。也可以用于AOP记录。</p>
<p>例如，你可以为<code>UIViewController</code>这个所有view controller的父类注册一个router，这样就可以监控所有的<code>UIViewController</code>子类的路由事件。</p>
<h3 id="路由错误检查"><a href="#路由错误检查" class="headerlink" title="路由错误检查"></a>路由错误检查</h3><p><code>ZIKRouter</code>会在启动时进行所有router的注册，这样就能检测出router是否有冲突、protocol是否和router正确匹配，保证所有router都能正确工作。当检测到错误时，断言将会失败。</p>
<p><code>ZIKViewRouter</code>在执行界面路由时，会检测并报告路由时的错误。例如：</p>
<ul>
<li>使用了错误的protocol执行路由</li>
<li>执行路由时configuration配置错误</li>
<li>不支持的路由方式（router可以限制界面只能使用push、present等有限的跳转方式）</li>
<li>在其他界面的跳转过程中，执行了另一个界面的跳转（<code>unbalanced transition</code>错误，会导致<code>-viewWillAppear:</code>、<code>-viewDidAppear:</code>、<code>-viewWillDisAppear:</code>、<code>-viewDidDisappear:</code>等事件的顺序发生错乱）</li>
<li>Source view controller此时的状态无法执行当前路由</li>
<li>路由时container view controller配置错误</li>
<li>segue在代理方法中被取消，导致路由未执行</li>
<li>重复执行路由</li>
</ul>
<p>基本上包含了界面跳转时会发生的大部分错误事件。</p>
<h3 id="支持任意模块"><a href="#支持任意模块" class="headerlink" title="支持任意模块"></a>支持任意模块</h3><p><code>ZIKRouter</code>包含<code>ZIKViewRouter</code>和<code>ZIKServiceRouter</code>。<code>ZIKViewRouter</code>专门用于界面跳转，<code>ZIKServiceRouter</code>则可以添加任意类进行实例获取。</p>
<p>你可以用<code>ZIKServiceRouter</code>管理需要的类，并且<code>ZIKServiceRouter</code>增添了和<code>ZIKViewRouter</code>相同的动态性和泛型支持。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>为了错误检查、支持storyboard和注册，<code>ZIKViewRouter</code>和<code>ZIKServiceRouter</code>会在app启动时遍历所有类，进行hook和注册的工作。注册时只是把view class、protocol和router class的地址加入字典，不会对内存有影响。</p>
<p>在release模式下，iPhone6s机型上，测试了5000个UIViewController以及5000个对应的router，遍历所有类并且hook的耗时大约为15ms，注册router的耗时大约为50ms。基本上不会遇到性能问题。</p>
<p>如果你不需要支持storyboard，可以去掉view class和router class配对的注册，去掉以后就无法自动为storyboard里的view controller创建router。至于protocol和router的注册，目前似乎是无法避免的。</p>
<h2 id="项目地址和Demo"><a href="#项目地址和Demo" class="headerlink" title="项目地址和Demo"></a>项目地址和Demo</h2><p>简单来说，ZIKRouter就是一个用于模块间路由，基于接口进行模块发现和依赖注入的Router。它以原生的语法执行路由，在OC和Swift中都能使用。</p>
<p>项目地址在：<a href="https://github.com/Zuikyo/ZIKRouter" target="_blank" rel="external">ZIKRouter</a>。里面包含了一个demo，用于演示iOS中大部分的界面路由场景，建议在横屏iPad上运行。</p>
<p>最后记得点个star~</p>
<p>Demo截图，控制台的输出就是界面路由时的AOP回调：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1865432-f1eef5831de2a8ce.gif?imageMogr2/auto-orient/strip" alt="demo"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://mrpeak.cn/blog/module/" target="_blank" rel="external">iOS组件化方案</a></li>
<li><a href="http://www.jianshu.com/p/76da56b3bd55" target="_blank" rel="external">iOS 组件化 —— 路由设计思路分析</a></li>
<li><a href="http://www.uml-diagrams.org/component-diagrams.html" target="_blank" rel="external">component-diagrams</a></li>
<li><a href="https://github.com/alibaba/BeeHive" target="_blank" rel="external">BeeHive</a></li>
<li><a href="https://casatwy.com/iOS-Modulization.html" target="_blank" rel="external">CTMediator</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;路由是实现模块间解耦的一个有效工具。如果要进行组件化开发，路由是必不可少的一部分。目前iOS上绝大部分的路由工具都是基于URL匹配的，优缺点都很明显。这篇文章里将会给出一个更加原生和安全的设计，这个设计的特点是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;路由时用protocol寻找模块&lt;
    
    </summary>
    
      <category term="代码架构" scheme="http://yoursite.com/categories/%E4%BB%A3%E7%A0%81%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS VIPER架构实践(二)：VIPER详解与实现</title>
    <link href="http://yoursite.com/2017/08/11/iOS%20VIPER%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5(%E4%BA%8C)%EF%BC%9AVIPER%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2017/08/11/iOS VIPER架构实践(二)：VIPER详解与实现/</id>
    <published>2017-08-11T08:55:29.000Z</published>
    <updated>2018-01-24T01:45:41.320Z</updated>
    
    <content type="html"><![CDATA[<p>第一篇文章对VIPER进行了简单的介绍，这篇文章将从VIPER的源头开始，比较现有的几种VIPER实现，对VIPER进行进一步的职责剖析，并对各种细节实现问题进行挖掘和探讨。最后给出两个完整的VIPER实现，并且提供快速生成VIPER代码的模板。</p>
<p>Demo和轮子的github地址是：<a href="https://github.com/Zuikyo/ZIKViper" target="_blank" rel="external">ZIKViper</a>，路由工具：<a href="https://github.com/Zuikyo/ZIKRouter" target="_blank" rel="external">ZIKRouter</a>。有用请点个star~</p>
<p>两个实现展示了以下问题的解决方案：</p>
<ul>
<li>如何彻底地解决不同模块之间的耦合</li>
<li>如何在一个模块里引入子模块</li>
<li>子模块和父模块之间如何通信</li>
<li>如何对模块进行依赖注入</li>
<li>面向接口的路由工具</li>
</ul>
<h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>VIPER架构，最初是2013年在MutualMobile的技术博客上，由Jeff Gilbert 和 Conrad Stoll 提出的。他们的博客网站有过一次迁移，原文地址已经失效，这是迁移后的博文：<a href="https://mutualmobile.com/posts/meet-viper-fast-agile-non-lethal-ios-architecture-framework" target="_blank" rel="external">MEET VIPER: MUTUAL MOBILE’S APPLICATION OF CLEAN ARCHITECTURE FOR IOS APPS</a>。</p>
<p>这是文章中提出的架构示意图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1865432-13daad61ed8db39c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="viper_mutualmobile"></p>
<p>Wireframe可以看作是Router的另一种表达。可以看到，VIPER之间的关系已经很明确了。之后，作者在2014年在objc.io上发表了另一篇更详细的介绍文章：<a href="https://www.objc.io/issues/13-architecture/viper/" target="_blank" rel="external">Architecting iOS Apps with VIPER</a>。</p>
<p>在作者的第一篇文章里，阐述了VIPER是在接触到了Uncle Bob的<a href="https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html" target="_blank" rel="external">Clean Architecture</a>后，对Clean Architecture的一次实践。因此，VIPER真正的源头应该是Clean Architecture。</p>
<h2 id="Clean-Architecture"><a href="#Clean-Architecture" class="headerlink" title="Clean Architecture"></a>Clean Architecture</h2><p>由Uncle Bob在2011年提出的<code>Clean Architecture</code>，是一个平台无关的抽象架构。想要详细学习的，可以阅读作者的原文：<a href="https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html" target="_blank" rel="external">Clean Architecture</a>，翻译：<a href="http://www.jdon.com/artichect/the-clean-architecture.html" target="_blank" rel="external">干净的架构The Clean Architecture</a>。</p>
<p>它通过梳理软件中不同层之间的依赖关系，提出了一个自外向内，单向依赖的架构，如下图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1865432-dda97ce26c973609.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Clean Architecture"></p>
<p>越靠近内层，越变得抽象，越接近设计的核心。越靠近外层，越和具体的平台和实现技术相关。内层的部分完全不知道外层的存在和实现方式，代码只能从外层向内层引用，目的是为了实现层与层之间的隔离。将不同抽象程度的层进行隔离，做到了把业务规则和具体实现分离开。你可以把外层看作是内层的delegate，外层只能通过内层提供的delegate接口来使用内层。</p>
<h3 id="Enterprise-Business-Rules"><a href="#Enterprise-Business-Rules" class="headerlink" title="Enterprise Business Rules"></a>Enterprise Business Rules</h3><p>代表了这个软件项目的业务规则。由数据实体体现，是一些可以在不同的程序应用之间共享的数据结构。</p>
<h3 id="Application-Business-Rules"><a href="#Application-Business-Rules" class="headerlink" title="Application Business Rules"></a>Application Business Rules</h3><p>代表了本应用所使用的一些业务规则。封装和实现了用到的业务功能，会将各种实体的数据结构转为在用例中传递的实体类，但是和具体的数据库技术或者UI无关。</p>
<h3 id="Interface-Adapters"><a href="#Interface-Adapters" class="headerlink" title="Interface Adapters"></a>Interface Adapters</h3><p>接口适配层。将用例的规则和具体的实现技术进行抽象地对接，将用例中用到的实体类转为供数据库存储的格式或者供View展示的格式。类似于MVVM中把Model的数据传递给ViewModel供View显示。</p>
<p>右下角表示了接口适配层中不同模块间的通信方式。不同的模块在业务用例中产生关联和数据传递。Input、Output就是Use Case提供给外层的数据流动接口。</p>
<h3 id="Frameworks-amp-Drivers"><a href="#Frameworks-amp-Drivers" class="headerlink" title="Frameworks &amp; Drivers"></a>Frameworks &amp; Drivers</h3><p>库和驱动层，代表了选用的各种具体的实现技术，例如持久层使用SQLite还是Core Data，网络层使用NSURLSession、NSURLConnection还是AFNetworking等。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>可以看到，Clean Architecture里已经出现了Use Case、Interactor、Presenter等概念，它为VIPER的工程实现提供了设计思想，VIPER将它的设计转化成了具体的实现。VIPER里的各部分正是存在着由外向内的依赖，从外向内表现为：<code>View -&gt; Presenter -&gt; Interactor -&gt; Entity</code>，<code>Wireframe</code>严格来说也是一类特殊的Use Case，用于不同模块之间通信，连接了不同的<code>Presenter</code>。</p>
<p>必须要记住的是，<strong>VIPER架构是根据由外向内的依赖关系来设计的</strong>。这句话是指导我们进行进一步设计和优化的关键。</p>
<h2 id="现有的各种VIPER实现"><a href="#现有的各种VIPER实现" class="headerlink" title="现有的各种VIPER实现"></a>现有的各种VIPER实现</h2><p>MutualMobile的那两篇文章虽然已经明确了VIPER各部分之间的职责，并且给出了简单的Demo，但是对Wireframe部分的实现有些争议，解耦做得不够彻底，并且对各层之间如何交互还处在最简单的实现上。之后出现了挺多文章来将VIPER进一步细化，不过某些细节的实现上有些差别，在给出我自己的VIPER之前，我将先对这些实现进行一次综合的比较分析，看看他们都使用了哪些技术，遇到了哪些争议点。不同实现之间已经公认的地方我就不再单独列出了。</p>
<h3 id="Brigade团队的实现"><a href="#Brigade团队的实现" class="headerlink" title="Brigade团队的实现"></a>Brigade团队的实现</h3><p>原文地址：<a href="https://brigade.engineering/brigades-experience-using-an-mvc-alternative-36ef1601a41f" target="_blank" rel="external">Brigade’s Experience Using an MVC Alternative: VIPER architecture for iOS applications</a>。</p>
<p>文章把VIPER的优点总结了一下，提出了这样的架构图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1865432-76a4f532c58da061.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Brigade’s VIPER"></p>
<p>他们对VIPER的各部分都没有异议，只是对Interactor的实现进行了进一步细化。用一个Data Manager提供给各个Use Case管理Entity，比如获取、存储功能。在Service中调用网络层去获取服务端的数据。</p>
<p>文章中还认为应该由Wireframe负责初始化整个VIPER，生成各部分的类，并设置依赖关系，并且引用另一个模块的Wireframe，负责跳转到另一个界面。</p>
<p>和这个实现类似的还有：</p>
<ul>
<li><a href="https://swifting.io/blog/2016/03/07/8-viper-to-be-or-not-to-be/" target="_blank" rel="external">VIPER to be or not to be?</a>。这篇文章里给出了一个Unit Test的例子，还探讨了应该在什么情况下开始应用VIPER。</li>
<li><a href="https://cheesecakelabs.com/blog/best-practices-viper-architecture/" target="_blank" rel="external">VIPER architecture: Our best practices to build an app like a boss</a>。Demo地址：<a href="https://github.com/CheesecakeLabs/Boilerplate_iOS_VIPER" target="_blank" rel="external">Boilerplate_iOS_VIPER</a>。</li>
</ul>
<p>针对VIPER需要编写太多初始化代码的麻烦，可以使用Xcode自带的Template解决。而很多作者都提到了一个代码生成工具：<a href="https://github.com/rambler-digital-solutions/Generamba" target="_blank" rel="external">Generamba</a>。</p>
<h4 id="争议"><a href="#争议" class="headerlink" title="争议"></a>争议</h4><p>文章并没有对VIPER进行修改，只是进一步细化了。这应该是一个最简单的实现。如果你要实施VIPER，参照这篇文章来没有什么大问题。但是它没有探讨的问题是：</p>
<ul>
<li>如何解决不同Wrieframe之间的耦合？</li>
<li>Wrieframe如何知道其他模块需要的初始化参数？</li>
<li>在模块间通信时，Interactor的数据如何传递给另一个模块？</li>
<li>父模块和子模块之间是怎样的关系？</li>
</ul>
<h3 id="Rambler-amp-Co团队的实现"><a href="#Rambler-amp-Co团队的实现" class="headerlink" title="Rambler&amp;Co团队的实现"></a>Rambler&amp;Co团队的实现</h3><p>一个对VIPER十分感兴趣的俄国团队，编写了一本关于VIPER的书：<a href="https://github.com/strongself/The-Book-of-VIPER" target="_blank" rel="external">The-Book-of-VIPER</a>。并且给出了一个目前网络上实现完成度最高的开源Demo：<a href="https://github.com/rambler-digital-solutions/rambler-it-ios" target="_blank" rel="external">rambler-it-ios</a>，以及他们用于实施VIPER的库：<a href="https://github.com/rambler-digital-solutions/ViperMcFlurry" target="_blank" rel="external">ViperMcFlurry</a>。</p>
<p>他们整理的VIPER架构图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1865432-9f35c09e9c9b0f12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Rambler&amp;Co&#39;s VIPER"></p>
<p>和其他实现不同的是，他们把VIPER的初始化和装配工作单独放到了一个Assembly里，Router只做界面跳转的工作。并且把VIPER内不同部分之间的通信统一用Input和Output来表示。Input表示外部主动调用模块提供的接口，Output表示模块通过外部实现所要求的接口，将事件传递到外部。</p>
<p>之所以将模块初始化单独放到Assembly里，是因为Router如果负责初始化本模块，会违背单一职责原则。</p>
<h4 id="争议-1"><a href="#争议-1" class="headerlink" title="争议"></a>争议</h4><p>这个实现的愿景很好，只是在转变为具体实现的时候不够完美，有很多问题尚待解决。具体可以参见Demo。</p>
<ul>
<li>Assembly使用了<a href="https://github.com/appsquickly/Typhoon" target="_blank" rel="external">Typhoon</a>这个依赖注入工具，通过Method Swizzling自动初始化VIPER的各个部分</li>
</ul>
<p>我对Typhoon这个依赖注入工具不是特别感冒，它使用了十分复杂的run time技术，想要追踪一个对象的注入过程时，会看得晕头转向。而且它无法实现运行时由调用方动态注入，只能实现预定义好的静态注入。也就是不能动态传参。</p>
<ul>
<li>使用storyboard进行路由</li>
</ul>
<p>在Demo中实现了在执行segue时用block来使用<code>-prepareForSegue:sender:</code>，实现向目的界面传参，实现了动态注入。但是这样就把路由限定在了storyboard的segue技术上，那么对于那些没有使用storyboard的项目应该怎么办呢？Demo并没有给出答案。而且<code>-prepareForSegue:sender:</code>只能向View传参，但是有一些参数是View不应该接触到的，而是应该直接传给Presenter或者Interactor的。</p>
<ul>
<li>有时候模块需要从Output中获取数据，例如Presenter主动获取View中的文字，传递给Interactor，此时<code>Output</code>并不能完整描述它的职责，还可以再进一步划分</li>
</ul>
<p>也就是说，他们的方案在设计上是不错的，但在技术上还有很多改进空间。</p>
<h3 id="Uber团队的实现"><a href="#Uber团队的实现" class="headerlink" title="Uber团队的实现"></a>Uber团队的实现</h3><p>Uber由于业务越来越复杂，旧项目的架构已经无法满足当前的需求，因此在2016年完全重构了他们的 rider app。他们借鉴VIPER，并且设计出了一个VIPER的变种架构：Riblets。文章地址：<a href="https://eng.uber.com/new-rider-app/" target="_blank" rel="external">ENGINEERING THE ARCHITECTURE BEHIND UBER’S NEW RIDER APP</a>。</p>
<p>架构图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1865432-ad4602f11ed62094.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="riblets"></p>
<p>数据流向图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1865432-bdb29d6717472b5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="riblets_数据流向"></p>
<p>父模块和子模块之间通信：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1865432-e71eed65c555ddc5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="riblet_父子模块间通信"></p>
<h4 id="各部分职责"><a href="#各部分职责" class="headerlink" title="各部分职责"></a>各部分职责</h4><p>这里只列出一些和VIPER有差异的地方：</p>
<ul>
<li>Builder负责初始化Riblets模块内的各个部分，定义了模块的依赖参数</li>
<li>Component负责获取和初始化那些不是Riblets模块内的部分，例如services，并注入到Interactor中</li>
<li>Router负责管理子模块，持有子模块的Router，并把子模块的View添加到视图树上</li>
<li>Interactor通过调用Service管理Model，而不是在Interactor中直接管理</li>
<li>Interactor和子模块的Interactor通过监听者模式和delegate互相通信</li>
</ul>
<h4 id="数据驱动"><a href="#数据驱动" class="headerlink" title="数据驱动"></a>数据驱动</h4><p>最大的改变是将Router从Presenter移到了Interactor，改变了模块的主从关系，整个模块的生命周期现在由Interactor来管理。而之前的VIPER模块是依赖于View的生命周期的。这样一来，整个架构就从View驱动变成了业务驱动，或者数据驱动。</p>
<p>关于这个改变，Uber给出了两个原因：</p>
<ul>
<li>想要统一iOS和Andorid的软件架构，以及更好地互相借鉴开发经验和教训，因而需要改变iOS中视图驱动的设计</li>
<li>想要创建一个没有View，只有业务逻辑的模块，因此生命周期需要由Interactor管理</li>
</ul>
<h4 id="争议-2"><a href="#争议-2" class="headerlink" title="争议"></a>争议</h4><p>Uber团队的确很有想法。在对他们的这个方案进行深入实践之前，我无法评论这个方案是好是坏，我只在这里提出一些实践中可能会遇到的问题。</p>
<p>关于Uber给出的第一个原因，这是Uber团队基于协调两个开发团队的情况而做出的选择，如果我们没有他们这样统一开发的需求，并没有必要借鉴。iOS的UIKit是一个视图驱动的框架，很难做到100%数据驱动，在实践中将会遇到许多需要解决的问题，除非有足够的开发时间，否则不要草率地投入其中。是否要使用数据驱动的设计，还是应该由项目的业务设计来决定。当数据变化大部分是由后端的Service和网络数据引起时，再去考虑数据驱动吧。例如Uber的地图路线由定位模块不断计算，自动更新，就比较适合使用数据驱动。</p>
<p>关于第二个原因，一个没有View和Presenter的VIPER，就只剩下Router、Interactor、Model，这时这个模块可以看做是一个可以通过Router调用的Service或者Manager，这个Service有自己的状态和生命周期，Service也可以在View销毁后继续完成剩余的业务工作，只要业务需要，可以进行自持有，自释放。而且这个Service最终还是会表现在某个View上。这么看来，Router的层级已经升高了，成为了整个app内的模块间通信工具，可以连接任意模块，不仅仅是VIPER，因此Router由谁持有，就完全由模块内部自由管理了。</p>
<p>只是，在iOS中的VIPER里，实际的路由API都是存在于UIViewController上的，Router会直接和View产生引用，把Router放到和View隔离的Interactor里会破坏隔离。而且从Clean架构的分层来看，层级升高后的Router应该是处在Interface Adapter层和Framework &amp; Driver层之间，而Interactor则是在Application Business Rules层，由Interactor来管理其他角色，会破坏了Clean Architecture里的依赖关系。</p>
<p>比如一个没有View的、用于管理语音通话数据的Interactor，收到了通话异常中断的事件，在处理事件时，它不应该通过Router将自己移除，或者结束整个语音通话业务，或者自动调用重新拨号的业务，这样很容易会让不同的Use Case之间产生耦合，这些都应该由更上层的Service去选择执行，如果有页面跳转的设计，则应该把事件转发给一个存在Presenter层的Parent VIPER模块，由parent来决定是退出通话界面还是弹窗提示。当一个Interactor没有Presenter和View时，它一定是另一个VIPER的子模块。这么看来，在没有View时，或许让Service来持有Router才是正确的。</p>
<p>因此，如果真的有把VIPER变成数据驱动的需求，主要还是源于Uber给出的第一个基于团队统一的理由。</p>
<h4 id="其他设计"><a href="#其他设计" class="headerlink" title="其他设计"></a>其他设计</h4><p>文章里还给出了一些很有参考价值的内容，比如：</p>
<ul>
<li>对Interactor进行注入的Component</li>
<li>视图树变成了Router树</li>
<li>Interactor不直接维护Model，而是通过对应的Service来维护Model</li>
<li>父模块和子模块之间通过Interactor来通信</li>
</ul>
<p>Uber的这个方案讲了很多其他方案没有提到的方面，比如依赖注入、如何引入子模块等问题。不过这个方案并没有开源。</p>
<h2 id="方案一：最完整的VIPER"><a href="#方案一：最完整的VIPER" class="headerlink" title="方案一：最完整的VIPER"></a>方案一：最完整的VIPER</h2><p>各种实现方案都分析了一遍，接下来就开始进行一个总结。首先总结出一个绝对标准的VIPER，各部分遵循隔离关系，同时考虑到依赖注入、子模块通信、模块间解耦等问题，将VIPER的各部分的职责变得更加明确，也新增了几个角色。示例图如下，各角色的颜色和Clean Architecture图中各层的颜色对应：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1865432-a204e884cdb08f63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="thorough_viper"></p>
<p>示例代码将用一个笔记应用作为演示。</p>
<h3 id="View"><a href="#View" class="headerlink" title="View"></a>View</h3><p>View可以是一个UIView + UIViewController，也可以只是一个custom UIView，也可以是一个自定义的用于管理UIView的Manager，只要它实现了View的接口就可以。</p>
<p>View层的职责：</p>
<ul>
<li>展示界面，组合各种UIView，并在UIViewController内管理各种控件的布局、更新</li>
<li>View对外暴露各种用于更新UI的接口，而自己不主动更新UI</li>
<li>View持有一个由外部注入的eventHandler对象，将View层的事件发送给eventHandler</li>
<li>View持有一个由外部注入的viewDataSource对象，在View的渲染过程中，会从viewDataSource获取一些用于展示的数据，viewDataSource的接口命名应该尽量和具体业务无关</li>
<li>View向Presenter提供routeSource，也就是用于界面跳转的源界面</li>
</ul>
<p>View层会引入各种自定义控件，这些控件有许多delegate，都在View层实现，统一包装后，再交给Presenter层实现。因为Presenter层并不知道View的实现细节，因此也就不知道这些控件的接口，Presenter层只知道View层统一暴露出来的接口。而且这些控件的接口在定义时可能会将数据获取、事件回调、控件渲染接口混杂起来，最具代表性的就是<code>UITableViewDataSource</code>里的<code>-tableView:cellForRowAtIndexPath:</code>。这个接口同时涉及到了<code>UITableViewCell</code>和渲染cell所需要的Model，是非常容易产生耦合的地方，因此需要做一次分解。应该在View的dataSource里定义一个从外部获取所需要的简单类型数据的方法，在<code>-tableView:cellForRowAtIndexPath:</code>里用获取到的数据渲染cell。示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@protocol ZIKNoteListViewEventHandler &lt;NSObject&gt;</div><div class="line">- (void)handleDidSelectRowAtIndexPath:(NSIndexPath *)indexPath;</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@protocol ZIKNoteListViewDataSource &lt;NSObject&gt;</div><div class="line">- (NSInteger)numberOfRowsInSection:(NSInteger)section;</div><div class="line">- (NSString *)textOfCellForRowAtIndexPath:(NSIndexPath *)indexPath;</div><div class="line">- (NSString *)detailTextOfCellForRowAtIndexPath:(NSIndexPath *)indexPath;</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">@interface ZIKNoteListViewController () &lt;UITableViewDelegate,UITableViewDataSource&gt;</div><div class="line">@property (nonatomic, strong) id&lt;ZIKNoteListViewEventHandler&gt; eventHandler;</div><div class="line">@property (nonatomic, strong) id&lt;ZIKNoteListViewDataSource&gt; viewDataSource;</div><div class="line">@property (weak, nonatomic) IBOutlet UITableView *noteListTableView;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ZIKNoteListViewController</div><div class="line"></div><div class="line">- (UITableViewCell *)cellForRowAtIndexPath:(NSIndexPath *)indexPath</div><div class="line">                                      text:(NSString *)text</div><div class="line">                                detailText:(NSString *)detailText &#123;</div><div class="line">    UITableViewCell *cell = [self.noteListTableView dequeueReusableCellWithIdentifier:@&quot;noteListCell&quot; forIndexPath:indexPath];</div><div class="line">    cell.textLabel.text = text;</div><div class="line">    cell.detailTextLabel.text = detailText;</div><div class="line">    return cell;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark UITableViewDataSource</div><div class="line"></div><div class="line">- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123;</div><div class="line">    return [self.viewDataSource numberOfRowsInSection:section];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</div><div class="line">    NSString *text = [self.viewDataSource textOfCellForRowAtIndexPath:indexPath];</div><div class="line">    NSString *detailText = [self.viewDataSource detailTextOfCellForRowAtIndexPath:indexPath];</div><div class="line">    UITableViewCell *cell = [self cellForRowAtIndexPath:indexPath</div><div class="line">                                                   text:text</div><div class="line">                                             detailText:detailText];</div><div class="line">    return cell;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark UITableViewDelegate</div><div class="line"></div><div class="line">- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath &#123;</div><div class="line">    [tableView deselectRowAtIndexPath:indexPath animated:YES];</div><div class="line">    </div><div class="line">    [self.eventHandler handleDidSelectRowAtIndexPath:indexPath];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>一般来说，viewDataSource和eventHandler都是由Presenter来担任的，Presenter接收到dataSource请求时，从Interactor里获取并返回对应的数据。你也可以选择在View和Presenter之间用ViewModel来进行交互。</p>
<h3 id="Presenter"><a href="#Presenter" class="headerlink" title="Presenter"></a>Presenter</h3><p>Presenter由View持有，它的职责有：</p>
<ul>
<li>接收并处理来自View的事件</li>
<li>维护和View相关的各种状态和配置，比如界面是否使用夜间模式等</li>
<li>调用Interactor提供的Use Case执行业务逻辑</li>
<li>向Interactor提供View中的数据，让Interactor生成需要的Model</li>
<li>接收并处理来自Interactor的业务事件回调事件</li>
<li>通知View进行更新操作</li>
<li>通过Wireframe跳转到其他View</li>
</ul>
<p>Presenter是View和业务之间的中转站，它不包含业务实现代码，而是负责调用现成的各种Use Case，将具体事件转化为具体业务。Presenter里不应该导入UIKit，否则就有可能入侵View层的渲染工作。Presenter里也不应该出现Model类，当数据从Interactor传递到Presenter里时，应该转变为简单的数据结构。</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">@interface ZIKNoteListViewPresenter () &lt;ZIKNoteListViewDataSource, ZIKNoteListViewEventHandler&gt;</div><div class="line">@property (nonatomic, strong) id&lt;ZIKNoteListWireframeProtocol&gt; wireframe;</div><div class="line">@property (nonatomic, weak) id&lt;ZIKViperView,ZIKNoteListViewProtocol&gt; view;</div><div class="line">@property (nonatomic, strong) id&lt;ZIKNoteListInteractorInput&gt; interactor;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ZIKNoteListViewPresenter</div><div class="line"></div><div class="line">#pragma mark ZIKNoteListViewDataSource</div><div class="line"></div><div class="line">- (NSInteger)numberOfRowsInSection:(NSInteger)section &#123;</div><div class="line">    return self.interactor.noteCount;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSString *)textOfCellForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</div><div class="line">    NSString *title = [self.interactor titleForNoteAtIndex:indexPath.row];</div><div class="line">    return title;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSString *)detailTextOfCellForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</div><div class="line">    NSString *content = [self.interactor contentForNoteAtIndex:indexPath.row];</div><div class="line">    return content;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark ZIKNoteListViewEventHandler</div><div class="line"></div><div class="line">- (void)handleDidSelectRowAtIndexPath:(NSIndexPath *)indexPath &#123;</div><div class="line">    NSString *uuid = [self.interactor noteUUIDAtIndex:indexPath.row];</div><div class="line">    NSString *title = [self.interactor noteTitleAtIndex:indexPath.row];</div><div class="line">    NSString *content = [self.interactor noteContentAtIndex:indexPath.row];</div><div class="line">    </div><div class="line">    [self.wireframe pushEditorViewForEditingNoteWithUUID:uuid title:title content:content delegate:self];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="Interactor"><a href="#Interactor" class="headerlink" title="Interactor"></a>Interactor</h3><p>Ineractor的职责：</p>
<ul>
<li>实现和封装各种业务的Use Case，供外部调用</li>
<li>维护和业务相关的各种状态，比如是否正在编辑笔记</li>
<li>Interactor可以获取各种Manager和Service，用于组合实现业务逻辑，这些Manager和Service应该是由外部注入的依赖，而不是直接引用具体的类</li>
<li>通过DataManager维护Model</li>
<li>监听各种外部的业务事件并处理，必要时将事件发送给eventHandler</li>
<li>Interactor持有一个由外部注入的eventHandler对象，将需要外部处理的业务事件发送给eventHandler，或者通过eventHandler接口对某些数据操作的过程进行回调</li>
<li>Interactor持有一个由外部注入的dataSource对象，用于获取View上的数据，以更新Model</li>
</ul>
<p>Interactor是业务的实现者和维护者，它会调用各种Service来实现业务逻辑，封装成明确的用例。而这些Service在使用时，也都是基于接口的，因为Interactor的实现不和具体的类绑定，而是由Application注入Interactor需要的Service。</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@protocol ZIKNoteListInteractorInput &lt;NSObject&gt;</div><div class="line">- (void)loadAllNotes;</div><div class="line">- (NSInteger)noteCount;</div><div class="line">- (NSString *)titleForNoteAtIndex:(NSUInteger)idx;</div><div class="line">- (NSString *)contentForNoteAtIndex:(NSUInteger)idx;</div><div class="line">- (NSString *)noteUUIDAtIndex:(NSUInteger)idx;</div><div class="line">- (NSString *)noteTitleAtIndex:(NSUInteger)idx;</div><div class="line">- (NSString *)noteContentAtIndex:(NSUInteger)idx;</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">@interface ZIKNoteListInteractor : NSObject &lt;ZIKNoteListInteractorInput&gt;</div><div class="line">@property (nonatomic, weak) id dataSource;</div><div class="line">@property (nonatomic, weak) id eventHandler;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ZIKNoteListInteractor</div><div class="line"></div><div class="line">- (void)loadAllNotes &#123;</div><div class="line">    [[ZIKNoteDataManager sharedInsatnce] fetchAllNotesWithCompletion:^(NSArray *notes) &#123;</div><div class="line">        [self.eventHandler didFinishLoadAllNotes];</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSArray&lt;ZIKNoteModel *&gt; *)noteList &#123;</div><div class="line">    return [ZIKNoteDataManager sharedInsatnce].noteList;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSInteger)noteCount &#123;</div><div class="line">    return self.noteList.count;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSString *)titleForNoteAtIndex:(NSUInteger)idx &#123;</div><div class="line">    if (self.noteList.count - 1 &lt; idx) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    return [[self.noteList objectAtIndex:idx] title];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSString *)contentForNoteAtIndex:(NSUInteger)idx &#123;</div><div class="line">    if (self.noteList.count - 1 &lt; idx) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    return [[self.noteList objectAtIndex:idx] content];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSString *)noteUUIDAtIndex:(NSUInteger)idx &#123;</div><div class="line">    if (self.noteList.count - 1 &lt; idx) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    return [[self.noteList objectAtIndex:idx] uuid];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSString *)noteTitleAtIndex:(NSUInteger)idx &#123;</div><div class="line">    if (self.noteList.count - 1 &lt; idx) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    return [[self.noteList objectAtIndex:idx] title];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSString *)noteContentAtIndex:(NSUInteger)idx &#123;</div><div class="line">    if (self.noteList.count - 1 &lt; idx) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    return [[self.noteList objectAtIndex:idx] content];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>向Interactor提供各种封装好的服务，例如数据库的访问、存储，调用定位功能等。Service由Application在执行路由时注入到Builder里，再由Buidler注入到Interactor里。也可以只注入一个Service Router，在运行时再通过这个Service Router懒加载需要的Service，相当于注入了一个提供Router功能的Service。</p>
<p>Service可以看作是没有View的VIPER，也有自己的路由和Builder。</p>
<h3 id="Wireframe"><a href="#Wireframe" class="headerlink" title="Wireframe"></a>Wireframe</h3><p>翻译成中文叫线框，用于表达从一个Module到另一个Module的过程。虽然也是扮演者执行路由的角色，但是其实它和Router是有区别的。</p>
<p>Wireframe和storyboard中连接好的一个个segue类似，负责提供一系列具体的路由用例，这个用例里已经配置好了源界面和目的界面的一些依赖，包括转场动画、模块间传参等。Wireframe的接口是提供给模块内部使用的，它通过调用Router来执行真正的路由操作。</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@interface ZIKTNoteListWireframe : NSObject &lt;ZIKTViperWireframe&gt;</div><div class="line">- (void)presentLoginViewWithMessage:(NSString *)message delegate:(id&lt;ZIKTLoginViewDelegate&gt;)delegate completion:(void (^ __nullable)(void))completion;</div><div class="line">- (void)dismissLoginView:(UIViewController *)viewController animated:(BOOL)animated completion:(void (^ __nullable)(void))completion;</div><div class="line">- (void)presentEditorForCreatingNewNoteWithDelegate:(id&lt;ZIKTEditorDelegate&gt;)delegate completion:(void (^ __nullable)(void))completion;</div><div class="line">- (void)pushEditorViewForEditingNoteWithUUID:(NSString *)uuid title:(NSString *)title content:(NSString *)content delegate:(id&lt;ZIKTEditorDelegate&gt;)delegate;</div><div class="line">- (UIViewController *)editorViewForEditingNoteWithUUID:(NSString *)uuid title:(NSString *)title content:(NSString *)content delegate:(id&lt;ZIKTEditorDelegate&gt;)delegate;</div><div class="line">- (void)pushEditorViewController:(UIViewController *)destination fromViewController:(UIViewController *)source animated:(BOOL)animated;</div><div class="line">- (void)quitEditorViewWithAnimated:(BOOL)animated;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h3><p>Router则是由Application提供的具体路由技术，可以简单封装UIKit里的那些跳转方法，也可以用URL Router来执行路由。但是一个模块是不需要知道app使用的是什么具体技术的。Router才是真正连接各个模块的地方。它也负责寻找对应的目的模块，并且通过Buidler进行依赖注入。</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@interface ZIKTRouter : NSObject &lt;ZIKTViperRouter&gt;</div><div class="line">///封装UIKit的跳转方法</div><div class="line">+ (void)pushViewController:(UIViewController *)destination fromViewController:(UIViewController *)source animated:(BOOL)animated;</div><div class="line">+ (void)popViewController:(UIViewController *)viewController animated:(BOOL)animated;</div><div class="line">+ (void)presentViewController:(UIViewController *)viewControllerToPresent fromViewController:(UIViewController *)source animated:(BOOL)animated completion:(void (^ __nullable)(void))completion;</div><div class="line">+ (void)dismissViewController:(UIViewController *)viewController animated:(BOOL)animated completion:(void (^ __nullable)(void))completion;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ZIKTRouter (ZIKTEditor)</div><div class="line"></div><div class="line">+ (UIViewController *)viewForCreatingNoteWithDelegate:(id&lt;ZIKTEditorDelegate&gt;)delegate &#123;</div><div class="line">    return [ZIKTEditorBuilder viewForCreatingNoteWithDelegate:delegate];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (UIViewController *)viewForEditingNoteWithUUID:(NSString *)uuid title:(NSString *)title content:(NSString *)content delegate:(id&lt;ZIKTEditorDelegate&gt;)delegate &#123;</div><div class="line">    return [ZIKTEditorBuilder viewForEditingNoteWithUUID:uuid title:title content:content delegate:delegate];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h3><p>由Application实现，负责在模块通信时进行一些接口的转换，例如两个模块使用了相同业务功能的某个Service，使用的protocol实现一样，但是protocol名字不一样，就可以在路由时，在Adapter里进行一次转换。甚至只要定义的逻辑一样，依赖参数的名字和数据类型也可以允许不同。这样就能让模块不依赖于某个具体的protocol，而是依赖于protocol实际定义的依赖和接口。</p>
<p>注意这里的Adapter和Clean Architecture里的<code>Interface Adapter</code>是不一样的。这里的Adapter就是字面意义上的接口转换，而Clean Architecture里的<code>Interface Adapter</code>层更加抽象，是Use Case层与具体实现技术之间的转换，囊括了更多的角色。</p>
<h3 id="Builder"><a href="#Builder" class="headerlink" title="Builder"></a>Builder</h3><p>负责初始化整个模块，配置VIPER之间的关系，并对外声明模块需要的依赖，让外部执行注入。</p>
<h2 id="模块间解耦"><a href="#模块间解耦" class="headerlink" title="模块间解耦"></a>模块间解耦</h2><p>一个VIPER模块可以看做是一个独立的组件，可以被单独封装成一个库，被app引用。这时候，app就负责将各个模块连接起来，也就是图中灰色的<code>Application Context</code>部分。一个模块，肯定是存在于一个上下文环境中才能运行起来的。</p>
<p><code>Wireframe</code> -&gt; <code>Router</code> -&gt; <code>Adapter</code> -&gt; <code>Builder</code> 实现了一个完整的模块间路由，并且实现了模块间的解耦。</p>
<p>其中Wireframe和Builder是分别由引用者模块和被引用模块提供的，是两个模块的出口和入口，而Router和Adapter则是由模块的使用者——Application实现的。</p>
<p>当两个模块之间存在引用关系时，说明存在业务逻辑上的耦合，这种耦合是业务的一部分，是不可能消除的。我们能做的就是把耦合尽量交给模块调用者，由Application来提供具体的类，注入到各个模块之中，而模块内部只面向protocol即可。这样的话，被引用模块只要实现了相同的接口，就可以随时替换，甚至接口有一些差异时，只要被引用模块提供了相同功能的接口，也可以通过Adapter来做接口兼容转换，让引用者模块无需做任何修改。</p>
<p>Wireframe相当于插头，Builder相当于插座，而Router和Adapter相当于电路和转接头，将不同规格的插座和插头连接起来。把这些连接和适配的工作交给Application层，就能让两个模块实现各自独立。</p>
<h2 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h2><p>大部分方案都没有讨论子模块存在的情况。在VIPER里如何引入另一个VIPER模块？多个模块之间如何交互？子模块由谁初始化、由谁管理？</p>
<p>其他几个实现中，只有Uber较为详细地讨论了子模块的问题。在Uber的Riblets架构里，子模块的Router被添加到父模块的Router，模块之间通过delegate和监听的方式进行通信。这样做会让模块间产生一定的耦合。如果子模块是由于父View使用了一个子View控件而被引入的，那么父Interactor就会在代码里多出一个子Interactor，这样就导致了View的实现方式影响了Interactor的实现。</p>
<h3 id="子模块的来源"><a href="#子模块的来源" class="headerlink" title="子模块的来源"></a>子模块的来源</h3><p>子模块的来源有：</p>
<ul>
<li>View引用了一个封装好的子View控件，连带着引入了子View的整个VIPER</li>
<li>Interactor使用了一个Service</li>
</ul>
<h3 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h3><p>子View可能是一个UIView，也可能是一个Child UIViewController。因此子View有可能需要向外部请求数据，也可能独立完成所有任务，不需要依赖父模块。</p>
<p>如果子View可以独立，那在子模块里不会出现和父模块交互的逻辑，只有把一些事件通过Output传递出去的接口。这时只需要把子View的接口封装在父View的接口里即可，父Presenter和父Interactor是不知道父View提供的这几个接口是通过子View实现的。这样父模块就能接收到子模块的事件了，而且能够保持Interactor和Presenter、View之间从低到高的依赖关系。</p>
<p>如果父模块需要调用子模块的某些功能，或者从子模块获取数据，可以选择封装到父View的接口里，不过如果涉及到数据模型，并且不想让数据模型出现在View的接口中，可以把子Interactor作为父Interactor的一个Service，在引入子模块时，通过父Builder注入到父Interactor里，或者根据依赖关系解耦地再彻底一点，注入到父Presenter里，让父Presenter再把接口转发给父Interactor。这样子模块和父模块就能通过Service的形式进行通信了，而这时，父Interactor也不知道这个Service是来自子模块里的。</p>
<p>在这样的设计下，子模块和父模块是不知道彼此的存在的，只是通过接口进行交互。好处是父View如果想要更换为另一个相同功能的子View控件，就只需要在父View里修改，不会影响Presenter和Interactor。</p>
<h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p>这个VIPER的设计是通过接口将各个部分组合在一起的，一个类需要设置很多依赖，例如Interactor需要依赖许多Service。这就涉及到了两个问题：</p>
<ul>
<li>在哪里配置依赖</li>
<li>一个类怎么声明自己的依赖</li>
</ul>
<p>在这个方案中，由Builder声明整个模块的依赖，然后在Builder内部为不同的类设置依赖，外部在注入依赖时，就不必知道内部是怎么使用这些依赖参数的。一个类如果有必需的依赖参数，可以直接在init方法里体现，对于那些非必需的依赖，可以通过暴露接口来声明。</p>
<p>如果需要动态注入，而不是在模块初始化时就配置所有的依赖，Builder也可以提供动态注入的接口。</p>
<h2 id="映射到MVC"><a href="#映射到MVC" class="headerlink" title="映射到MVC"></a>映射到MVC</h2><p>如果你需要把一个模块从MVC重构到VIPER，可以先按照这个步骤：</p>
<ul>
<li>整理Controller中的代码，把不同职责的代码用pragma mark分隔好</li>
<li>整理好后，按照各部分的职责，将代码分散到VIPER的各个角色中，此时View、Presenter、Interactor之间可以直接互相引用</li>
<li>把View、Presenter、Interactor进行解耦，抽出接口，互相之间依赖接口进行交互</li>
</ul>
<p>下面就是第一步里在Controller中可以分隔出的职责：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">@implementation ViewController</div><div class="line">//------View-------</div><div class="line"></div><div class="line">//View的生命周期</div><div class="line">#pragma mark View life</div><div class="line"></div><div class="line">//View的配置，包括布局设置</div><div class="line">#pragma mark View config</div><div class="line"></div><div class="line">//更新View的接口</div><div class="line">#pragma mark Update view</div><div class="line"></div><div class="line">//View需要从model中获取的数据</div><div class="line">#pragma mark Request view data source</div><div class="line"></div><div class="line">//监控、接收View的事件</div><div class="line">#pragma mark Send view event</div><div class="line"></div><div class="line">//------Presenter-------</div><div class="line"></div><div class="line">//处理View的事件</div><div class="line">#pragma mark Handle view event</div><div class="line"></div><div class="line">//界面跳转</div><div class="line">#pragma mark Wireframe</div><div class="line"></div><div class="line">//向View提供配置用的数据</div><div class="line">#pragma mark Provide view data source</div><div class="line"></div><div class="line">//提供生成model需要的数据</div><div class="line">#pragma mark Provide model data source</div><div class="line"></div><div class="line">//处理业务事件，调用业务用例</div><div class="line">#pragma mark Handle business event</div><div class="line"></div><div class="line">//------Interactor-------</div><div class="line"></div><div class="line">//监控、接收业务事件</div><div class="line">#pragma mark Send business event</div><div class="line"></div><div class="line">//业务用例</div><div class="line">#pragma mark Business use case</div><div class="line"></div><div class="line">//获取生成model需要的数据</div><div class="line">#pragma mark Request data for model</div><div class="line"></div><div class="line">//维护model</div><div class="line">#pragma mark Manage model</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这里缺少了View状态管理、业务状态管理等职责，因为这些状态一般都是@property，用pragma mark不能分隔它们，只能在@interface里声明的时候进行隔离。</p>
<h2 id="方案二：允许适当耦合"><a href="#方案二：允许适当耦合" class="headerlink" title="方案二：允许适当耦合"></a>方案二：允许适当耦合</h2><p>上面的方案是以最彻底的解耦为目标设计的，在实践中，如果真的完全按照这个设计，代码量的确不小。其实一些地方的耦合并不会引起多大问题，除非你的模块需要封装成通用组件供多个app使用，否则并不需要按照100%的解耦要求来编写。因此接下来我再总结一个稍微简化的方案，总结一下各部分可以在哪些地方出现耦合，哪些耦合不能出现。</p>
<p>在这个方案里，我使用了一个中介者来减少一部分代码，Router就是一个很适合成为中介者的角色。</p>
<p>架构图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1865432-2a5e4eaf6275caba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="final_viper"></p>
<h3 id="View-1"><a href="#View-1" class="headerlink" title="View"></a>View</h3><ul>
<li>View可以直接通过Router引入另一个子View，不需要通过Presenter的路由来引入</li>
<li>View中的一些delegate如果变化的可能性不大，可以直接让Presenter实现（例如<code>UITableViewDataSource</code>），不用再封装一遍后交给Presenter</li>
<li>View不能出现Model类</li>
</ul>
<h3 id="Presenter-1"><a href="#Presenter-1" class="headerlink" title="Presenter"></a>Presenter</h3><ul>
<li>Presenter可以直接调用Router执行路由，不用再通过Wireframe封装一遍</li>
<li>Presenter的接口参数中可以出现Model类，但是不能导入Model类的头文件并且使用Model类，只能用于参数传递</li>
<li>Presenter中不建议导入UIKit，除非能保证不会使用那些会影响控件渲染的方法</li>
</ul>
<h3 id="Interactor-1"><a href="#Interactor-1" class="headerlink" title="Interactor"></a>Interactor</h3><ul>
<li>一些app中常用的Service可以直接引入，不需要通过外部注入的方式来使用</li>
<li>Interactor可以用一个Service Router来动态获取Service</li>
</ul>
<h3 id="路由和依赖注入"><a href="#路由和依赖注入" class="headerlink" title="路由和依赖注入"></a>路由和依赖注入</h3><p>改变得最多的就是路由部分。View、Presenter和Interactor都可以使用路由来获取一些模块。View可以通过路由获取子View，Presenter可以通过路由获取其他View模块，Interactor可以通过路由获取Service。</p>
<p>在实现时，可以把Wireframe、Router、Builder整合到一起，全都放到Router里，Router由模块实现并提供给外部使用。类似于Brigade团队和Rambler&amp;Co团队的实现。但是他们的实现都是直接在Router里引入其他模块的Router，这样会导致依赖混乱，更好的方式是通过一个中间人统一提供其他模块的接口。</p>
<p>我在这里造了个轮子，通过protocol来寻找需要的模块并执行路由，不用直接导入目的模块中的类，并且提供了Adapter的支持，可以让多个protocol指向同一个模块。这样就能避免模块间的直接依赖。</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">///editor模块的依赖声明</div><div class="line">@protocol NoteEditorProtocol &lt;NSObject&gt;</div><div class="line">@property (nonatomic, weak) id&lt;ZIKEditorDelegate&gt; delegate;</div><div class="line">- (void)constructForCreatingNewNote;</div><div class="line">- (void)constructForEditingNote:(ZIKNoteModel *)note;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ZIKNoteListViewPresenter</div><div class="line"></div><div class="line">- (void)handleDidSelectRowAtIndexPath:(NSIndexPath *)indexPath &#123;</div><div class="line">    NSAssert([[self.view routeSource] isKindOfClass:[UIViewController class]], nil);</div><div class="line">    </div><div class="line">    //跳转到编辑器界面；通过protocol获取对应的router类，再通过protocol注入依赖</div><div class="line">    //App可以用Adapter把NoteEditorProtocol和真正的protocol进行匹配和转接</div><div class="line">    [ZIKViewRouterToModule(NoteEditorProtocol)</div><div class="line">	     performWithConfigure:^(ZIKViewRouteConfiguration&lt;NoteEditorProtocol&gt; *config) &#123;</div><div class="line">	         //路由配置</div><div class="line">	         //跳转的源界面</div><div class="line">	         config.source = [self.view routeSource];</div><div class="line">	         //设置跳转方式，支持所有界面跳转类型</div><div class="line">	         config.routeType = ZIKViewRouteTypePush;</div><div class="line">	         //Router内部负责用获取到的参数初始化editor模块</div><div class="line">	         config.delegate = self;</div><div class="line">	         [config constructForEditingNote:[self.interactor noteAtIndex:indexPath.row]];</div><div class="line">	         config.prepareForRoute = ^(id destination) &#123;</div><div class="line">	             //跳转前配置目的界面</div><div class="line">	         &#125;;</div><div class="line">	         config.routeCompletion = ^(id destination) &#123;</div><div class="line">	             //跳转结束处理</div><div class="line">	         &#125;;</div><div class="line">	         config.performerErrorHandler = ^(SEL routeAction, NSError * error) &#123;</div><div class="line">	             //跳转失败处理</div><div class="line">	         &#125;;</div><div class="line">	     &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>这个方案依赖于一个统一的中间人，也就是路由工具，在我的实现里就是<a href="https://github.com/Zuikyo/ZIKRouter" target="_blank" rel="external">ZIKRouter</a>。View、Presenter、Interactor都可以使用对应功能的Router获取子模块。而由于ZIKRouter仍然是通过protocol的方式来和子模块进行交互，因此仍然可保持模块间解耦。唯一的耦合就是各部分都引用了ZIKRouter这个工具。如果你想把模块和ZIKRouter的耦合也去除，可以让Router也变成面向接口，由外部注入。</p>
<h2 id="Demo和代码模板"><a href="#Demo和代码模板" class="headerlink" title="Demo和代码模板"></a>Demo和代码模板</h2><p>针对两个方案，同时写了两个相同功能的Demo，可以比较一下代码上的区别。地址在：<a href="https://github.com/Zuikyo/ZIKViper" target="_blank" rel="external">ZIKViper</a></p>
<p>项目里也提供了Xcode File Template用于快速生成VIPER代码模板。把<code>.xctemplate</code>后缀的文件夹拷贝到<code>~/Library/Developer/Xcode/Templates/</code>目录下，就可以在Xcode的<code>New-&gt;File-&gt;Template</code>里选择代码模板快速生成代码。</p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>VIPER是按照Clean Architecture中由外向内的依赖进行设计的，各部分职责十分明确。并且由于引入了路由部分，更容易支持组件化开发。</p>
<p>下一篇文章将讨论基于接口的路由设计，总结UIKit中的各种视图转场，并讲解ZIKRouter的实现。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://mutualmobile.com/posts/meet-viper-fast-agile-non-lethal-ios-architecture-framework" target="_blank" rel="external">MEET VIPER: MUTUAL MOBILE’S APPLICATION OF CLEAN ARCHITECTURE FOR IOS APPS</a></li>
<li><a href="https://www.objc.io/issues/13-architecture/viper/" target="_blank" rel="external">Architecting iOS Apps with VIPER</a></li>
<li><a href="https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html" target="_blank" rel="external">Clean Architecture</a></li>
<li><a href="https://brigade.engineering/brigades-experience-using-an-mvc-alternative-36ef1601a41f" target="_blank" rel="external">Brigade’s Experience Using an MVC Alternative: VIPER architecture for iOS applications</a></li>
<li><a href="https://swifting.io/blog/2016/03/07/8-viper-to-be-or-not-to-be/" target="_blank" rel="external">VIPER to be or not to be?</a></li>
<li><a href="https://cheesecakelabs.com/blog/best-practices-viper-architecture/" target="_blank" rel="external">VIPER architecture: Our best practices to build an app like a boss</a></li>
<li><a href="https://github.com/strongself/The-Book-of-VIPER" target="_blank" rel="external">The-Book-of-VIPER</a></li>
<li><a href="https://eng.uber.com/new-rider-app/" target="_blank" rel="external">ENGINEERING THE ARCHITECTURE BEHIND UBER’S NEW RIDER APP</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一篇文章对VIPER进行了简单的介绍，这篇文章将从VIPER的源头开始，比较现有的几种VIPER实现，对VIPER进行进一步的职责剖析，并对各种细节实现问题进行挖掘和探讨。最后给出两个完整的VIPER实现，并且提供快速生成VIPER代码的模板。&lt;/p&gt;
&lt;p&gt;Demo和轮
    
    </summary>
    
      <category term="代码架构" scheme="http://yoursite.com/categories/%E4%BB%A3%E7%A0%81%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS VIPER架构实践(一)：从MVC到MVVM到VIPER</title>
    <link href="http://yoursite.com/2017/07/21/iOS%20VIPER%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5(%E4%B8%80)%EF%BC%9A%E4%BB%8EMVC%E5%88%B0MVVM%E5%88%B0VIPER/"/>
    <id>http://yoursite.com/2017/07/21/iOS VIPER架构实践(一)：从MVC到MVVM到VIPER/</id>
    <published>2017-07-21T12:58:29.000Z</published>
    <updated>2017-09-27T15:36:01.030Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>最近半年在写app的时候，研究了一下各种iOS代码架构，最后选择了VIPER进行实践，在此对实践中遇到的各种设计问题做一番总结，并分享造出的轮子。</p>
<p>对代码风格和架构有兴趣的同学，肯定都已经在很多地方见过各种架构的介绍。MVC、MVP、MVVM、VIPER，细分程度逐渐上升。这些架构设计都是来自MVC，只是各自用不同的方式对MVC进行了细分，在此只对MVC、MVP和MVVM作精简介绍，想要详细了解可以参考这些文章：</p>
<p><a href="http://ios.jobbole.com/83727/" target="_blank" rel="external">iOS 架构模式–解密 MVC，MVP，MVVM以及VIPER架构</a>,</p>
<p><a href="http://draveness.me/mvx.html" target="_blank" rel="external">浅谈 MVC、MVP 和 MVVM 架构模式</a>。</p>
<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p><code>Model-View-Controller</code>。MVC简单地将一个模块分为3部分：</p>
<ul>
<li>View是展示给外部的界面</li>
<li>Model是Controller内部管理的数据模型</li>
<li>Controller负责将Model的变化更新到View</li>
<li>Controller负责处理来自View的事件</li>
</ul>
<p>MVC的划分粒度很粗，因此有很多种具体实现，各个实现有差异，因此并没有一个十分明确的标准定义。</p>
<h2 id="苹果的MVC"><a href="#苹果的MVC" class="headerlink" title="苹果的MVC"></a>苹果的MVC</h2><p>苹果的Cocoa Touch就遵照了MVC的设计，一个界面分为UIView和UIViewController，UIView负责渲染和接收触摸事件，UIViewController负责子view之间的布局、组合、更新以及事件处理。</p>
<p>尽管苹果已经给我们提供了简单的MVC支持，但是在实践中我们却常常没有遵守MVC。原因在于Cocoa Touch中的Model部分是由我们自己负责管理的，并没有提供原生的设计支持。所以有时候会出现这样的情况：一个UIView为了方便，提供了一个从某个model进行配置的方法。乍一看十分合理，但是仔细想想就会发现，这么做已经将View和Model耦合，不符合苹果官方的MVC规范(<a href="https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/index.html#//apple_ref/doc/uid/TP40007457-CH2-SW1" target="_blank" rel="external">The Role of View Controllers</a>)。</p>
<p>另外，UIViewController存在的一些问题，导致了它很容易变得臃肿和耦合。</p>
<p>首先，UIViewController和UIView耦合得十分紧密，导致UIViewController经常和某些具体的UIView耦合，几乎无法重用。而且在测试的时候，很难做到单独测试没有View的那部分代码，因为在写的时候就很容易将View的逻辑入侵到各处，Controller会受到View的状态的影响，无法稳定测试。因此，应该尽量把和View无关的代码放到UIViewController之外。</p>
<p>第二，UIViewController负责了界面跳转的操作，界面跳转的相关配置是直接在对应的UIViewController实例上设置的，这样就很容易把源界面和目的界面耦合起来，简单地把界面跳转的部分单独抽离为一个封装好的跳转方法可以一定程度上减少这部分耦合，但也不可避免地会多写许多代码。</p>
<p>因此，苹果的MVC，实际上是<code>Model-View-ViewController</code>。它是一个视图驱动的设计，Controller只是为了管理View而存在的。苹果把UIViewController和Model的关系设计交给了我们自己。所以，如何把一个UIViewController进行更明确的分工，就是这些架构要做的事。</p>
<h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><p><code>Model-View-Presenter</code>用一个Presenter，把Controller中View的部分剔除，实现了View和Model的隔绝。各部分分工如下：</p>
<ul>
<li>View负责界面展示和布局管理，向Presenter暴露视图更新和数据获取的接口</li>
<li>Presenter负责接收来自View的事件，通过View提供的接口更新视图，并管理Model</li>
<li>Model和MVC中的一样，提供数据模型</li>
</ul>
<p>在iOS里，UIView和UIViewController共同组合成了MVP中的View。UIView负责元素的展示，UIViewController负责界面布局和组合，并把事件转发给Presenter。<br>因此在MVP里，业务逻辑被放到了Presenter中，由它负责协调View和Model。而由于View的抽离，Presenter的状态是可控的，在测试时更不容易受外部影响。</p>
<p>在iOS中使用MVP很简单，在View和Presenter之间用protocol做好事件传递就可以。缺点就是多了一层用于隔离的接口，会导致代码数量增大。</p>
<p>但是随着界面越来越复杂，Presenter中的业务代码也会越来越庞大，总有一天会遇到一个新的问题：如何再细分Presenter。</p>
<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p><code>Model-View-ViewModel-Controller</code>模式，它也和MVP一样，目的是解决View和Model的耦合。各部分分工如下：</p>
<ul>
<li>Model提供数据模型</li>
<li>View负责视图展示</li>
<li>ViewModel用于描述View的状态，例如View的颜色、显示的文字等属性类的信息，将View抽象成了一个特殊的模型</li>
<li>Controller(Presenter)通过修改ViewModel来更新View，并且负责事件处理，维护Model</li>
</ul>
<p>在MVP中，View通过接口的方式来描述自己，在MVVM中，则通过ViewModel来描述自己的特征。那么ViewModel如何将自己的变化更新到View上呢？MVVM经常和数据绑定一起出现，在Controller中，将View和ViewModel的属性用类似KVO的方式进行绑定，这样ViewModel的变化就能立即传输到View上。注意，这里的Controller不是UIViewController，而是负责模块业务逻辑的一个角色，类似于Presenter。</p>
<p>但是数据绑定的缺点也很明显：调试困难，数据来源难以回溯，在线上出bug的时候就很难追踪了。</p>
<p>其实数据绑定只是一种为了减少胶水代码的技术实现方式，MVVM的设计并没有要求必须要使用数据绑定，你也完全可以使用protocol的方式来将ViewModel的变化传递给View，让数据流向更清晰。MVVM的关键是将View进行了抽象，并且这个抽象很容易在其他Controller中复用。</p>
<p>Controller在绑定完View和ViewModel之后，就不应该在其他地方使用View了。你也可以单独用一个ViewModelManager来负责设置ViewModel和View之间的数据传递。而其他的业务代码，还是放在Controller中，ViewModel应该只负责管理View相关的状态、传递View的事件，不应该存在本属于Controller中的其他业务。当然如果你不打算重用这个ViewModel的话，也可以在ViewModel里加入一些和Model相关的业务逻辑，维护Model，只不过基于单一职责原则，这么做是不好的。</p>
<p>和MVP相比，MVVM用了一种更优雅的方式来抽象View。但它和MVP其实是类似的，仍然没有对Controller进行进一步的细分。</p>
<p>那么如何对Controller进行进一步的职责细分呢？答案就是VIPER。</p>
<h2 id="VIPER"><a href="#VIPER" class="headerlink" title="VIPER"></a>VIPER</h2><p>VIPER的全称是<code>View-Interactor-Presenter-Entity-Router</code>。示意图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1865432-580872920986b640.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="VIPER"></p>
<p>相比之前的MVX架构，VIPER多出了两个东西：Interactor（交互器）和Router（路由）。</p>
<p>各部分职责如下：</p>
<h3 id="View"><a href="#View" class="headerlink" title="View"></a>View</h3><ul>
<li>提供完整的视图，负责视图的组合、布局、更新</li>
<li>向Presenter提供更新视图的接口</li>
<li>将View相关的事件发送给Presenter</li>
</ul>
<h3 id="Presenter"><a href="#Presenter" class="headerlink" title="Presenter"></a>Presenter</h3><ul>
<li>接收并处理来自View的事件</li>
<li>向Interactor请求调用业务逻辑</li>
<li>向Interactor提供View中的数据</li>
<li>接收并处理来自Interactor的数据回调事件</li>
<li>通知View进行更新操作</li>
<li>通过Router跳转到其他View</li>
</ul>
<h3 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h3><ul>
<li>提供View之间的跳转功能，减少了模块间的耦合</li>
<li>初始化VIPER的各个模块</li>
</ul>
<h3 id="Interactor"><a href="#Interactor" class="headerlink" title="Interactor"></a>Interactor</h3><ul>
<li>维护主要的业务逻辑功能，向Presenter提供现有的业务用例</li>
<li>维护、获取、更新Entity</li>
<li>当有业务相关的事件发生时，处理事件，并通知Presenter</li>
</ul>
<h3 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h3><ul>
<li>和Model一样的数据模型</li>
</ul>
<h3 id="和MVX的区别"><a href="#和MVX的区别" class="headerlink" title="和MVX的区别"></a>和MVX的区别</h3><p>VIPER把MVC中的Controller进一步拆分成了Presenter、Router和Interactor。和MVP中负责业务逻辑的Presenter不同，VIPER的Presenter的主要工作是在View和Interactor之间传递事件，并管理一些View的展示逻辑，主要的业务逻辑实现代码都放在了Interactor里。Interactor的设计里提出了”用例”的概念，也就是把每一个会出现的业务流程封装好，这样可测试性会大大提高。而Router则进一步解决了不同模块之间的耦合。所以，VIPER和上面几个MVX相比，多总结出了几个需要维护的东西：</p>
<ul>
<li>View事件管理</li>
<li>数据事件管理</li>
<li>事件和业务的转化</li>
<li>总结每个业务用例</li>
<li>模块内分层隔离</li>
<li>模块间通信</li>
</ul>
<p>而这里面，还可以进一步细分一些职责。VIPER实际上已经把Controller的概念淡化了，这拆分出来的几个部分，都有很明确的单一职责，有些部分之间是完全隔绝的，在开发时就应该清晰地区分它们各自的职责，而不是将它们视为一个Controller。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>VIPER的特色就是职责明确，粒度细，隔离关系明确，这样能带来很多优点：</p>
<ul>
<li>可测试性好。UI测试和业务逻辑测试可以各自单独进行。</li>
<li>易于迭代。各部分遵循单一职责，可以很明确地知道新的代码应该放在哪里。</li>
<li>隔离程度高，耦合程度低。一个模块的代码不容易影响到另一个模块。</li>
<li>易于团队合作。各部分分工明确，团队合作时易于统一代码风格，可以快速接手别人的代码。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>一个模块内的类数量增大，代码量增大，在层与层之间需要花更多时间设计接口。</li>
</ul>
<p>使用代码模板来自动生成文件和模板代码可以减少很多重复劳动，而花费时间设计和编写接口是减少耦合的路上不可避免的，你也可以使用数据绑定这样的技术来减少一些传递的层次。</p>
<ul>
<li>模块的初始化较为复杂，打开一个新的界面需要生成View、Presenter、Interactor，并且设置互相之间的依赖关系。而iOS中缺少这种设置复杂初始化的原生方式。</li>
</ul>
<p>简单来说，就是Cocoa框架缺少一个强大的自定义依赖注入工具。这个问题影响不是特别大，可以选用一些第三方工具来实现，也可以在Router的界面跳转方法里，对模块进行初始化，只不过总是不够完美。针对这个问题，我实现了一个基于protocol声明依赖的界面跳转Router，将会在之后的文章中进行详解。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>有人可能会觉得，一个界面模块真的有必要使用这么复杂的架构吗？这样是不是过度设计？</p>
<p>我反对这种观点。不要被VIPER的组织图吓到，VIPER并不复杂，它是将原来MVC中的Controller中的各种任务进行了清晰的分解，在写代码时，你会很清楚你正在做什么。事实上，它比使用了数据绑定技术的MVVM更加简单，就是因为它职责明确。从MVC转到VIPER的过程同样是很清晰的，它甚至把重构的思路都体现出来了。而MVVM则留下了许多尚未明确的责任，导致不同的人会在某些地方有不同的实现。即便你还在使用MVC，你也应该在Controller中分离出VIPER总结出的那些专项职责，既然如此，为何不彻底地明确这些职责，把它们分散到不同的文件中呢？一旦开始这样的工作，你就已经向VIPER靠拢了。</p>
<p>有人可能会觉得，VIPER适合大型app，中小型app没必要过早使用。</p>
<p>我反对这种观点。VIPER是单个界面模块内的架构设计，并不是整个app架构层面的设计，和app的整体架构没有多大的关系，也不存在过早使用VIPER的情况。你是愿意1天开发，3天修bug，还是更愿意1.5天开发，1天修bug呢？</p>
<p>至此，我的结论就是，快点拥抱VIPER的怀抱吧。</p>
<h3 id="开始实践"><a href="#开始实践" class="headerlink" title="开始实践"></a>开始实践</h3><p>VIPER是2013年首次在iOS平台上提出的设计，十分年轻，因此缺少大量参与者，以总结出更多最佳实践。下一篇文章将会从VIPER的源头开始，比较现有的各种VIPER实现，总结出一个我认为较好的实施方案。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://ios.jobbole.com/83727/" target="_blank" rel="external">iOS 架构模式–解密 MVC，MVP，MVVM以及VIPER架构</a></li>
<li><a href="http://draveness.me/mvx.html" target="_blank" rel="external">浅谈 MVC、MVP 和 MVVM 架构模式</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;最近半年在写app的时候，研究了一下各种iOS代码架构，最后选择了VIPER进行实践，在此对实践中遇到的各种设计问题做一番总结，并分享造出的
    
    </summary>
    
      <category term="代码架构" scheme="http://yoursite.com/categories/%E4%BB%A3%E7%A0%81%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>CFRunloop的多线程隐患</title>
    <link href="http://yoursite.com/2017/05/22/CFRunloop%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9A%90%E6%82%A3/"/>
    <id>http://yoursite.com/2017/05/22/CFRunloop的多线程隐患/</id>
    <published>2017-05-22T08:29:29.000Z</published>
    <updated>2017-08-13T07:25:24.120Z</updated>
    
    <content type="html"><![CDATA[<p>如果你还不了解什么是runloop，可以看这里的详解<a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a>。</p>
<p>苹果<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW26" target="_blank" rel="external">官方文档</a>中，声明了CFRunloop是线程安全的：</p>
<blockquote>
<p>Thread safety varies depending on which API you are using to manipulate your run loop. The functions in Core Foundation are <strong><em>generally</em></strong> thread-safe and can be called from any thread. If you are performing operations that alter the configuration of the run loop, however, it is still good practice to do so from the thread that owns the run loop whenever possible.</p>
</blockquote>
<p>但是需要注意的是，狡猾的苹果使用了<code>generally</code>这个模糊的词。</p>
<p>从实践中来看，CFRunloop在停止runloop的阶段的某些操作是存在多线程隐患的。</p>
<h2 id="不安全的CFRunloopSource"><a href="#不安全的CFRunloopSource" class="headerlink" title="不安全的CFRunloopSource"></a>不安全的CFRunloopSource</h2><p>CFRunloop是线程安全的，但是加上CFRunloopSource就不一定了。比如CFSocket。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>看这样一段自定义线程的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">@interface MyThread()</div><div class="line">@property (nonatomic, strong) NSThread *currentThread;</div><div class="line">@property (nonatomic, assign) CFRunLoopSourceRef socketSource;</div><div class="line">@property (nonatomic, assign) CFSocketRef socket;</div><div class="line">@property (nonatomic, assign) CFRunLoopRef currentRunloop;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation MyThread</div><div class="line"></div><div class="line">//初始化线程</div><div class="line">- (instancetype)init &#123;</div><div class="line">    if (self = [super init]) &#123;</div><div class="line">        _currentThread = [[NSThread alloc] initWithTarget:self selector:@selector(runThread) object:nil];</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//开启线程；此方法在使用时没有多线程调用</div><div class="line">- (void)startThread &#123;</div><div class="line">    [self.currentThread start];</div><div class="line">&#125;</div><div class="line"></div><div class="line">//线程入口</div><div class="line">- (void)runThread &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">    //返回runloop，可以让其他线程停止此线程</div><div class="line">        self.currentRunloop = CFRunLoopGetCurrent();</div><div class="line">        [self addSocketSource];</div><div class="line">        </div><div class="line">        CFRunLoopRun();</div><div class="line">    &#125;</div><div class="line">    NSLog(@&quot;线程退出&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//此方法在使用时没有多线程调用</div><div class="line">- (void)stopThread &#123;</div><div class="line">	 [self removeSocketSource];</div><div class="line">	 @synchronized (_currentRunloop) &#123;</div><div class="line">        if (_currentRunloop) &#123;</div><div class="line">	        CFRunLoopStop(_currentRunloop);</div><div class="line">	        self.currentRunloop = NULL;</div><div class="line">	    &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//此方法在使用时没有多线程调用</div><div class="line">- (void)addSocketSource &#123;</div><div class="line">    int sock;</div><div class="line">    sock = socket(AF_INET6, SOCK_STREAM, 0);</div><div class="line">    CFSocketContext context = &#123;0, (__bridge void *)(self), NULL, NULL, NULL&#125;;</div><div class="line">    self.socket = CFSocketCreateWithNative(NULL, sock, kCFSocketReadCallBack, socketCallBack, &amp;context);</div><div class="line">    self.socketSource = CFSocketCreateRunLoopSource(NULL, self.socket, 0);</div><div class="line">    CFRunLoopAddSource(_currentRunloop, _socketSource, kCFRunLoopDefaultMode);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)removeSocketSource &#123;</div><div class="line">	@synchronized (_socket) &#123;</div><div class="line">		if (_socket) &#123;</div><div class="line">			//CFSocketInvalidate可能被抛到另一个线程去执行，因此 CFSocketInvalidate 和 CFRunLoopStop可能有多线程同时调用的情况       </div><div class="line">	        CFSocketInvalidate(_socket);</div><div class="line">	        CFRelease(_socket);</div><div class="line">	        self.socket = NULL;</div><div class="line">	    &#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在实践中，CFSocket是被另一个socket类管理的，所以<code>addSocketSource</code>和<code>removeSocketSource</code>都是在另一个类中的，也就有可能出现<code>CFSocketInvalidate</code>和 <code>CFRunLoopStop</code>多线程同时调用的情况。</p>
<h3 id="crash实例分析"><a href="#crash实例分析" class="headerlink" title="crash实例分析"></a>crash实例分析</h3><p>看上去并没有什么问题，该加锁的地方都加锁了，而且CF开头的那几个方法都是线程安全的。但是这时候，如果出现<code>CFSocketInvalidate</code>和 <code>CFRunLoopStop</code>多线程同时调用的情况，就有crash的可能。例如我们项目里收到的某个crash：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">Thread 0 name:  Dispatch queue: com.apple.main-thread</div><div class="line">Thread 0 Crashed:</div><div class="line">0   CoreFoundation                  0x000000018e6a9144 CFRunLoopWakeUp + 92</div><div class="line">1   CoreFoundation                  0x000000018e6a9140 CFRunLoopWakeUp + 88</div><div class="line">2   CoreFoundation                  0x000000018e6d71e8 CFSocketInvalidate + 712</div><div class="line">3   MyApp                           0x00000001000fe424 (-[MySocket stop] + 136)</div><div class="line">4   MyApp                           0x00000001000fcd50 (-[MySocket dealloc] + 56)</div><div class="line">5   libsystem_blocks.dylib          0x000000018d6afa28 _Block_release + 144</div><div class="line">6   libdispatch.dylib               0x000000018d65a1bc _dispatch_client_callout + 16</div><div class="line">7   libdispatch.dylib               0x000000018d65ed68 _dispatch_main_queue_callback_4CF + 1000</div><div class="line">8   CoreFoundation                  0x000000018e77e810 __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__ + 12</div><div class="line">9   CoreFoundation                  0x000000018e77c3fc __CFRunLoopRun + 1660</div><div class="line">10  CoreFoundation                  0x000000018e6aa2b8 CFRunLoopRunSpecific + 444</div><div class="line">11  GraphicsServices                0x000000019015e198 GSEventRunModal + 180</div><div class="line">12  UIKit                           0x00000001946f17fc -[UIApplication _run] + 684</div><div class="line">13  UIKit                           0x00000001946ec534 UIApplicationMain + 208</div><div class="line">14  DuoYiIM                         0x000000010003ca58 0x100024000 + 100952 (main + 132)</div><div class="line">15  libdyld.dylib                   0x000000018d68d5b8 start + 4</div><div class="line"></div><div class="line">Thread 0 crashed with ARM-64 Thread State:</div><div class="line">  cpsr: 0x0000000020000000     fp: 0x000000016fddab30     lr: 0x000000018e6a9140     pc: 0x000000018e6a9144 </div><div class="line">    sp: 0x000000016fddaa00     x0: 0x0000000000000000     x1: 0x0000000000000000    x10: 0x0000000000000000 </div><div class="line">   x11: 0x0000000000000000    x12: 0x0000000000000000    x13: 0x0000000000000000    x14: 0x0000000000000000 </div><div class="line">   x15: 0x0000000000001203    x16: 0x000000000000012d    x17: 0x000000018f1eef74    x18: 0x0000000000000000 </div><div class="line">   x19: 0x000000017056cb50     x2: 0x0000000000001000    x20: 0x000000017056cb40    x21: 0x96e73914144e0055 </div><div class="line">   x22: 0x0000000174452990    x23: 0x000000017048bae0    x24: 0x0000000000000000    x25: 0x00000000ffffffff </div><div class="line">   x26: 0xffffffffffffffff    x27: 0x000000017426f1c0    x28: 0x0000000002ffffff    x29: 0x000000016fddab30 </div><div class="line">    x3: 0x000000000017e4a6     x4: 0x0000000000012068     x5: 0x0000000000000000     x6: 0x0000000000000036 </div><div class="line">    x7: 0xffffffffffffffec     x8: 0x8c8c8c8c8c8c8c8c     x9: 0x000000000000000c</div></pre></td></tr></table></figure>
<p><code>CFSocketInvalidate</code>在主线程被调用了。看堆栈，在<code>CFSocketInvalidate</code>内部调用<code>CFRunLoopWakeUp</code>时，出现了crash。</p>
<p>看不出具体是什么原因crash，所以需要看看是在<code>CFRunLoopWakeUp</code>的哪里挂的。查看对应版本的<code>CoreFoundation</code>的汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">_CFRunLoopWakeUp:</div><div class="line">0x0000000181521b9c FF0305D1               sub        sp, sp, #0x140             ; CODE XREF=_CFRunLoopAddTimer+696, _CFRunLoopTimerSetNextFireDate+592, _CFSocketInvalidate+708, __wakeUpRunLoop+276, __CFXRegistrationPost+344, -[CFPrefsSearchListSource asynchronouslyNotifyOfChangesFromDictionary:toDictionary:]+172, ___CFSocketPerformV0+1408, ___CFSocketManager+2004, ___CFSocketManager+4248, _boundPairRead+604, _boundPairReadClose+124, …</div><div class="line">0x0000000181521ba0 FC6F11A9               stp        x28, x27, [sp, #0x110]</div><div class="line">0x0000000181521ba4 F44F12A9               stp        x20, x19, [sp, #0x120]</div><div class="line">0x0000000181521ba8 FD7B13A9               stp        x29, x30, [sp, #0x130]</div><div class="line">0x0000000181521bac FDC30491               add        x29, sp, #0x130</div><div class="line">0x0000000181521bb0 F40300AA               mov        x20, x0</div><div class="line">0x0000000181521bb4 C80C10F0               adrp       x8, #0x1a16bc000</div><div class="line">0x0000000181521bb8 084140F9               ldr        x8, [x8, #0x80]            ; -[_CFXPreferences init]_1a16bc080</div><div class="line">0x0000000181521bbc 080140F9               ldr        x8, [x8]</div><div class="line">0x0000000181521bc0 292013F0               adrp       x9, #0x1a7928000</div><div class="line">0x0000000181521bc4 29E90791               add        x9, x9, #0x1fa             ; ___CF120290</div><div class="line">0x0000000181521bc8 A8831DF8               stur       x8, [x29, #-0x28]</div><div class="line">0x0000000181521bcc E8030032               orr        w8, wzr, #0x1</div><div class="line">0x0000000181521bd0 28010039               strb       w8, [x9]                   ; ___CF120290</div><div class="line">0x0000000181521bd4 E8731290               adrp       x8, #0x1a639d000</div><div class="line">0x0000000181521bd8 08F13F91               add        x8, x8, #0xffc             ; ___CF120293</div><div class="line">0x0000000181521bdc 08014039               ldrb       w8, [x8]                   ; ___CF120293</div><div class="line">0x0000000181521be0 48000034               cbz        w8, loc_181521be8</div><div class="line"></div><div class="line">0x0000000181521be4 E3560394               bl         ___THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__</div><div class="line"></div><div class="line">                                      loc_181521be8:</div><div class="line">0x0000000181521be8 93420091               add        x19, x20, #0x10            ; CODE XREF=_CFRunLoopWakeUp+68</div><div class="line">0x0000000181521bec E00313AA               mov        x0, x19</div><div class="line">0x0000000181521bf0 70300694               bl         imp___stubs_-[NSOrderedSet sortedArrayFromRange:options:usingComparator:]//真机的系统库做了混淆，这里其实是__CFRunLoopLock</div><div class="line">0x0000000181521bf4 882E40F9               ldr        x8, [x20, #0x58]</div><div class="line">0x0000000181521bf8 080D40B9               ldr        w8, [x8, #0xc]</div><div class="line">0x0000000181521bfc A8010034               cbz        w8, loc_181521c30</div></pre></td></tr></table></figure>
<p>crash日志中，崩溃在<code>CFRunLoopWakeUp + 92</code>，对应汇编地址为<code>0x0000000181521b9c + 92</code>=<code>0x0000000181521bf8</code>，在<code>ldr        w8, [x8, #0xc]</code>的时候挂了。查看crash时寄存器的值，<code>x8: 0x8c8c8c8c8c8c8c8c</code>，很明显<code>x8</code>指向的内存已经被释放了。<code>x8</code>是从<code>ldr        x8, [x20, #0x58]</code>得来的（也就是<code>x20</code>的地址偏移<code>0x58</code>后的值），而<code>x20</code>则是从<code>mov        x20, x0</code>得来的，<code>x0</code>就是<code>CFRunloopWakeUp</code>的第一个参数，<code>CFRunLoopRef</code>结构体，所以<code>x8</code>就是<code>CFRunLoopRef</code>偏移<code>0x58</code>后的值。</p>
<p><code>CoreFoundation</code>的代码是开源的，可以在这里下载：<a href="https://opensource.apple.com/tarballs/CF/CF-1153.18.tar.gz" target="_blank" rel="external">CF-1153.18</a>。</p>
<p>对应<code>CFRunloopWakeUp</code>源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">void CFRunLoopWakeUp(CFRunLoopRef rl) &#123;</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    __CFRunLoopLock(rl);</div><div class="line">    if (__CFRunLoopIsIgnoringWakeUps(rl)) &#123;</div><div class="line">        __CFRunLoopUnlock(rl);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    kern_return_t ret;</div><div class="line">    ret = __CFSendTrivialMachMessage(rl-&gt;_wakeUpPort, 0, MACH_SEND_TIMEOUT, 0);</div><div class="line">    if (ret != MACH_MSG_SUCCESS &amp;&amp; ret != MACH_SEND_TIMED_OUT) CRASH(&quot;*** Unable to send message to wake up port. (%d) ***&quot;, ret);</div><div class="line">    __CFRunLoopUnlock(rl);</div><div class="line">&#125;</div><div class="line"></div><div class="line">CF_INLINE Boolean __CFRunLoopIsIgnoringWakeUps(CFRunLoopRef rl) &#123;</div><div class="line">    return (rl-&gt;_perRunData-&gt;ignoreWakeUps) ? true : false;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>CFRunloop结构体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">struct __CFRunLoop &#123;</div><div class="line">    CFRuntimeBase _base;	//16 byte</div><div class="line">    pthread_mutex_t _lock;	//64 byte</div><div class="line">    __CFPort _wakeUpPort; //mach_port_t (unsign int), 4 byte</div><div class="line">    Boolean _unused;	//bool变量占用1 byte，但是需要和4字节对齐，所以也是4 byte</div><div class="line">    volatile _per_run_data *_perRunData;</div><div class="line">    pthread_t _pthread;</div><div class="line">    uint32_t _winthread;</div><div class="line">    CFMutableSetRef _commonModes;</div><div class="line">    CFMutableSetRef _commonModeItems;</div><div class="line">    CFRunLoopModeRef _currentMode;</div><div class="line">    CFMutableSetRef _modes;</div><div class="line">    struct _block_item *_blocks_head;</div><div class="line">    struct _block_item *_blocks_tail;</div><div class="line">    CFAbsoluteTime _runTime;</div><div class="line">    CFAbsoluteTime _sleepTime;</div><div class="line">    CFTypeRef _counterpart;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">typedef struct __CFRuntimeBase &#123;</div><div class="line">    uintptr_t _cfisa;	//unsigned long 8 byte</div><div class="line">    uint8_t _cfinfo[4];	//unsigned char 4 byte</div><div class="line">#if __LP64__</div><div class="line">    uint32_t _rc;	//unsigned int 4 byte</div><div class="line">#endif</div><div class="line">&#125; CFRuntimeBase;</div><div class="line"></div><div class="line">struct pthread_mutex_t &#123;</div><div class="line">	long __sig;	//8 byte</div><div class="line">	char __opaque[56]; //56 byte</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>计算结构体size后，得出<code>ldr        x8, [x20, #0x58]</code>就是<code>runloop-&gt; _perRunData</code>。也就是在调用<code>__CFRunLoopIsIgnoringWakeUps</code>的时候，<code>CFRunLoopRef</code>已经被释放了。</p>
<h3 id="分析CFSocket源码"><a href="#分析CFSocket源码" class="headerlink" title="分析CFSocket源码"></a>分析<code>CFSocket</code>源码</h3><p>查看<code>CFSocketInvalidate</code>源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">void CFSocketInvalidate(CFSocketRef s) &#123;</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    CFRetain(s);</div><div class="line">    __CFLock(&amp;__CFAllSocketsLock);</div><div class="line">    __CFSocketLock(s);</div><div class="line">    if (__CFSocketIsValid(s)) &#123;</div><div class="line">    </div><div class="line">        //省略部分代码...</div><div class="line"></div><div class="line">		 //取出socket中的runloop数组</div><div class="line">        CFArrayRef runLoops = (CFArrayRef)CFRetain(s-&gt;_runLoops);</div><div class="line">       //CFRunloop释放操作1       </div><div class="line">        CFRelease(s-&gt;_runLoops);</div><div class="line">        </div><div class="line">        s-&gt;_runLoops = NULL;</div><div class="line">        </div><div class="line">        //省略部分代码...</div><div class="line">        </div><div class="line">        __CFSocketUnlock(s);</div><div class="line">        </div><div class="line">        // Do this after the socket unlock to avoid deadlock (10462525)</div><div class="line">        for (idx = CFArrayGetCount(runLoops); idx--;) &#123;</div><div class="line">            CFRunLoopWakeUp((CFRunLoopRef)CFArrayGetValueAtIndex(runLoops, idx));</div><div class="line">        &#125;</div><div class="line">        //CFRunloop释放操作3</div><div class="line">        CFRelease(runLoops);</div><div class="line"></div><div class="line">        //省略部分代码...</div><div class="line">    &#125; else &#123;</div><div class="line">        __CFSocketUnlock(s);</div><div class="line">    &#125;</div><div class="line">    __CFUnlock(&amp;__CFAllSocketsLock);</div><div class="line">    CFRelease(s);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>CFSocketInvalidate</code>中唯一使用到<code>CFRunLoopWakeUp</code>的地方，就是最后遍历runloops的操作。<br>但是此时<code>CFRunLoopRef</code>还在数组里，正在被数组强引用，到了<code>CFRunLoopWakeUp</code>里怎么就被释放了呢？</p>
<p>注意，<code>CFSocketInvalidate</code>里遍历runloops的操作是在锁外面进行的，说明CFSocket很有可能没有管理好它的runloops数组，导致数组在遍历时被释放了。从<code>Do this after the socket unlock to avoid deadlock (10462525)</code>这一行注释猜测，这部分遍历操作之前应该也是在锁内的，但是会出现死锁，所以放到了锁外。苹果的bug report是不对外公开的，只在这里找到了可能相关的讨论：<a href="https://bugreports.qt.io/browse/QTBUG-22789" target="_blank" rel="external">bug #10462525</a>。</p>
<p>最大的可能是出现在<code>__CFSocketCancel</code>里。在runloop停止的时候，也会执行remove source操作，在<code>CFRunLoopRemoveSource</code>里，会执行source0的cancel函数，也就是<code>__CFSocketCancel</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">void CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef rls, CFStringRef modeName) \</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    Boolean doVer0Callout = false, doRLSRelease = false;</div><div class="line">    __CFRunLoopLock(rl);</div><div class="line">    if (modeName == kCFRunLoopCommonModes) &#123;</div><div class="line">	//省略代码...</div><div class="line">    &#125; else &#123;</div><div class="line">	CFRunLoopModeRef rlm = __CFRunLoopFindMode(rl, modeName, false);</div><div class="line">	if (NULL != rlm &amp;&amp; ((NULL != rlm-&gt;_sources0 &amp;&amp; CFSetContainsValue(rlm-&gt;_sources0, rls)) || (NULL != rlm-&gt;_sources1 &amp;&amp; CFSetContainsValue(rlm-&gt;_sources1, rls)))) &#123;</div><div class="line">	    CFRetain(rls);</div><div class="line">	    //省略代码...</div><div class="line">	    if (0 == rls-&gt;_context.version0.version) &#123;</div><div class="line">	        if (NULL != rls-&gt;_context.version0.cancel) &#123;</div><div class="line">	            doVer0Callout = true;</div><div class="line">	        &#125;</div><div class="line">	    &#125;</div><div class="line">	    doRLSRelease = true;</div><div class="line">	&#125;</div><div class="line">        //省略代码...</div><div class="line">	&#125;</div><div class="line">    &#125;</div><div class="line">    __CFRunLoopUnlock(rl);</div><div class="line">    if (doVer0Callout) &#123;</div><div class="line">        // although it looses some protection for the source, we have no choice but</div><div class="line">        // to do this after unlocking the run loop and mode locks, to avoid deadlocks</div><div class="line">        // where the source wants to take a lock which is already held in another</div><div class="line">        // thread which is itself waiting for a run loop/mode lock</div><div class="line">        rls-&gt;_context.version0.cancel(rls-&gt;_context.version0.info, rl, modeName);	/* CALLOUT */</div><div class="line">    &#125;</div><div class="line">    if (doRLSRelease) CFRelease(rls);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>__CFSocketCancel</code>源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">static void __CFSocketCancel(void *info, CFRunLoopRef rl, CFStringRef mode) &#123;</div><div class="line">    CFSocketRef s = (CFSocketRef)info;</div><div class="line">    __CFSocketLock(s);</div><div class="line">    if (0 == s-&gt;_socketSetCount) &#123;</div><div class="line">        //省略代码...</div><div class="line">    if (NULL != s-&gt;_runLoops) &#123;</div><div class="line">    //从runloops数组中移除此runloop；对原数组执行拷贝后，释放原数组</div><div class="line">        CFMutableArrayRef runLoopsOrig = s-&gt;_runLoops;</div><div class="line">        CFMutableArrayRef runLoopsCopy = CFArrayCreateMutableCopy(kCFAllocatorSystemDefault, 0, s-&gt;_runLoops);</div><div class="line">        idx = CFArrayGetFirstIndexOfValue(runLoopsCopy, CFRangeMake(0, CFArrayGetCount(runLoopsCopy)), rl);</div><div class="line">        if (0 &lt;= idx) CFArrayRemoveValueAtIndex(runLoopsCopy, idx);</div><div class="line">        s-&gt;_runLoops = runLoopsCopy;</div><div class="line">        //CFRunloop释放操作2</div><div class="line">        CFRelease(runLoopsOrig);</div><div class="line">    &#125;</div><div class="line">    __CFSocketUnlock(s);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>__CFSocketCancel</code>也有一次对<code>CFRunloopRef</code>的释放操作，加上<code>CFSocketInvalidate</code>里的2个，总共有3个释放操作。</p>
<p>所以，如果<code>__CFSocketCancel</code>和<code>CFSocketInvalidate</code>在多线程同时执行，就有可能出现对CFSocket中的runloops数组过度释放，因此在遍历runloops的时候就会出现<code>CFRunLoopRef</code>被释放的情况。虽然这个crash出现的概率比较低，但是在项目里隔一段时间就会稳定出现。</p>
<p>所以，不是加了锁就万事大吉了，<code>CFSocketInvalidate</code>里在遍历数组前应该再加一个retain才能保证安全。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ul>
<li>既然是CFSocket里的bug，那就只能避免不要出现<code>CFSocketInvalidate</code>和<code>CFRunloopStop</code>多线程执行的代码。</li>
<li>如果你的socket只在这个线程里运行，那直接调用<code>CFRunloopStop</code>即可，runloop会自动清理所有source。</li>
<li>如果这个线程需要重用，那就不需要stop，而是停止socket后，在同一个线程里新建socket。</li>
</ul>
<h2 id="自动停止的Runloop"><a href="#自动停止的Runloop" class="headerlink" title="自动停止的Runloop"></a>自动停止的Runloop</h2><p>那么，如果把stop代码改成这样，应该就没问题了吧？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (void)runThread &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        self.currentRunloop = CFRunLoopGetCurrent();</div><div class="line">        [self addRunloopSource];</div><div class="line">        [self addSocketSource];</div><div class="line">        </div><div class="line">        CFRunLoopRun();</div><div class="line">    &#125;</div><div class="line">    NSLog(@&quot;线程退出&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)stopThread &#123;</div><div class="line">    if (_currentRunloop) &#123;</div><div class="line">	    //保证removeSocketSource的操作只会在这里执行，没有多线程的情况</div><div class="line">        [self removeSocketSource];</div><div class="line">        CFRunLoopStop(_currentRunloop);</div><div class="line">        self.currentRunloop = NULL;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很遗憾，这样写还是不安全的。</p>
<p>原因在于<code>removeSocketSource</code>之后，runloop里source就全部为空了，runloop如果检测到了source为空，就会自动停止runloop循环，销毁线程。</p>
<p>因此如果你在另一个线程调用<code>stopThread</code>，在<code>removeSocketSource</code>之后线程就会随时停止，runloop在调用<code>CFRunLoopStop</code>时可能已经被释放了。</p>
<p>上面的写法出现crash的概率太低，但是稍微改一下就能必现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (void)stopThread &#123;</div><div class="line">    if (_currentRunloop) &#123;</div><div class="line">        [self removeSocketSource];</div><div class="line">        </div><div class="line">        //插入一个耗时操作</div><div class="line">        sleep(2);</div><div class="line">        //必定crash</div><div class="line">        CFRunLoopStop(_currentRunloop);</div><div class="line">        self.currentRunloop = NULL;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种情况下crash的原因其实是没做好内存管理，只要对runloop增加一次retain操作就没问题了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (void)runThread &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">	    //做一次retain操作</div><div class="line">        self.currentRunloop = CFRetain(CFRunLoopGetCurrent());</div><div class="line">        [self addRunloopSource];</div><div class="line">        [self addSocketSource];</div><div class="line">        </div><div class="line">        CFRunLoopRun();</div><div class="line">    &#125;</div><div class="line">    NSLog(@&quot;线程退出&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)stopThread &#123;</div><div class="line">    if (_currentRunloop) &#123;</div><div class="line">        [self removeSocketSource];</div><div class="line">        CFRunLoopStop(_currentRunloop);</div><div class="line">        CFRelease(_currentRunloop);</div><div class="line">        self.currentRunloop = NULL;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在使用runloop source的时候要谨慎，尤其在处理stop的阶段。其他source可能也存在类似的问题。</p>
<p>一个变量有多线程操作的时候，在锁外的操作即使是只读也是不安全的，在读取之前最好再做一次retain操作，防止在读取的过程中被释放。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你还不了解什么是runloop，可以看这里的详解&lt;a href=&quot;http://blog.ibireme.com/2015/05/18/runloop/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;深入理解RunLoop&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;苹果
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS逆向：在任意app上开启malloc stack追踪内存来源</title>
    <link href="http://yoursite.com/2017/05/04/iOS%E9%80%86%E5%90%91%EF%BC%9A%E5%9C%A8%E4%BB%BB%E6%84%8Fapp%E4%B8%8A%E5%BC%80%E5%90%AFmalloc%20stack%E8%BF%BD%E8%B8%AA%E5%86%85%E5%AD%98%E6%9D%A5%E6%BA%90/"/>
    <id>http://yoursite.com/2017/05/04/iOS逆向：在任意app上开启malloc stack追踪内存来源/</id>
    <published>2017-05-04T12:49:00.000Z</published>
    <updated>2017-10-20T08:02:51.370Z</updated>
    
    <content type="html"><![CDATA[<p>lldb有一个内存调试工具malloc stack，开启以后就可以查看某个内存地址的malloc和free记录，追踪对象是在哪里创建的。</p>
<p>这个工具可以打印出对象创建的堆栈，而在逆向时，也经常需要追踪某些方法的调用栈，如果可以随时打印出某个对象的创建记录，也就能直接找到其所在的类和方法，不用再花费大量的时间去打log和动态调试追踪了。</p>
<h2 id="malloc-stack"><a href="#malloc-stack" class="headerlink" title="malloc stack"></a>malloc stack</h2><p>在自己的项目中，要开启malloc stack，需要在<code>Product-&gt;Scheme-&gt;Edit Scheme-&gt;Diagnistic</code>里勾选<code>Malloc Stack</code>选项。</p>
<p>效果如下：</p>
<p>测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (IBAction)create:(id)sender &#123;</div><div class="line">    NSString *testString = [NSString stringWithFormat:@&quot;string created by %@&quot;,self];</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>断点后在lldb中使用<code>lldb.macosx.heap</code>里的<code>malloc_info</code>命令，虽然官网上说是Mac app才能用的命令，但是经测试现在在iOS上也能用了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">(lldb) p/x testString</div><div class="line">(__NSCFString *) $3 = 0x16eac000 @&quot;string created by &lt;ViewController: 0x16e9d7c0&gt;&quot;</div><div class="line">(lldb) command script import lldb.macosx.heap //加载lldb.macosx.heap</div><div class="line">&quot;malloc_info&quot;, &quot;ptr_refs&quot;, &quot;cstr_refs&quot;, &quot;find_variable&quot;, and &quot;objc_refs&quot; commands have been installed, use the &quot;--help&quot; options on these commands for detailed help.</div><div class="line">(lldb) malloc_info -s 0x16eac000</div><div class="line">0x0000000016eac000: malloc(    64) -&gt; 0x16eac000 __NSCFString.NSMutableString.NSString.NSObject.isa</div><div class="line">stack[0]: addr = 0x16eac000, type=malloc, frames:</div><div class="line">     [0] 0x00000000242948ab libsystem_malloc.dylib`malloc_zone_malloc + 123</div><div class="line">     [1] 0x00000000244e3bc1 CoreFoundation`_CFRuntimeCreateInstance + 237</div><div class="line">     [2] 0x00000000245a6ffd CoreFoundation`__CFStringCreateImmutableFunnel3 + 1657</div><div class="line">     [3] 0x00000000244ee0f7 CoreFoundation`CFStringCreateCopy + 359</div><div class="line">     [4] 0x00000000245a725d CoreFoundation`_CFStringCreateWithFormatAndArgumentsAux2 + 89</div><div class="line">     [5] 0x0000000024d17dd3 Foundation`-[NSPlaceholderString initWithFormat:locale:arguments:] + 139</div><div class="line">     [6] 0x0000000024d17cd1 Foundation`+[NSString stringWithFormat:] + 61</div><div class="line">     [7] 0x00000000000d7343 testMallocStack`-[ViewController create:] + 97 at ViewController.m:23:28</div><div class="line">     [8] 0x00000000287a5771 UIKit`-[UIApplication sendAction:to:from:forEvent:] + 81</div><div class="line">     [9] 0x00000000287a5701 UIKit`-[UIControl sendAction:to:forEvent:] + 65</div><div class="line">     [10] 0x000000002878d61f UIKit`-[UIControl _sendActionsForEvents:withEvent:] + 447</div><div class="line">     [11] 0x00000000287a5051 UIKit`-[UIControl touchesEnded:withEvent:] + 617</div><div class="line">     [12] 0x00000000287a4cbf UIKit`-[UIWindow _sendTouchesForEvent:] + 647</div><div class="line">     [13] 0x000000002879d5d7 UIKit`-[UIWindow sendEvent:] + 643</div><div class="line">     [14] 0x000000002876e119 UIKit`-[UIApplication sendEvent:] + 205</div><div class="line">     [15] 0x000000002876c757 UIKit`_UIApplicationHandleEventQueue + 5135</div><div class="line">     [16] 0x0000000024599257 CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 15</div><div class="line">     [17] 0x0000000024598e47 CoreFoundation`__CFRunLoopDoSources0 + 455</div><div class="line">     [18] 0x00000000245971af CoreFoundation`__CFRunLoopRun + 807</div><div class="line">     [19] 0x00000000244e9bb9 CoreFoundation`CFRunLoopRunSpecific + 517</div><div class="line">     [20] 0x00000000244e99ad CoreFoundation`CFRunLoopRunInMode + 109</div><div class="line">     [21] 0x0000000025763af9 GraphicsServices`GSEventRunModal + 161</div><div class="line">     [22] 0x00000000287d5fb5 UIKit`UIApplicationMain + 145</div><div class="line">     [23] 0x00000000000d7587 testMallocStack`main + 107 at main.m:14:9</div><div class="line">     [24] 0x000000002419c873 libdyld.dylib`start + 3</div><div class="line">     [25] 0x000000003a9c0001 libsystem_pthread.dylib`_thread + 1</div></pre></td></tr></table></figure>
<p>这个工具是继承自gdb的<code>malloc_history</code>，不过<code>malloc_history</code>只能用在模拟器上，而<code>malloc_info</code>在模拟器和真机上都可以使用。另外，新版Xcode又增加了一个新的lldb工具<code>memory history</code>，在<code>Product-&gt;Scheme-&gt;Edit Scheme-&gt;Diagnistic</code>里勾选<code>Address Sanitizer</code>即可，效果类似。</p>
<h2 id="使用非官方版的heap-py"><a href="#使用非官方版的heap-py" class="headerlink" title="使用非官方版的heap.py"></a>使用非官方版的heap.py</h2><p>注意，在Xcode8.3以后使用<code>malloc_info</code>会crash，似乎是出bug了，一直没修复。在Xcode8.2上可以正常使用。</p>
<p>所以我们需要替换一下lldb自带的lldb.macosx.heap模块。使用这个非官方的版本：<a href="https://github.com/llvm-mirror/lldb/blob/master/examples/darwin/heap_find/heap.py" target="_blank" rel="external">heap.py</a>。</p>
<p>lldb可以加载自定义的pthon脚本。只需要在lldb中输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">command script import python脚本的地址</div></pre></td></tr></table></figure>
<p>因此把上面的<code>heap.py</code>下载到本地后，输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">command script import /你的路径/lldb/examples/darwin/heap_find/heap.py</div></pre></td></tr></table></figure>
<p>即可。</p>
<h2 id="在任意app上开启malloc-stack"><a href="#在任意app上开启malloc-stack" class="headerlink" title="在任意app上开启malloc stack"></a>在任意app上开启malloc stack</h2><p><code>Address Sanitizer</code>的<code>memory history</code>需要重新编译app，但是<code>malloc stack</code>只需要在app启动前设置环境变量<code>MallocStackLogging</code>和<code>MallocStackLoggingNoCompact</code>即可。开启后会在系统的<code>/tmp</code>目录下生成一个<code>.index</code>文件，这个文件里的内容是依赖于app的运行时环境的，进程退出以后这个文件也就没用处了。</p>
<p>那么，现在的问题就变成了如何给app设置启动环境变量。</p>
<h3 id="方法一：execve"><a href="#方法一：execve" class="headerlink" title="方法一：execve"></a>方法一：execve</h3><p>这是我一开始使用的方法。使用<code>execve</code>函数来运行app的二进制文件。</p>
<p>由于沙盒的限制，需要让app拥有root权限才能使用<code>execve</code>。步骤如下。</p>
<h4 id="1-重签名ipa"><a href="#1-重签名ipa" class="headerlink" title="1.重签名ipa"></a>1.重签名ipa</h4><p>重签名需要逆向的app。因为需要对app内容作出修改。重签名后安装到越狱设备上。</p>
<h4 id="2-移动app到系统app目录下，修改权限"><a href="#2-移动app到系统app目录下，修改权限" class="headerlink" title="2.移动app到系统app目录下，修改权限"></a>2.移动app到系统app目录下，修改权限</h4><p>只有系统目录下的app才有root权限。</p>
<p>假设需要逆向的app是<code>YOUR_APP.app</code>。把app移动到系统app目录下：<code>mv -f /var/containers/Bundle/Application/xxxxxxxxxxxxx/YOUR_APP.app /Applications/YOUR_APP.app</code>。</p>
<p>然后修改文件权限：</p>
<p><code>cd /Applications</code></p>
<p><code>chown -R root:wheel YOUR_APP.app</code></p>
<p><code>chmod 4755 YOUR_APP.app/YOUR_APP</code></p>
<p>移动后，用<code>uicache</code>刷新app图标，用<code>killall SpringBoard</code>重启<code>SpringBoard</code>。</p>
<h4 id="3-使用引导程序启动app"><a href="#3-使用引导程序启动app" class="headerlink" title="3.使用引导程序启动app"></a>3.使用引导程序启动app</h4><p>最终的目的就是使用引导程序用<code>execve</code>启动app，在启动前设置环境变量。</p>
<p>首先重命名原来的二进制文件：<code>mv YOUR_APP.app/YOUR_APP   YOUR_APP.app/YOUR_APP_Orig</code>。</p>
<p>然后制作引导程序，随便创建一个iOS工程，替换main.m里的内容为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        NSString* string = [[NSBundle mainBundle] pathForResource:@&quot;YOUR_APP_Orig&quot; ofType:nil];//YOUR_APP_Orig是所要启动的二进制文件名</div><div class="line">        argv[0] = (char*)[string UTF8String];</div><div class="line">        char *envp[] =</div><div class="line">        &#123;</div><div class="line">            &quot;HOME=/var/root&quot;,</div><div class="line">            &quot;LOGNAME=root&quot;,</div><div class="line">            &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/bin/X11:/usr/games&quot;,</div><div class="line">            &quot;USER=root&quot;,</div><div class="line">            &quot;MallocStackLogging=1&quot;,</div><div class="line">            &quot;MallocStackLoggingNoCompact=1&quot;</div><div class="line">            0</div><div class="line">        &#125;;</div><div class="line">        execve([string UTF8String], argv, envp);</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译后，取出二进制文件，重命名为<code>YOUR_APP</code>，复制到越狱设备的<code>/Application/YOUR_APP.app/</code>目录下。</p>
<p>给引导程序设置执行权限：<code>chmod +x /Application/YOUR_APP.app/YOUR_APP</code>。</p>
<p>最后重启SpringBoard：<code>killall SpringBoard</code>。</p>
<p>这样，每次启动app就都会使用引导程序间接启动app。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>步骤繁琐。</li>
<li>有些app重签名很麻烦。</li>
<li>越狱后的系统分区容量很小，很容易就被占满了，想要测试大一点的app就麻烦了。</li>
<li>无法使用<code>debugserver</code>唤醒app，调试启动过程。因为<code>YOUR_APP</code>和<code>YOUR_APP_Orig</code>是两个进程，第一个在<code>execve</code>执行完就退出了。</li>
<li>把app放到系统目录下有时候会引起crash。</li>
</ul>
<h3 id="方法2：debugserver参数"><a href="#方法2：debugserver参数" class="headerlink" title="方法2：debugserver参数"></a>方法2：debugserver参数</h3><p>方法1实在是太麻烦了，有时候遇上重签名失败的app就更麻烦了。但其实还有另一个更直接的方法。就是使用debugserver的命令。</p>
<p>debugserver是动态调试工具，参考：<a href="http://gslab.qq.com/article-159-1.html" target="_blank" rel="external">IOS平台lldb动态调试介绍</a>。</p>
<p>安装好后，在越狱设备上输入<code>debugserver *:1234 /var/containers/Bundle/Application/589822B6-BFDA-4A3D-A71C-AD0D30BA6077/WeChat.app/WeChat</code>就能唤醒app进行调试。</p>
<p>但是网上的教程都没有提到，其实debugserver还有一个隐藏的参数<code>--env</code>(<code>-env</code>,<code>-e</code>都可以)，就是用来设置进程的环境变量的：</p>
<p><code>debugserver *:1234 /var/containers/Bundle/Application/589822B6-BFDA-4A3D-A71C-AD0D30BA6077/WeChat.app/WeChat -env MallocStackLogging=1 -env MallocStackLoggingNoCompact=1</code></p>
<p>当时我想debugserver会不会有设置环境变量的功能，没想到随便试了个<code>-env</code>就成功了。后来在debugserver的源码里也发现了它的存在：<a href="https://llvm.org/svn/llvm-project/lldb/trunk/tools/debugserver/source/debugserver.cpp" target="_blank" rel="external">debugserver.cpp</a>（搜索<code>g_long_options</code>可以找到<code>env</code>）。</p>
<p>这样，即使app没有重签名，也可以直接调试了。</p>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p><code>debugserver</code>无法启动调试extension app，因为extension app是依赖于宿主app而存在的，不能单独运行。这种情况就只能使用方法1了。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>这里使用一个重签名，并且恢复了符号表的微信进行测试。</p>
<p>比如找到微信查看表情的界面，打印出内存地址为<code>0x108795c20</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;MMEmoticonView: 0x108795c20; frame = (276.25 404.25; 215.5 215.5); autoresize = LM+RM+TM+BM; layer = &lt;CALayer: 0x170828700&gt;&gt;</div></pre></td></tr></table></figure>
<p>第一次使用<code>malloc_info</code>需要在lldb里导入<code>lldb.macosx.heap</code>，这里需要导入非官方版本的<code>heap.py</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(lldb) command script import heap.py的路径</div><div class="line">&quot;malloc_info&quot;, &quot;ptr_refs&quot;, &quot;cstr_refs&quot;, &quot;find_variable&quot;, and &quot;objc_refs&quot; commands have been installed, use the &quot;--help&quot; options on these commands for detailed help.</div></pre></td></tr></table></figure>
<p>使用<code>malloc_info</code>打印创建堆栈：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">(lldb) malloc_info -s 0x108795c20</div><div class="line">0x0000000108795c20: malloc(   480) -&gt; 0x108795c20 MMEmoticonView.UIView.UIResponder.NSObject.isa</div><div class="line">stack[0]: addr = 0x108795c20, type=malloc, frames:</div><div class="line">     [0] 0x000000018374e0ac libsystem_malloc.dylib`calloc + 40</div><div class="line">     [1] 0x000000018318b624 libobjc.A.dylib`class_createInstance + 76</div><div class="line">     [2] 0x0000000183199ae4 libobjc.A.dylib`_objc_rootAlloc + 52</div><div class="line">     [3] 0x00000001026d8fd4 WeChat`-[MMImageBrowseView InitEmoticonView:] + 432</div><div class="line">     [4] 0x000000010245e950 WeChat`-[MMEmotionMsgBrowseViewController initImageViewWithFrame:] + 404</div><div class="line">     [5] 0x000000010245ea74 WeChat`-[MMEmotionMsgBrowseViewController setupImageView] + 156</div><div class="line">     [6] 0x000000010245e024 WeChat`-[MMEmotionMsgBrowseViewController initView] + 224</div><div class="line">     [7] 0x000000010245d76c WeChat`-[MMEmotionMsgBrowseViewController viewDidLoad] + 112</div><div class="line">     [8] 0x000000018a5f7924 UIKit`-[UIViewController loadViewIfRequired] + 1056</div><div class="line">     [9] 0x000000018a60f4b4 UIKit`-[UIViewController __viewWillAppear:] + 132</div><div class="line">     [10] 0x00000001026e05f8 WeChat`-[MMUIViewController beginAppearanceTransition:animated:] + 92</div><div class="line">     [11] 0x000000018a7975b4 UIKit`-[UINavigationController _startCustomTransition:] + 1136</div><div class="line">     [12] 0x000000018a6afe74 UIKit`-[UINavigationController _startDeferredTransitionIfNeeded:] + 676</div><div class="line">     [13] 0x000000018a6afadc UIKit`-[UINavigationController __viewWillLayoutSubviews] + 64</div><div class="line">     [14] 0x000000018a6afa40 UIKit`-[UILayoutContainerView layoutSubviews] + 188</div><div class="line">     [15] 0x000000018a5f4a80 UIKit`-[UIView(CALayerDelegate) layoutSublayersOfLayer:] + 1196</div><div class="line">     [16] 0x0000000187aa29d8 QuartzCore`-[CALayer layoutSublayers] + 148</div><div class="line">     [17] 0x0000000187a974cc QuartzCore`CA::Layer::layout_if_needed(CA::Transaction*) + 292</div><div class="line">     [18] 0x0000000187a9738c QuartzCore`CA::Layer::layout_and_display_if_needed(CA::Transaction*) + 32</div><div class="line">     [19] 0x0000000187a143e0 QuartzCore`CA::Context::commit_transaction(CA::Transaction*) + 252</div><div class="line">     [20] 0x0000000187a3ba68 QuartzCore`CA::Transaction::commit() + 512</div><div class="line">     [21] 0x0000000187a3c488 QuartzCore`CA::Transaction::observer_callback(__CFRunLoopObserver*, unsigned long, void*) + 120</div><div class="line">     [22] 0x00000001846f60c0 CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__ + 32</div><div class="line">     [23] 0x00000001846f3cf0 CoreFoundation`__CFRunLoopDoObservers + 372</div><div class="line">     [24] 0x00000001846f4180 CoreFoundation`__CFRunLoopRun + 1024</div><div class="line">     [25] 0x00000001846222b8 CoreFoundation`CFRunLoopRunSpecific + 444</div><div class="line">     [26] 0x00000001860d6198 GraphicsServices`GSEventRunModal + 180</div><div class="line">     [27] 0x000000018a6627fc UIKit`-[UIApplication _run] + 684</div><div class="line">     [28] 0x000000018a65d534 UIKit`UIApplicationMain + 208</div><div class="line">     [29] 0x00000001000ebea4 WeChat`-[WATemplateMsgMngSwitchCell .cxx_destruct] + 372</div><div class="line">     [30] 0x00000001836055b8 libdyld.dylib`start + 4</div></pre></td></tr></table></figure>
<p>这样就直接找到表情界面所在的类，以及在哪里初始化了。</p>
<p>这样的话，只要能找到一个对象，就能快速定位到其所在模块。比原来打log，打断点一步步回溯高效多了。</p>
<h2 id="恢复符号表"><a href="#恢复符号表" class="headerlink" title="恢复符号表"></a>恢复符号表</h2><p>建议在对app重签名时恢复符号表。恢复符号表后，就能直接在堆栈中看到方法名，免去了计算偏移量然后在hopper里查找的麻烦。</p>
<p>参考：<a href="http://blog.imjun.net/posts/restore-symbol-of-iOS-app/" target="_blank" rel="external">iOS符号表恢复&amp;逆向支付宝</a>, <a href="https://github.com/tobefuturer/restore-symbol" target="_blank" rel="external">restore-symbol</a>。</p>
<h2 id="其他几个调试命令"><a href="#其他几个调试命令" class="headerlink" title="其他几个调试命令"></a>其他几个调试命令</h2><h3 id="ptr-refs"><a href="#ptr-refs" class="headerlink" title="ptr_refs"></a>ptr_refs</h3><p>可以在内存中找出哪些地址引用了某个指针，也就相当于查看某个变量在哪里被引用。</p>
<h3 id="cstr-refs"><a href="#cstr-refs" class="headerlink" title="cstr_refs"></a>cstr_refs</h3><p>在内存中寻找某个C String在哪里被引用。</p>
<h3 id="find-variable"><a href="#find-variable" class="headerlink" title="find_variable"></a>find_variable</h3><p>在当前栈帧上寻找某个局部变量在哪里被引用。</p>
<h3 id="objc-refs"><a href="#objc-refs" class="headerlink" title="objc_refs"></a>objc_refs</h3><p>在内存中寻找某个类的实例。</p>
<h2 id="转到Xcode中调试"><a href="#转到Xcode中调试" class="headerlink" title="转到Xcode中调试"></a>转到Xcode中调试</h2><p>如果想要在Xcode中调试并开启<code>malloc stack</code>，则需要先用<code>debugserver</code>启动app，在终端的lldb里连接上以后，再用<code>process detach</code>断开连接。接下来用Xcode的<code>Attach to Process</code>就可以了，参考：<a href="https://zuikyo.github.io/2017/05/04/iOS逆向：用Xcode直接调试第三方app/" target="_blank" rel="external">iOS逆向：用Xcode直接调试第三方app</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;lldb有一个内存调试工具malloc stack，开启以后就可以查看某个内存地址的malloc和free记录，追踪对象是在哪里创建的。&lt;/p&gt;
&lt;p&gt;这个工具可以打印出对象创建的堆栈，而在逆向时，也经常需要追踪某些方法的调用栈，如果可以随时打印出某个对象的创建记录，也就能
    
    </summary>
    
      <category term="逆向工程" scheme="http://yoursite.com/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS逆向：用Xcode直接调试第三方app</title>
    <link href="http://yoursite.com/2017/05/04/iOS%E9%80%86%E5%90%91%EF%BC%9A%E7%94%A8Xcode%E7%9B%B4%E6%8E%A5%E8%B0%83%E8%AF%95%E7%AC%AC%E4%B8%89%E6%96%B9app/"/>
    <id>http://yoursite.com/2017/05/04/iOS逆向：用Xcode直接调试第三方app/</id>
    <published>2017-05-04T12:48:00.000Z</published>
    <updated>2017-05-05T02:19:48.950Z</updated>
    
    <content type="html"><![CDATA[<p>一般动态调试app时，都是在终端里用lldb直接调试，但是用Xcode的<code>Attach to Process</code>也可以连接到真机上的进程进行调试。但是只能调试用自己的证书签名的app。</p>
<p>在Xcode上调试的优点：</p>
<ul>
<li>有UI界面，查看堆栈更直接，可以用Xcode打断点。</li>
<li>可以使用<code>debug gauges</code>里的Disk和Network等工具。</li>
<li>输入lldb命令时有自动补全。</li>
<li>可以使用Xcode的<code>Debug UI Hierarchy</code>功能，直接查看app的界面布局。</li>
<li>可以使用Xcode的<code>Debug Memory Graph</code>功能，查看当前内存中存在的所有对象，以及对象之间的引用关系。</li>
</ul>
<p>步骤如下。</p>
<h2 id="1-重签名需要逆向的app"><a href="#1-重签名需要逆向的app" class="headerlink" title="1.重签名需要逆向的app"></a>1.重签名需要逆向的app</h2><p>重签名后才能用Xcode attach。而重签名前需要对app进行砸壳。这些步骤就不再重复了。</p>
<p>额外说一句，在砸壳后建议进行一下恢复符号表的操作。恢复符号表后，在调试时就能直接在堆栈中看到方法名，免去了计算偏移量然后在hopper里查找的麻烦。参考：<a href="http://blog.imjun.net/posts/restore-symbol-of-iOS-app/" target="_blank" rel="external">iOS符号表恢复&amp;逆向支付宝</a>, <a href="https://github.com/tobefuturer/restore-symbol" target="_blank" rel="external">restore-symbol</a>。</p>
<h2 id="2-Attach-to-Process"><a href="#2-Attach-to-Process" class="headerlink" title="2.Attach to Process"></a>2.Attach to Process</h2><p>重签名后安装到越狱设备上，启动app，在Xcode中随便打开一个工程，选择越狱设备，就可以在<code>Debug-&gt;Attach to Process</code>中找到正在运行的进程名和进程id，点击后就会开始连接。大概过1分钟就会连接上。</p>
<h2 id="3-查看UI"><a href="#3-查看UI" class="headerlink" title="3.查看UI"></a>3.查看UI</h2><p>连接上后，就可以点击使用Xcode的<code>Debug UI Hierarchy</code>来查看界面布局：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1865432-b3652b738ff07228.jpg" alt="UI Hierarchy"></p>
<p>注意，<code>Debug UI Hierarchy</code>对Xcode版本似乎有要求，在调试重签名app时，Xcode8.3.2可以，而Xcode8.2就没有这个功能按钮。</p>
<h2 id="4-查看内存信息"><a href="#4-查看内存信息" class="headerlink" title="4.查看内存信息"></a>4.查看内存信息</h2><p>点击<code>Debug Memory Graph</code>按钮，可以查看当前内存中存在的数据。打印地址，查看引用关系，可以配合<code>malloc stack</code>进行追踪。如果打开了<code>malloc stack</code>，就可以直接在右边显示这个对象的创建堆栈。参考：<a href="https://zuikyo.github.io/2017/05/04/iOS逆向：在任意app上开启malloc%20stack追踪内存来源/" target="_blank" rel="external">iOS逆向：在任意app上开启malloc%20stack追踪内存来源</a>。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1865432-d599a5233b28e245.jpg" alt="Memory Graph"></p>
<h2 id="5-查看正在使用的文件"><a href="#5-查看正在使用的文件" class="headerlink" title="5.查看正在使用的文件"></a>5.查看正在使用的文件</h2><p><code>debug gauges</code>中的Disk工具可以查看app当前打开的文件。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1865432-80d24111380e2e44.jpg" alt="Open Files"></p>
<h2 id="5-instrument调试"><a href="#5-instrument调试" class="headerlink" title="5.instrument调试"></a>5.instrument调试</h2><p>类似的，也可以用instrument调试重签名后的app，不过并不是所有工具都可以使用，对逆向的帮助不大。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般动态调试app时，都是在终端里用lldb直接调试，但是用Xcode的&lt;code&gt;Attach to Process&lt;/code&gt;也可以连接到真机上的进程进行调试。但是只能调试用自己的证书签名的app。&lt;/p&gt;
&lt;p&gt;在Xcode上调试的优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
    
    </summary>
    
      <category term="逆向工程" scheme="http://yoursite.com/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>私有API-修复iOS10不弹出&quot;是否允许xxx访问数据&quot;导致app无法联网的bug</title>
    <link href="http://yoursite.com/2017/02/05/%E7%A7%81%E6%9C%89API-%E4%BF%AE%E5%A4%8DiOS%2010%E4%B8%8D%E5%BC%B9%E5%87%BA%E6%98%AF%E5%90%A6%E5%85%81%E8%AE%B8xxx%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%87%B4app%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91%E7%9A%84bug/"/>
    <id>http://yoursite.com/2017/02/05/私有API-修复iOS 10不弹出是否允许xxx访问数据导致app无法联网的bug/</id>
    <published>2017-02-05T15:38:00.000Z</published>
    <updated>2017-05-03T08:32:26.330Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>iOS 10有一个系统bug：app在第一次安装时，第一次联网操作会弹出一个授权框，提示”是否允许xxx访问数据？”。而有时候系统并不会弹出授权框，导致app无法联网。</p>
<p>详细情况见：</p>
<p><a href="http://www.jianshu.com/p/6cbde1b8b922" target="_blank" rel="external">iOS 10 的坑：新机首次安装 app，请求网络权限“是否允许使用数据”</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/22738261" target="_blank" rel="external">iOS 10 不提示「是否允许应用访问数据」，导致应用无法使用的解决方案</a></p>
<p>关键点总结：</p>
<ul>
<li>只有iOS 10以上、国行机型、有蜂窝网络功能的设备存在这个授权问题，WiFi版的iPad没有这个问题；</li>
<li>由于授权框是在有网络操作时才弹出的，这就导致app第一次网络访问必定失败；</li>
<li>当出现不弹出授权框的bug时，去设置里更改任意app的蜂窝网络权限，或者打开无线局域网助理，让系统更新一下蜂窝网络相关的数据，可以解决这个bug。</li>
</ul>
<p>这个系统bug出现时，对用户来说是很麻烦的，app也需要提供详细的提示语来应对这种情况，十分不优雅。</p>
<h1 id="修复方法"><a href="#修复方法" class="headerlink" title="修复方法"></a>修复方法</h1><p>春节有点空，找到了几个相关的私有API来修复这个bug。</p>
<h2 id="弹出授权框"><a href="#弹出授权框" class="headerlink" title="弹出授权框"></a>弹出授权框</h2><p>首先找到的是一个能直接弹出授权框的API。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//Image: /System/Library/PrivateFrameworks/FTServices.framework/FTServices</div><div class="line"></div><div class="line">@interface FTNetworkSupport : NSObject</div><div class="line">+ (id)sharedInstance;</div><div class="line">- (bool)dataActiveAndReachable;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>头文件参考：<a href="https://github.com/JaviSoto/iOS10-Runtime-Headers/blob/master/PrivateFrameworks/FTServices.framework/FTNetworkSupport.h" target="_blank" rel="external">FTNetworkSupport.h</a></p>
<p>当app之前没有请求过网络权限时，调用<code>dataActiveAndReachable</code>会弹出”是否允许xxx访问数据？”的授权框，如果网络权限已经确定，则不会弹出。</p>
<h3 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h3><p>由于<code>FTNetworkSupport</code>是在<code>PrivateFrameworks</code>目录下，app并没有加载这个库，所以要使用里面的类前，需要用<code>dlopen</code>加载<code>FTServices.framework</code>,简单示意如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#import &lt;dlfcn.h&gt;</div><div class="line"></div><div class="line">//加载FTServices.framework</div><div class="line">void * FTServicesHandle = dlopen(&quot;/System/Library/PrivateFrameworks/FTServices.framework/FTServices&quot;, RTLD_LAZY);</div><div class="line">Class NetworkSupport = NSClassFromString(@&quot;FTNetworkSupport&quot;);</div><div class="line">id networkSupport = [NetworkSupport performSelector:NSSelectorFromString(@&quot;sharedInstance&quot;)];</div><div class="line">[networkSupport performSelector:NSSelectorFromString(@&quot;dataActiveAndReachable&quot;)];</div><div class="line">//卸载FTServices.framework</div><div class="line">dlclose(FTServicesHandle);</div></pre></td></tr></table></figure>
<p>这个API能解决网络权限导致第一个联网操作失败的问题，但是它还是存在有时候不会弹出授权框的bug。</p>
<h2 id="让系统更新蜂窝网络权限数据"><a href="#让系统更新蜂窝网络权限数据" class="headerlink" title="让系统更新蜂窝网络权限数据"></a>让系统更新蜂窝网络权限数据</h2><p>既然更改任意app的蜂窝网络权限后，能让app弹出授权框，那么只要找到一个方法，能让系统更新一下网络权限相关的数据就可以了。</p>
<p>用<code>hopper</code>反编译一下系统的设置app用到的库<code>PreferencesUI.framework</code>，找到了里面修改app网络权限的API。用到的是<code>CoreTelephony.framework</code>里的两个私有C函数：</p>
<p><code>CTServerConnection* _CTServerConnectionCreateOnTargetQueue(CFAllocatorRef, NSString *, dispatch_queue_t, void*/*一个block类型的参数*/)</code></p>
<p><code>void _CTServerConnectionSetCellularUsagePolicy(CTServerConnection *, NSString *, NSDictionary *)</code></p>
<p>大部分时间都花在测试这两个函数上了。几个月前我也研究过这两个函数尝试修复这个bug，但是那时候发现没什么作用，就不了了之了。</p>
<h3 id="调用方式-1"><a href="#调用方式-1" class="headerlink" title="调用方式"></a>调用方式</h3><p>要调用私有C函数，需要用<code>dlsym</code>，简单示意如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">void *CoreTelephonyHandle = dlopen(&quot;/System/Library/Frameworks/CoreTelephony.framework/CoreTelephony&quot;, RTLD_LAZY);</div><div class="line"></div><div class="line">//用函数指针来调用私有C函数，用符号名从库里寻找函数地址</div><div class="line">CFTypeRef (*connectionCreateOnTargetQueue)(CFAllocatorRef, NSString *, dispatch_queue_t, void*) = dlsym(CoreTelephonyHandle, &quot;_CTServerConnectionCreateOnTargetQueue&quot;);</div><div class="line">int (*changeCellularPolicy)(CFTypeRef, NSString *, NSDictionary *) = dlsym(CoreTelephonyHandle, &quot;_CTServerConnectionSetCellularUsagePolicy&quot;);</div><div class="line"></div><div class="line">//使用设置app的bundle id进行伪装</div><div class="line">CFTypeRef connection = connectionCreateOnTargetQueue(kCFAllocatorDefault,@&quot;com.apple.Preferences&quot;,dispatch_get_main_queue(),NULL);</div><div class="line">//请求修改本app的网络权限为allowed，不会真的修改，只能触发系统更新一下相关的数据</div><div class="line">changeCellularPolicy(connection, @&quot;需要授权的app的bundle id&quot;, @&#123;@&quot;kCTCellularUsagePolicyDataAllowed&quot;:@YES&#125;);</div><div class="line"></div><div class="line">dlclose(CoreTelephonyHandle);</div></pre></td></tr></table></figure>
<p>注意，在声明connectionCreateOnTargetQueue和changeCellularPolicy函数指针时，参数类型要严格对应，如果类型错误，可能会导致系统对参数执行错误的内存管理，出现crash。<code>CTServerConnection</code>是私有的，是<code>CFTypeRef</code>的子类，所以这里可以用<code>CFTypeRef</code>来代替。</p>
<h3 id="出现了玄学"><a href="#出现了玄学" class="headerlink" title="出现了玄学"></a>出现了玄学</h3><p><code>_CTServerConnectionSetCellularUsagePolicy</code>函数的第二个参数是需要修改的app的bundle id。在测试时，发现传入这个参数时，对象必须是用字面量语法创建的<code>NSString</code>，例如<code>@&quot;com.who.testDemo&quot;</code>，当传入<code>[NSBundle mainBundle].bundleIdentifier</code>这种动态生成的<code>NSString</code>时，仍然会出现不弹出授权框的bug，也就是并没有修复成功。连续测试5-10次就能重现。</p>
<p>不过，用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSMutableString *bundleIdentifier = [NSMutableString stringWithString:@&quot;com.who&quot;];</div><div class="line">[bundleIdentifier appendString:@&quot;.testDemo&quot;];</div></pre></td></tr></table></figure>
<p>这样的字符串也没问题。相同点是最终都是来自字面量语法创建的<code>NSString</code>。</p>
<p>这个玄学问题目前还没有找到原因。</p>
<p>研究了一下字面量创建出的<code>NSString</code>，的确是有些特殊的。参考：<a href="http://bou.io/ConstantStringsInObjC.html" target="_blank" rel="external">Constant Strings in Objective-C</a>。它是一个<code>__NSCFConstantString</code>类型的字符串，在app的整个生命周期内，这个对象的内存都不会被释放。难道iOS的XPC对使用到的字符串还有要求？</p>
<p>时间有限，这个问题以后再研究吧。</p>
<h2 id="用控制台跟踪进程间通信"><a href="#用控制台跟踪进程间通信" class="headerlink" title="用控制台跟踪进程间通信"></a><a name="debug-trace"></a>用控制台跟踪进程间通信</h2><p>这几个私有API都用了进程间通信，要进行调试跟踪有点麻烦。</p>
<p>可以使用Mac上的控制台查看设备的实时log，寻找通信行为。打开控制台app，在左侧选择连接到Mac的iOS设备，就可以看到设备log了。</p>
<p>下面是调用了<code>_CTServerConnectionSetCellularUsagePolicy</code>之后的log，传入bundle id时用的是字面量创建的字符串：<br><img src="http://upload-images.jianshu.io/upload_images/1865432-e5eec32d03c2fa7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用字面量字符串传入bundle id"><br>高亮的那行是测试demo打的log，可以认为就是在这里调用了<code>_CTServerConnectionSetCellularUsagePolicy</code>，<br>可以看到，调用之后系统更新了本app的权限状态。<code>CommCenter</code>就是这几个私有API通信的对应进程，用于管理设备的网络。参考<a href="https://www.theiphonewiki.com/wiki//System/Library/Frameworks/CoreTelephony.Framework/Support/CommCenter" target="_blank" rel="external">CommCenter - The iPhone Wiki</a>。</p>
<p>下面是用<code>[NSBundle mainBundle].bundleIdentifier</code>传入<code>_CTServerConnectionSetCellularUsagePolicy</code>的第二个参数时的log：<br><img src="http://upload-images.jianshu.io/upload_images/1865432-87dfca01425cbad0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用动态创建的字符串传入bundle id"><br>没有看到系统更新app权限的相关log，进程间通信可能失败了。因此可以确定，使用<code>_CTServerConnectionSetCellularUsagePolicy</code>时必须传入字面量语法创建的字符串。</p>
<h1 id="检查网络权限情况"><a href="#检查网络权限情况" class="headerlink" title="检查网络权限情况"></a>检查网络权限情况</h1><p>由于<code>dataActiveAndReachable</code>里面有异步操作，所以不能立即用<code>dlclose</code>卸载<code>FTServices.framework</code>。解决方法是监听到蜂窝权限开启时再卸载。</p>
<p><code>CoreTelephony</code>里的<code>CTCellularData</code>可以用来监测app的蜂窝网络权限，并且这不是个私有API。你也可以用它来帮助用户检测蜂窝权限是否被关闭，并给出提示，防止出现用户关了网络权限导致app无法联网的情况。</p>
<p><code>CTCellularData</code>的头文件如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSUInteger, CTCellularDataRestrictedState) &#123;</div><div class="line">	kCTCellularDataRestrictedStateUnknown,//权限未知</div><div class="line">	kCTCellularDataRestricted,//蜂窝权限被关闭，有 网络权限完全关闭 or 只有WiFi权限 两种情况</div><div class="line">	kCTCellularDataNotRestricted//蜂窝权限开启</div><div class="line">&#125;;</div><div class="line"></div><div class="line">@interface CTCellularData : NSObject</div><div class="line">///权限更改时的回调</div><div class="line">@property (copy, nullable) CellularDataRestrictionDidUpdateNotifier cellularDataRestrictionDidUpdateNotifier;</div><div class="line">///当前的蜂窝权限</div><div class="line">@property (nonatomic, readonly) CTCellularDataRestrictedState restrictedState;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>使用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#import &lt;CoreTelephony/CTCellularData.h&gt;</div><div class="line"></div><div class="line">CTCellularData *cellularDataHandle = [[CTCellularData alloc] init];</div><div class="line">cellularDataHandle.cellularDataRestrictionDidUpdateNotifier = ^(CTCellularDataRestrictedState state) &#123;</div><div class="line">        //蜂窝权限更改时的回调</div><div class="line">    &#125;;</div></pre></td></tr></table></figure>
<p>使用时需要注意的关键点：</p>
<ul>
<li><code>CTCellularData</code>只能检测蜂窝权限，不能检测WiFi权限。</li>
<li>一个<code>CTCellularData</code>实例新建时，<code>restrictedState</code>是<code>kCTCellularDataRestrictedStateUnknown</code>，之后在<code>cellularDataRestrictionDidUpdateNotifier</code>里会有一次回调，此时才能获取到正确的权限状态。</li>
<li>当用户在设置里更改了app的权限时，<code>cellularDataRestrictionDidUpdateNotifier</code>会收到回调，如果要停止监听，必须将<code>cellularDataRestrictionDidUpdateNotifier</code>设置为<code>nil</code>。</li>
<li>赋值给<code>cellularDataRestrictionDidUpdateNotifier</code>的block并不会自动释放，即便你给一个局部变量的<code>CTCellularData</code>实例设置监听，当权限更改时，还是会收到回调，所以记得将block置<code>nil</code>。</li>
</ul>
<h1 id="检测国行机型和是否有蜂窝功能"><a href="#检测国行机型和是否有蜂窝功能" class="headerlink" title="检测国行机型和是否有蜂窝功能"></a>检测国行机型和是否有蜂窝功能</h1><p>非国行机型，以及没有蜂窝功能的设备是不需要进行修复的。因此也要寻找相关的私有API进行检测。</p>
<p>用到的私有API如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//Image: /System/Library/PrivateFrameworks/AppleAccount.framework/AppleAccount</div><div class="line"></div><div class="line">@interface AADeviceInfo : NSObject</div><div class="line">///是否有蜂窝功能</div><div class="line">- (bool)hasCellularCapability;</div><div class="line">///设备的区域代码，例如国行机就是CH</div><div class="line">- (id)regionCode;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>头文件参考：<a href="https://github.com/JaviSoto/iOS10-Runtime-Headers/blob/master/PrivateFrameworks/AppleAccount.framework/AADeviceInfo.h" target="_blank" rel="external">AADeviceInfo.h</a></p>
<p>使用方式和<code>FTServices.framework</code>类似，不再重复。</p>
<h1 id="测试修复是否成功的方法"><a href="#测试修复是否成功的方法" class="headerlink" title="测试修复是否成功的方法"></a>测试修复是否成功的方法</h1><p>我的测试方式是每次运行都修改项目的<code>bundle identifier</code>和<code>display name</code>，让系统每次都把它当做一个新app，使用<code>Release</code>模式，测试是否每次都能够弹出授权框。由于需要不断修改<code>bundle identifier</code>，写了个脚本在每次build时自动运行，会自动累加几个地方的<code>bundle identifier</code>后面的数字。demo里已经附带了这个脚本。</p>
<p>你也可以测试一下不执行修复时，进行联网操作是否会弹出授权框。我的测试结果是大约运行5-10次时，就会出现不弹出授权框的bug。需要把项目改为<code>Release</code>模式才能出现，<code>Debug</code>模式下不会出bug。</p>
<p>注意，由于build后自动累加的关系，<code>ZIKCellularAuthorization.h</code>里的<code>AppBundleIdentifier</code>是下一次app运行时的值。如果你觉得这个脚本把你搞晕了，可以在<code>Build Phases/Run Script</code>里关掉，在<code>sh ${PROJECT_DIR}/IncreaseBundleId.sh</code>前面加个<code>#</code>注释掉就行了。</p>
<p>没有测试覆盖安装同一个<code>bundle identifier</code>的app，或者更新了版本号的app是否也会出现这个bug，现在是认为只有第一次安装时才会出现bug。</p>
<h1 id="工具代码和Demo"><a href="#工具代码和Demo" class="headerlink" title="工具代码和Demo"></a>工具代码和Demo</h1><p>地址在<a href="https://github.com/Zuikyo/ZIKCellularAuthorization" target="_blank" rel="external">ZIKCellularAuthorization</a>，用到的私有API已经经过混淆。测试前记得先把<code>Build Configuration</code>改为<code>Release</code>模式。有帮助请点个Star~</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.jianshu.com/p/6cbde1b8b922" target="_blank" rel="external">iOS 10 的坑：新机首次安装 app，请求网络权限“是否允许使用数据”</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/22738261" target="_blank" rel="external">iOS 10 不提示「是否允许应用访问数据」，导致应用无法使用的解决方案</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;iOS 10有一个系统bug：app在第一次安装时，第一次联网操作会弹出一个授权框，提示”是否允许xxx访问数据？”。而有时
    
    </summary>
    
      <category term="私有API" scheme="http://yoursite.com/categories/%E7%A7%81%E6%9C%89API/"/>
    
      <category term="bug修复" scheme="http://yoursite.com/categories/%E7%A7%81%E6%9C%89API/bug%E4%BF%AE%E5%A4%8D/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS Crash分析必备：符号化系统库方法</title>
    <link href="http://yoursite.com/2016/12/18/iOS%20Crash%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%BF%85%E5%A4%87%EF%BC%9A%E7%AC%A6%E5%8F%B7%E5%8C%96%E7%B3%BB%E7%BB%9F%E5%BA%93%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2016/12/18/iOS Crash日志分析必备：符号化系统库方法/</id>
    <published>2016-12-17T20:52:00.000Z</published>
    <updated>2017-05-03T08:47:03.780Z</updated>
    
    <content type="html"><![CDATA[<p>如果你有过分析iOS崩溃日志的经验，一定经常看到日志里出现很多<code>&lt;redacted&gt;</code>的字段。这篇文章就是帮助开发者将这些字段符号化为对应的系统库方法名。</p>
<p>如果你已经掌握了这方面的知识，就直接去下面的<a href="#wang-pan">网盘下载地址</a>目录，下载我整理好的系统库符号文件吧。</p>
<h2 id="符号化的作用"><a href="#符号化的作用" class="headerlink" title="符号化的作用"></a>符号化的作用</h2><p>当获取到app的crash日志时，第一步就是将其符号化。作用是把日志堆栈中的方法调用显示出来，对于来自app内部的方法，还能直接给出方法对应.m文件的所在行。</p>
<p>符号化前（这里项目的<code>Build Settings</code>里的<code>Strip Style</code>设为了<code>Debugging Symbols</code>，所以这里能直接看到<code>MyApp</code>的方法名。更多和symbol相关的设置，请看<a href="http://www.jianshu.com/p/11710e7ab661" target="_blank" rel="external">这里</a>）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Thread 7:</div><div class="line">0   libsystem_kernel.dylib          0x000000018efb416c 0x18efb3000 + 4460 (mach_msg_trap + 8)</div><div class="line">1   libsystem_kernel.dylib          0x000000018efb3fdc 0x18efb3000 + 4060 (mach_msg + 72)</div><div class="line">2   MyApp                           0x000000010091e558 0x1000bc000 + 8791384 (ksmachexc_i_handleExceptions + 148)</div><div class="line">3   libsystem_pthread.dylib         0x000000018f097860 0x18f094000 + 14432 (&lt;redacted&gt; + 240)</div><div class="line">4   libsystem_pthread.dylib         0x000000018f097770 0x18f094000 + 14192 (_pthread_start + 284)</div></pre></td></tr></table></figure>
<p>符号化后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Thread 7:</div><div class="line">0   libsystem_kernel.dylib          0x000000018efb416c mach_msg_trap + 8</div><div class="line">1   libsystem_kernel.dylib          0x000000018efb3fdc mach_msg + 72</div><div class="line">2   MyApp                           0x000000010091e558 ksmachexc_i_handleExceptions (KSCrashSentry_MachException.c:233)</div><div class="line">3   libsystem_pthread.dylib         0x000000018f097860 _pthread_body + 240</div><div class="line">4   libsystem_pthread.dylib         0x000000018f097770 _pthread_body + 0</div></pre></td></tr></table></figure>
<p>可以发现，frame 3里<code>libsystem_pthread.dylib</code>的<code>&lt;redacted&gt;</code>变成了<code>_pthread_body</code>，frame 2里<code>MyApp</code>的<code>ksmachexc_i_handleExceptions</code>变成了更为完整的<code>ksmachexc_i_handleExceptions (KSCrashSentry_MachException.c:233)</code>，直接给出了方法及其所在文件和行数。</p>
<p>详细的符号化方法，请参考<a href="http://wufawei.com/2014/03/symbolicating-ios-crash-logs/" target="_blank" rel="external">符号化iOS Crash文件的3种方法</a>。这里就不重复了。</p>
<p>需要注意的是，很多时候，crash日志里并不会有MyApp的调用，而全都是系统库的调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Thread 0 name:  Dispatch queue: com.apple.main-thread</div><div class="line">Thread 0 Crashed:</div><div class="line">0   libobjc.A.dylib                 0x000000018b816f30 0x18b7fc000 + 110384 (objc_msgSend + 16)</div><div class="line">1   UIKit                           0x0000000192e0a79c 0x192c05000 + 2119580 (&lt;redacted&gt; + 72)</div><div class="line">2   UIKit                           0x0000000192c4db48 0x192c05000 + 297800 (&lt;redacted&gt; + 312)</div><div class="line">3   UIKit                           0x0000000192c4d988 0x192c05000 + 297352 (&lt;redacted&gt; + 160)</div><div class="line">4   QuartzCore                      0x00000001900d6404 0x18ffc5000 + 1119236 (&lt;redacted&gt; + 260)</div><div class="line">5   libdispatch.dylib               0x000000018bc551c0 0x18bc54000 + 4544 (&lt;redacted&gt; + 16)</div><div class="line">6   libdispatch.dylib               0x000000018bc59d6c 0x18bc54000 + 23916 (_dispatch_main_queue_callback_4CF + 1000)</div><div class="line">7   CoreFoundation                  0x000000018cd79f2c 0x18cc9d000 + 905004 (&lt;redacted&gt; + 12)</div><div class="line">8   CoreFoundation                  0x000000018cd77b18 0x18cc9d000 + 895768 (&lt;redacted&gt; + 1660)</div><div class="line">9   CoreFoundation                  0x000000018cca6048 0x18cc9d000 + 36936 (CFRunLoopRunSpecific + 444)</div><div class="line">10  GraphicsServices                0x000000018e729198 0x18e71d000 + 49560 (GSEventRunModal + 180)</div><div class="line">11  UIKit                           0x0000000192c80628 0x192c05000 + 505384 (&lt;redacted&gt; + 684)</div><div class="line">12  UIKit                           0x0000000192c7b360 0x192c05000 + 484192 (UIApplicationMain + 208)</div><div class="line">13  MyApp                           0x0000000100016e54 0x100004000 + 77396 (_mh_execute_header + 77396)</div><div class="line">14  libdyld.dylib                   0x000000018bc885b8 0x18bc84000 + 17848 (&lt;redacted&gt; + 4)</div></pre></td></tr></table></figure>
<p>这时候就必须符号化系统库了。符号化后的日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Thread 0 name:  Dispatch queue: com.apple.main-thread</div><div class="line">Thread 0 Crashed:</div><div class="line">0   libobjc.A.dylib                 0x000000018b816f30 objc_msgSend + 16</div><div class="line">1   UIKit                           0x0000000192e0a79c -[UISearchDisplayController _sendDelegateDidBeginDidEndSearch] + 72</div><div class="line">2   UIKit                           0x0000000192c4db48 -[UIViewAnimationState sendDelegateAnimationDidStop:finished:] + 312</div><div class="line">3   UIKit                           0x0000000192c4d988 -[UIViewAnimationState animationDidStop:finished:] + 160</div><div class="line">4   QuartzCore                      0x00000001900d6404 CA::Layer::run_animation_callbacks(void*) + 260</div><div class="line">5   libdispatch.dylib               0x000000018bc551c0 _dispatch_client_callout + 16</div><div class="line">6   libdispatch.dylib               0x000000018bc59d6c _dispatch_main_queue_callback_4CF + 1000</div><div class="line">7   CoreFoundation                  0x000000018cd79f2c __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__ + 12</div><div class="line">8   CoreFoundation                  0x000000018cd77b18 __CFRunLoopRun + 1660</div><div class="line">9   CoreFoundation                  0x000000018cca6048 CFRunLoopRunSpecific + 444</div><div class="line">10  GraphicsServices                0x000000018e729198 GSEventRunModal + 180</div><div class="line">11  UIKit                           0x0000000192c80628 -[UIApplication _run] + 684</div><div class="line">12  UIKit                           0x0000000192c7b360 UIApplicationMain + 208</div><div class="line">13  MyApp                           0x0000000100016e54 main (main.m:15)</div><div class="line">14  libdyld.dylib                   0x000000018bc885b8 start + 4</div></pre></td></tr></table></figure>
<p>可以看出是<code>UISearchController</code>的<code>delegate</code>导致的问题，检查一下就发现<code>UISearchDisplayController</code>的<code>delegate</code>是<code>assign</code>的，是由于点击搜索条的同时pop了界面导致的crash。</p>
<p>从这里可以发现，符号化系统库是很有必要的。</p>
<p>##如何符号化系统库</p>
<p>符号化自己app的方法名，需要编译ipa时生成的dySYM文件。而要将系统库的<code>&lt;redacted&gt;</code>符号化为完整的方法名，也需要系统库的符号文件。</p>
<h3 id="1-匹配对应的符号文件版本"><a href="#1-匹配对应的符号文件版本" class="headerlink" title="1. 匹配对应的符号文件版本"></a>1. 匹配对应的符号文件版本</h3><p>系统库符号文件不是通用的，而是对应crash所在设备的系统版本和CPU型号的。</p>
<p>crash日志中有这样两个信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Code Type:       ARM-64</div><div class="line">OS Version:      iOS 10.2 (14C82)</div></pre></td></tr></table></figure>
<p><code>Code Type</code>表示此设备的CPU为<code>armv7</code>、<code>armv7s</code>还是<code>arm64</code>。</p>
<p><code>OS Version</code>表示此设备的系统版本号，括号中的字符串代表了此系统的build号。可以在这里查找build号：<a href="https://en.wikipedia.org/wiki/IOS_SDK" target="_blank" rel="external">iOS SDK</a>，<a href="https://en.wikipedia.org/wiki/IOS_version_history#iOS_10" target="_blank" rel="external">iOS version history</a>。</p>
<h3 id="2-将对应版本的符号文件放到指定目录"><a href="#2-将对应版本的符号文件放到指定目录" class="headerlink" title="2. 将对应版本的符号文件放到指定目录"></a>2. 将对应版本的符号文件放到指定目录</h3><p>这时候，把获取到的对应版本的符号文件放到Mac的<code>~/Library/Developer/Xcode/iOS DeviceSupport</code>目录下，再使用<a href="http://wufawei.com/2014/03/symbolicating-ios-crash-logs/" target="_blank" rel="external">符号化iOS Crash文件的3种方法</a>里提到的Xcode自带的符号化工具<code>symbolicatecrash</code>进行符号化。这个工具会自动搜索系统库符号文件。</p>
<h2 id="获取系统符号文件的4个方法"><a href="#获取系统符号文件的4个方法" class="headerlink" title="获取系统符号文件的4个方法"></a>获取系统符号文件的4个方法</h2><h3 id="从真机上获取"><a href="#从真机上获取" class="headerlink" title="从真机上获取"></a>从真机上获取</h3><p>大部分系统库符号文件只能从真机上获取，苹果也没有提供下载。<br>当你用Xcode第一次连接某台设备进行真机调试时，会看到Xcode显示<code>Processing symbol files</code>，这时候就是在拷贝真机上的符号文件到Mac系统的<code>/Users/xxx/Library/Developer/Xcode/iOS DeviceSupport</code>目录下。</p>
<p>目录下的<code>10.2(14C82)</code>这样的文件夹就是对应的符号文件，通常都有1-3GB的大小，很占用空间，动不动就累积成3、40GB。很多讲清理Mac垃圾文件的教程都会说要删除这个目录下的文件，真是坑爹。正确做法是做成压缩包保存到外部硬盘里，需要符号化的时候再重新解压到此目录。</p>
<h3 id="寻找苹果官方的下载地址"><a href="#寻找苹果官方的下载地址" class="headerlink" title="寻找苹果官方的下载地址"></a>寻找苹果官方的下载地址</h3><p>之前watch的调试出现bug时，有人找出过几个watch的符号文件下载地址。见<a href="https://forums.developer.apple.com/thread/3380" target="_blank" rel="external">No symbols for paired Apple Watch</a>。<br>但是我尝试按照对应的命名格式，并没有找到iOS符号文件的下载地址。</p>
<h3 id="从已解密的固件中提取符号文件"><a href="#从已解密的固件中提取符号文件" class="headerlink" title="从已解密的固件中提取符号文件"></a>从已解密的固件中提取符号文件</h3><p>某些已经被破解的固件可以直接提取系统文件，但是未破解的固件（较新的固件和<code>arm64</code>的固件），无法用这种方式获取。</p>
<p>固件解密步骤：</p>
<p>1.下载对应版本的.ipsw固件，直接解压，解压后里面有几个<code>.dmg</code>格式的镜像文件，最大的<code>.dmg</code>文件就是系统镜像。<br>2.从<a href="https://www.theiphonewiki.com/wiki/Firmware_Keys" target="_blank" rel="external">Firmware_Keys</a>找到对应固件的解密key（页面上<code>Root Filesystem</code>字段的key）。<br>3.用一个<code>dmg</code>工具进行解密，<a href="http://modmyi.com/attachments/forums/general-verizon-sprint-cdma-iphone-chat/643832d1372672304-cant-decrypt-ios-7-beta-help-dmg.zip" target="_blank" rel="external">下载地址</a>。使用方式：<code>cd</code>到解压后的ipsw文件夹，执行<code>./dmg extract xxx-xxxx-xxx.dmg dec.dmg -k &lt;key&gt;</code>。<code>extract</code>后面跟两个参数，分别是系统镜像dmg的名字和解密后的文件名，-k 后面填写第2步获取到的key，如果key不对，解密会失败。<br>4.等待。最终会生成一个<code>dec.dmg</code>文件，双击打开即可加载系统镜像。</p>
<p>提取符号文件方法：<br>参考<a href="http://crash.163.com/#news/!newsId=31" target="_blank" rel="external">聊聊从iOS固件提取系统库符号</a>中的<code>二、系统库符号提取</code>部分。</p>
<h3 id="下载旧版本Xcode，提取SDK"><a href="#下载旧版本Xcode，提取SDK" class="headerlink" title="下载旧版本Xcode，提取SDK"></a>下载旧版本Xcode，提取SDK</h3><p>旧版本的Xcode里包含了对应的iPhoneSDK，可以从中获得符号文件。<br>路径是<code>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/</code>。里面的<code>System/Library</code>里就可以看到framework，而且同时包含了<code>armv7</code>,<code>armv7s</code>,<code>arm64</code>3个平台的版本。</p>
<p><code>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/version.plist</code>可以查看是哪个版本。把<code>iPhoneOS.sdk</code>文件夹的名字改成对应的<code>CFBundleVersion (ProductBuildVersion)</code>格式，然后在里面加一层<code>Symbols</code>子文件夹，把<code>System</code>,<code>Library</code>,<code>usr</code>都放进<code>Symbols</code>里，就可以和其他符号文件一样使用了。</p>
<p>但是当iOS版本只包含了bug修复，而没有改变API，Xcode就不会有附带对应的SDK，还是需要从真机上获取。而且从Xcode7开始，苹果用<code>tbd</code>文件代替了真机符号文件，所以这个方法也失效了。<br>参考：<a href="http://stackoverflow.com/questions/14941773/xcode-software-image-for-user-ios-in-order-to-symbolicate-ios-calls" target="_blank" rel="external">Xcode software image for user iOS in order to symbolicate iOS calls</a>, <a href="http://stackoverflow.com/a/28408052/6380485" target="_blank" rel="external">Missing iOS symbols at “~/Library/Developer/Xcode/iOS DeviceSupport”</a>。</p>
<h2 id="获取符号文件的难题"><a href="#获取符号文件的难题" class="headerlink" title="获取符号文件的难题"></a>获取符号文件的难题</h2><p>这个时候，游戏就开始了：</p>
<ul>
<li>很多时候crash日志只给出了系统的调用栈，不能直接定位到自己app的代码，因此需要符号化系统库。</li>
<li>用户的crash来自各种系统版本，需要对应版本的系统符号文件才能符号化。</li>
<li>系统库符号文件只能从真机上获取，苹果没有提供下载。</li>
<li>从<code>iOS 7.0(11A465)</code>到<code>iOS 10.2(14C92)</code>一共有50个build版本，公司的测试机是不会覆盖到这么变态的完整度的。</li>
<li>同一个版本，有时候会给iPhone和iPad、甚至6和6s提供不同build的固件。</li>
<li>某些版本是某些机子的特供版，例如<code>10.0.3(14A551)</code>是iPhone 7和 7 Plus独有的，这就更加大了收集难度。</li>
<li>同一个iOS版本可能有多个build，例如<code>10.1(14B72)</code>和<code>10.1(14B72c)</code>，苹果觉得更新幅度太小，就没有提升版本号。</li>
<li>除了build号的区别，符号文件在不同CPU平台上也有区别，意味着来自4s(<code>armv7</code>)和6s(<code>arm64</code>)的符号文件，即便build号是一样的，也无法通用。所以50个build号又要翻倍，达到了88个，所以精确来说我只是收集了（63/88）的进度。幸运的是，<code>arm64</code>机型的系统库里附带了<code>armv7s</code>。</li>
</ul>
<p>规则好厉害的收集游戏啊。收集品其实还有稀有度的区别，其中最厉害的应该是<code>10.0</code>，这是iPhone 7和7 Plus独有的出厂系统，而且没有固件可以下载，因此即便有iPhone 7也不能通过刷机来得到<code>10.0</code>。</p>
<p>其实我一直很奇怪为什么很少见到开发者抱怨找不到系统符号文件，从而召集大家进行收集并分享，猜测可能的原因是：</p>
<ul>
<li>懒。遇到无法符号化的问题，没有去解决。</li>
<li>有些公司可能很早就开始对crash日志自动符号化了，因此很早就开始收集符号文件。只要一直跟着苹果的每一个版本升级，收集起来还是挺简单的。而这些资源，开发者并不会注意到可以共享出来。</li>
<li>crash收集和符号化使用的是第三方服务，第三方平台会帮助符号化系统库。</li>
</ul>
<p>但是我找了一下，没有找到一家明确声明了能够符号化所有系统库的第三方平台。从腾讯的Bugly论坛里也能发现，有些系统方法并没有符号化出来，系统库是缺失的。（<strong>update</strong>：找到了一个国外的平台，在<a href="http://stackoverflow.com/questions/12058901/ios-system-symbol-symbolication-service" target="_blank" rel="external">stack overflow</a>上说能符号化所有版本的系统库，但是是收费服务，我也没有测试）</p>
<p>在公司小组里，大部分时候都是我来分析crash日志，所以当遇到缺少系统符号文件的情况，就会十分无奈。很多时候，没有符号化的crash日志根本无法提供有用信息。</p>
<h2 id="系统符号文件下载地址"><a href="#系统符号文件下载地址" class="headerlink" title="系统符号文件下载地址"></a>系统符号文件下载地址</h2><h3 id="暴力收集"><a href="#暴力收集" class="headerlink" title="暴力收集"></a>暴力收集</h3><p>收集不全一直让我很不爽。之前搜刮了组内的测试机，只收集到了有限的几个（感谢无私提供iPhone 7让我刷机降级的同事）。终于，这周末特意跑去了一趟二手机市场寻找旧版本的设备来拷贝，总算是收集得完整了一点，但是也花了我121块钱。</p>
<p>心情总算愉悦了。</p>
<p>其中大部分都是拷贝自<code>arm64</code>设备的，<code>armv7</code>的符号文件收集我是放弃了。有哪位大侠有兴趣把这个游戏玩通关的吗？还有 tvOS 和 watchOS的符号，我也放弃了。<br>(update:又花了些时间从Xcode的SDK和固件里提取了<code>armv7s</code>和<code>armv7</code>的固件，现在只剩下几个<code>arm64</code>的版本了)。</p>
<p>整理了一下传到了网盘，地址见下方，有需要的去下载吧。</p>
<h3 id="目前还缺少的符号文件"><a href="#目前还缺少的符号文件" class="headerlink" title="目前还缺少的符号文件"></a>目前还缺少的符号文件</h3><p>如果有人有这几个符号文件的，恳请你分享！</p>
<p>分享可以直接贴下载地址，也可以提交到这个github项目<a href="https://github.com/Zuikyo/iOS-System-Symbols" target="_blank" rel="external">iOS-System-Symbols</a>。如果我得到了新的符号文件，也会在这个项目里更新。</p>
<table>
<thead>
<tr>
<th>缺失符号的版本</th>
<th>缺失的CPU版本</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>10.0(14A346)</td>
<td>arm64</td>
<td>iPhone 7 和 7 Plus独占，出厂自带系统</td>
</tr>
<tr>
<td>9.3.2(13F72)</td>
<td>arm64</td>
<td>iPad Pro 9.7寸独占，修复了变砖的问题</td>
</tr>
<tr>
<td>9.3(13E237)</td>
<td>arm64</td>
<td>5s, iPad Air 和 iPad mini2独占，修复了不能激活的问题</td>
</tr>
<tr>
<td>9.3(13E234)</td>
<td>arm64</td>
<td>6s, 6s Plus 和 iPad Pro 9.7寸 独占</td>
</tr>
<tr>
<td>8.1.1 (12B435)</td>
<td>arm64</td>
<td>5s, iPad Air 和 iPad mini2 独占</td>
</tr>
<tr>
<td>8.0.1(12A402)</td>
<td>arm64</td>
<td><code>8.0.1</code>有导致变砖的bug，发布后很快就停止推送了</td>
</tr>
<tr>
<td>7.1.2 (11D257)</td>
<td>arm64</td>
<td></td>
</tr>
<tr>
<td>7.0.2(11A501)</td>
<td>arm64</td>
<td></td>
</tr>
<tr>
<td>7.0.1(11A470a)</td>
<td>arm64</td>
<td>5s 独占</td>
</tr>
</tbody>
</table>
<p>注意，arm64，armv7s，armv7版本的文件都是在同一个文件里的（例如<code>/Symbols/System/Library/Frameworks/UIKit.framework/UIKit</code>），Xcode在拷贝armv7的符号文件时，如果<code>iOS DeviceSupport</code>目录里已经有<code>arm64</code>或<code>armv7s</code>的符号文件，则会自动进行合并。因此如果你要分享一个<code>armv7</code>版本的符号文件，请先把arm64等其他版本的拷贝到<code>/Users/zhangweike/Library/Developer/Xcode/iOS DeviceSupport/</code>里，然后再用Xcode进行合并后再压缩分享。</p>
<h3 id="网盘下载地址"><a href="#网盘下载地址" class="headerlink" title="网盘下载地址"></a><a name="wang-pan"></a>网盘下载地址</h3><p><strong>网盘链接: <a href="https://pan.baidu.com/s/1nvfi4g5" target="_blank" rel="external">https://pan.baidu.com/s/1nvfi4g5</a> 密码: <code>79m8</code></strong></p>
<p>如果是在国外，可以用Google Driver：<br><a href="https://drive.google.com/drive/folders/0B-0LZDbSzubRaUdMdTJQc1ZzMUU?usp=sharing" target="_blank" rel="external">google drive分享(7.0.3-9.2)</a><br>,<br><a href="https://drive.google.com/drive/folders/0B5oBYvBG2NS7aDVTR1JzX2JXaFE?usp=sharing" target="_blank" rel="external">google drive分享(9.2.1-10.2)</a></p>
<p>如果我得到了新的符号文件，会在这个项目里更新：<a href="https://github.com/Zuikyo/iOS-System-Symbols" target="_blank" rel="external">iOS-System-Symbols</a>。</p>
<p>我把里面的那几个<code>dyld_shared_cache_xxxx</code>大文件单独拿出来了，目的是减小压缩包大小。如果只是符号化的话，用不到这几个文件，只是在真机调试的时候才需要。</p>
<h3 id="符号文件版本列表"><a href="#符号文件版本列表" class="headerlink" title="符号文件版本列表"></a>符号文件版本列表</h3><p>这些是我已经收集到的符号文件，包括了对应的CPU信息。iOS10系统开始不支持<code>armv7</code>的机器。但是iOS9以下还是支持<code>armv7</code>的，这里很多都缺失了<code>armv7</code>。</p>
<p>查看是否带有对应CPU架构的符号文件的方式：到<code>10.2 (14C92)/Symbols/System/Library/Caches/com.apple.dyld</code>这样的目录下，会有对应的<code>dyld_shared_cache_arm64</code>，<code>dyld_shared_cache_armv7s</code>，<code>dyld_shared_cache_armv7</code>文件，如果缺失了，就说明对应的CPU架构符号文件还不存在。（经过试验，这几个大文件并不影响符号化，只是在真机调试的时候才有用，因此如果嫌太占用空间，可以删去）。</p>
<table>
<thead>
<tr>
<th>版本</th>
<th>已收集到的CPU版本</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>10.2 (14C92)</td>
<td>arm64,armv7s</td>
<td></td>
</tr>
<tr>
<td>10.1.1 (14B150)</td>
<td>arm64,armv7s</td>
<td></td>
</tr>
<tr>
<td>10.1.1 (14B100)</td>
<td>arm64,armv7s</td>
<td></td>
</tr>
<tr>
<td>10.1 (14B72c)</td>
<td>arm64,armv7s</td>
<td></td>
</tr>
<tr>
<td>10.1 (14B72)</td>
<td>arm64,armv7s</td>
<td></td>
</tr>
<tr>
<td>10.0.3 (14A551)</td>
<td>arm64,armv7s</td>
<td></td>
</tr>
<tr>
<td>10.0.2 (14A456)</td>
<td>arm64,armv7s</td>
<td></td>
</tr>
<tr>
<td>10.0.1 (14A403)</td>
<td>arm64,armv7s</td>
<td></td>
</tr>
<tr>
<td><strong>10.0(14A346)</strong></td>
<td><strong>none</strong></td>
<td>iPhone 7 和 7 Plus独占，出厂自带系统</td>
</tr>
<tr>
<td>9.3.5 (13G36)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>9.3.4 (13G35)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>9.3.3 (13G34)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td><strong>9.3.2(13F72)</strong></td>
<td><strong>none</strong></td>
<td>iPad Pro 9.7寸独占，修复了变砖的问题</td>
</tr>
<tr>
<td>9.3.2 (13F69)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>9.3.1 (13E238)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>9.3(13E237)</td>
<td>armv7s,armv7</td>
<td>5s和更旧机型独占，修复了不能激活的问题</td>
</tr>
<tr>
<td>9.3(13E236)</td>
<td>armv7</td>
<td>iPad2独占，修复了不能激活的问题</td>
</tr>
<tr>
<td><strong>9.3(13E234)</strong></td>
<td><strong>none</strong></td>
<td>6s, 6s Plus and iPad Pro 9.7寸独占</td>
</tr>
<tr>
<td>9.3 (13E233)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>9.2.1 (13D20)</td>
<td>arm64,armv7s</td>
<td>iPhone 6 和更新的机型独占</td>
</tr>
<tr>
<td>9.2.1 (13D15)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>9.2 (13C75)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>9.1 (13B143)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>9.0.2(13A452)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>9.0.1(13A404)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>9.0 (13A344)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>8.4.1 (12H321)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>8.4 (12H143)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>8.3 (12F70)</td>
<td>arm64,armv7s,armv7</td>
<td>iPhone独占</td>
</tr>
<tr>
<td>8.3 (12F69)</td>
<td>arm64,armv7s,armv7</td>
<td>iPad独占</td>
</tr>
<tr>
<td>8.2 (12D508)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>8.1.3 (12B466)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>8.1.2 (12B440)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>8.1.1 (12B436)</td>
<td>arm64,armv7s</td>
<td>iPhone 6 和更新的机型独占</td>
</tr>
<tr>
<td>8.1.1 (12B435)</td>
<td>armv7s,armv7</td>
<td>5s和更旧机型独占</td>
</tr>
<tr>
<td>8.1 (12B411)</td>
<td>arm64,armv7s,armv7</td>
<td>iPhone独占</td>
</tr>
<tr>
<td>8.1 (12B410)</td>
<td>arm64,armv7s,armv7</td>
<td>iPad独占</td>
</tr>
<tr>
<td>8.0.2 (12A405)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>8.0.1(12A402)</td>
<td>armv7s,armv7</td>
<td><code>8.0.1</code>有导致变砖的bug，发布后很快就停止推送了</td>
</tr>
<tr>
<td>8.0 (12A366)</td>
<td>arm64,armv7s</td>
<td>6 Plus独占</td>
</tr>
<tr>
<td>8.0 (12A365)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>7.1.2 (11D257)</td>
<td>armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>7.1.1 (11D201)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>7.1 (11D167)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>7.0.6 (11B651)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>7.0.4 (11B554a)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>7.0.3 (11B511)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>7.0.2(11A501)</td>
<td>armv7s,armv7</td>
<td></td>
</tr>
<tr>
<td>7.0.1(11A470a)</td>
<td>armv7s</td>
<td>5s 和 5c 独占</td>
</tr>
<tr>
<td>7.0(11A465)</td>
<td>arm64,armv7s,armv7</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="机型对应CPU架构"><a href="#机型对应CPU架构" class="headerlink" title="机型对应CPU架构"></a>机型对应CPU架构</h3><table>
<thead>
<tr>
<th>CPU</th>
<th>机型</th>
</tr>
</thead>
<tbody>
<tr>
<td>armv6</td>
<td>iPhone, iPhone2, iPhone3G, iPod Touch 1 and 2</td>
</tr>
<tr>
<td>armv7</td>
<td>iPhone3GS, iPhone4, iPhone4S，iPad, iPad2, iPad3(The New iPad), iPad mini，iPod Touch 3G, iPod Touch4, iPod Touch5</td>
</tr>
<tr>
<td>armv7s</td>
<td>iPhone5, iPhone5C, iPad4(iPad with Retina Display)</td>
</tr>
<tr>
<td>arm64</td>
<td>iPhone5S, iPad Air, iPad mini2(iPad mini with Retina Display), iPhone6, iPhone6s, iPhone7, iPhone7s and any new device in the future</td>
</tr>
</tbody>
</table>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>最后再次呼吁一下，如果谁有上面缺失的符号文件，就请共享一下吧。虽然只是做一点微小的工作，但是能够有很大帮助。</p>
<p>不觉得填满上面那个列表会很爽吗？</p>
<h3 id="额外提示"><a href="#额外提示" class="headerlink" title="额外提示"></a>额外提示</h3><p>其实这些符号文件就是真机上的系统库，包括了完整的系统库二进制文件。有时候要反编译某些系统framework，但是模拟器SDK里没有对应的framework（比如只有真机上才有的<code>CoreMotion.framework</code>），就可以在这些真机上的系统库里找到了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.jianshu.com/p/11710e7ab661" target="_blank" rel="external">http://www.jianshu.com/p/11710e7ab661</a></li>
<li><a href="http://wufawei.com/2014/03/symbolicating-ios-crash-logs/" target="_blank" rel="external">符号化iOS Crash文件的3种方法</a></li>
<li><a href="https://en.wikipedia.org/wiki/IOS_SDK" target="_blank" rel="external">iOS SDK</a></li>
<li><a href="https://en.wikipedia.org/wiki/IOS_version_history#iOS_10" target="_blank" rel="external">iOS version history</a></li>
<li><a href="https://forums.developer.apple.com/thread/3380" target="_blank" rel="external">No symbols for paired Apple Watch</a></li>
<li><a href="http://crash.163.com/#news/!newsId=31" target="_blank" rel="external">聊聊从iOS固件提取系统库符号</a></li>
<li><a href="http://stackoverflow.com/questions/14941773/xcode-software-image-for-user-ios-in-order-to-symbolicate-ios-calls" target="_blank" rel="external">Xcode software image for user iOS in order to symbolicate iOS calls</a></li>
<li><a href="http://stackoverflow.com/a/28408052/6380485" target="_blank" rel="external">Missing iOS symbols at “~/Library/Developer/Xcode/iOS DeviceSupport”</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你有过分析iOS崩溃日志的经验，一定经常看到日志里出现很多&lt;code&gt;&amp;lt;redacted&amp;gt;&lt;/code&gt;的字段。这篇文章就是帮助开发者将这些字段符号化为对应的系统库方法名。&lt;/p&gt;
&lt;p&gt;如果你已经掌握了这方面的知识，就直接去下面的&lt;a href=&quot;#wan
    
    </summary>
    
      <category term="调试技巧" scheme="http://yoursite.com/categories/%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/"/>
    
      <category term="crash分析" scheme="http://yoursite.com/categories/%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/crash%E5%88%86%E6%9E%90/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>约束冲突调试工具：解决iOS7调试难题</title>
    <link href="http://yoursite.com/2016/12/13/%E7%BA%A6%E6%9D%9F%E5%86%B2%E7%AA%81%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2016/12/13/约束冲突调试工具/</id>
    <published>2016-12-13T13:43:29.000Z</published>
    <updated>2017-05-03T08:35:22.900Z</updated>
    
    <content type="html"><![CDATA[<p><em>功能</em>：</p>
<ul>
<li>在非调试模式下，获取出错的具体约束。</li>
<li>监测约束冲突，并获取出错的view和viewController。</li>
<li>监测iOS7上layoutSubViews导致的crash问题</li>
</ul>
<h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><h3 id="iOS7对Auto-Layout的支持问题"><a href="#iOS7对Auto-Layout的支持问题" class="headerlink" title="iOS7对Auto Layout的支持问题"></a>iOS7对Auto Layout的支持问题</h3><ul>
<li>iOS7的约束有一些奇怪的bug，对Auto Layout支持并不完美。</li>
<li>在出现约束冲突时，系统会尝试修复约束。iOS7和iOS8的修复结果有可能不一样。</li>
<li>如果view的<code>layoutSubviews</code>里没有调用<code>[super layoutSubviews]</code>，那么在往这个view上添加子view时，在iOS7以下会crash。例如<code>UITableView</code>，<code>UITableViewCell</code>。</li>
</ul>
<h3 id="iOS7的调试问题"><a href="#iOS7的调试问题" class="headerlink" title="iOS7的调试问题"></a>iOS7的调试问题</h3><ul>
<li>Xcode7虽然不能使用iOS7模拟器调试，但是还能使用iOS7真机调试。而Xcode8已经连iOS7的真机调试都不支持了。</li>
<li>Xcode8中编辑过的xib文件在Xcode7上会有兼容性问题，需要手动删除xib中的<code>&lt;capability name=&quot;documents saved in the Xcode 8 format&quot; minToolsVersion=&quot;8.0&quot;/&gt;</code>这一行才能在Xcode7上编译。如果要继续使用Xcode7调试，就需要修改这些xib，十分麻烦。</li>
<li>内网开发时，无法进行真机调试，如果要用模拟器调试，需要另一台低版本的Mac OSX系统的机子以安装Xcode6，同时也会遇到Xcode的兼容性问题，因此遇到iOS7的约束问题十分麻烦，如果没有环境的话只能靠猜。</li>
<li>约束冲突导致的crash往往在堆栈上无法得到有用的信息，因为是在系统库里crash，无法直接看出是哪个界面的约束出错。如果是在Xcode里调试，还能使用llvm的内存命令进行调试，但是在真机上就没办法了。</li>
</ul>
<h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>如果app能用代码监测到约束冲突，就可以在非调试模式下捕获到有用的信息，帮助快速定位问题。<br>当发生约束冲突时，控制台会输出这样的提示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">**Unable to simultaneously satisfy constraints.**</div><div class="line">    Probably at least one of the constraints in the following list is one you don&apos;t want. Try this: (1) look at each constraint and try to figure out which you don&apos;t expect; (2) find the code that added the unwanted constraint or constraints and fix it. (Note: If you&apos;re seeing NSAutoresizingMaskLayoutConstraints that you don&apos;t understand, refer to the documentation for the UIView property translatesAutoresizingMaskIntoConstraints)</div><div class="line">(</div><div class="line">    &quot;&lt;NSLayoutConstraint:0x7fc82d3e18a0 H:[UIView:0x7fc82aba1210(768)]&gt;&quot;,</div><div class="line">    &quot;&lt;NSLayoutConstraint:0x7fc82d6369e0 H:[UIView:0x7fc82aba1210]-(0)-|   (Names: &apos;|&apos;:UIView:0x7fc82d6b9f80 )&gt;&quot;,</div><div class="line">    &quot;&lt;NSLayoutConstraint:0x7fc82d636a30 H:|-(0)-[UIView:0x7fc82aba1210]   (Names: &apos;|&apos;:UIView:0x7fc82d6b9f80 )&gt;&quot;,</div><div class="line">    &quot;&lt;NSLayoutConstraint:0x7fc82d3e7fd0 &apos;UIView-Encapsulated-Layout-Width&apos; H:[UIView:0x7fc82d6b9f80(50)]&gt;&quot;</div><div class="line">)</div><div class="line"></div><div class="line">Will attempt to recover by breaking constraint</div><div class="line">&lt;NSLayoutConstraint:0x7fc82d3e18a0 H:[UIView:0x7fc82aba1210(768)]&gt;</div><div class="line"></div><div class="line">Make a symbolic breakpoint at UIViewAlertForUnsatisfiableConstraints to catch this in the debugger.</div><div class="line">The methods in the UIConstraintBasedLayoutDebugging category on UIView listed in &lt;UIKit/UIView.h&gt; may also be helpful.</div></pre></td></tr></table></figure>
<p>提示我们在<code>UIViewAlertForUnsatisfiableConstraints</code>上打断点调试。<br>这是一个检测到出错约束时，进行处理的C函数。上面那串控制台的log就是在这个函数里输出的。</p>
<p>于是可以尝试用method swizzling替换系统库的方法，记录出现冲突时的信息。<br>监测iOS7的crash问题也是同理。</p>
<h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><h3 id="获取UIView"><a href="#获取UIView" class="headerlink" title="获取UIView"></a>获取UIView</h3><p>runtime无法替换私有C函数，而调用栈里<code>NSISEngine</code>的那几个方法都没附带什么有用的信息，于是用hopper反编译<code>UIKit.framework</code>，找到使用<code>UIViewAlertForUnsatisfiableConstraints</code>的地方，是<code>-[UIView engine:willBreakConstraint:dueToMutuallyExclusiveConstraints:]</code>。</p>
<p>这个方法附带了出错约束的信息，也可以获取到冲突所在的UIView，于是也能通过UIView获取对应的viewController。接下来只要hook这个方法就可以了。</p>
<h3 id="获取view-controller"><a href="#获取view-controller" class="headerlink" title="获取view controller"></a>获取view controller</h3><p>获取view对应的view controller的方法有两种。</p>
<ul>
<li>使用<code>UIView</code>的私有API:<code>_viewDelegate</code>。</li>
<li>使用<code>UIResponder</code>的<code>nextResponder</code>：</li>
</ul>
<p>&gt;<br>The UIResponder class does not store or set the next responder automatically, instead returning nil by default. Subclasses must override this method to set the next responder. <strong>UIView implements this method by returning the UIViewController object that manages it (if it has one) or its superview (if it doesn’t)</strong>; UIViewController implements the method by returning its view’s superview; UIWindow returns the application object, and UIApplication returns nil.<br>&gt;</p>
<p>参考:<a href="http://stackoverflow.com/questions/1372977/given-a-view-how-do-i-get-its-viewcontroller" target="_blank" rel="external">Given a view, how do I get its viewController?</a></p>
<p>我选择了第二种方式。</p>
<h3 id="监测iOS7约束导致的crash"><a href="#监测iOS7约束导致的crash" class="headerlink" title="监测iOS7约束导致的crash"></a>监测iOS7约束导致的crash</h3><p>当你在实现自定义view的<code>layoutSubviews</code>方法时，记住：</p>
<ul>
<li>调用<code>[super layoutSubviews]</code></li>
<li>不要在<code>layoutSubviews</code>里增加约束</li>
</ul>
<p>如果不遵守这两条，当你向这个view上增加子view时，在iOS6和iOS7上会crash，控制台会输出提示：<code>&#39;Auto Layout still required after executing - layoutSubviews..&#39;</code> 。iOS8开始则不会crash。</p>
<p>某些系统控件，例如<code>UITableView</code>，<code>UITableViewCell</code>没有调用<code>[super layoutSubviews]</code>，所以在iOS6和iOS7上不能在它们上面增加子view，除非你用method swizlling修复它们的<code>layoutSubviews</code>方法。</p>
<p>经过反编译分析，<code>&#39;Auto Layout still required after executing - layoutSubviews..&#39;</code>发生在<code>UIView</code>的<code>layoutSublayersOfLayer:</code>里，发生错误之前会用<code>-[UIView _wantsWarningForMissingSuperLayoutSubviews]</code>来监测是否调用了<code>[super layoutSubviews]</code>，如果没有则抛出异常。<br>因此只需要hook<code>_wantsWarningForMissingSuperLayoutSubviews</code>就可以了。</p>
<h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p>设置监听方式如下，返回约束冲突所在的view，viewController，系统尝试打破的约束，目前所有的约束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">[ZIKConstraintsGuard monitorUnsatisfiableConstraintWithHandler:^(UIView *view, UIViewController *viewController, NSLayoutConstraint *constraintToBreak, NSArray&lt;NSLayoutConstraint *&gt; *currentConstraints) &#123;</div><div class="line">    NSLog(@&quot;检测到约束冲突！&quot;);</div><div class="line">    NSString *className = NSStringFromClass([viewController class]);</div><div class="line">    if ([className hasPrefix:@&quot;UI&quot;] &amp;&amp; ![className isEqualToString:@&quot;UIApplication&quot;]) &#123;</div><div class="line">    	  //使用某些系统控件时会出现约束冲突，例如UIAlertController</div><div class="line">        NSLog(@&quot;ignore conflict in UIKit:%@&quot;,viewController);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    NSLog(@&quot;冲突所在的viewController:\n%@ \nview:\n%@&quot;,viewController,view);</div><div class="line">    //使用recursiveDescription来打印view的层级，注意这是private API</div><div class="line">    NSLog(@&quot;view hierarchy:\n%@&quot;,[view valueForKeyPath:@&quot;recursiveDescription&quot;]);</div><div class="line">    NSLog(@&quot;目前所有的约束:\n%@&quot;,currentConstraints);</div><div class="line">    NSLog(@&quot;系统尝试打破的约束:\n%@&quot;,constraintToBreak);</div><div class="line">    </div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>打印结果如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">检测到约束冲突！</div><div class="line"></div><div class="line">冲突所在的viewController:</div><div class="line">&lt;MyViewController: 0x100201ba0&gt; </div><div class="line">view:</div><div class="line">&lt;UIView: 0x10020cbb0; frame = (0 0; 375 667); autoresize = W+H; gestureRecognizers = &lt;NSArray: 0x170242b50&gt;; layer = &lt;UIWindowLayer: 0x17002b240&gt;&gt;</div><div class="line"></div><div class="line">view hierarchy:</div><div class="line"></div><div class="line">&lt;UIView: 0x10020cbb0; frame = (0 0; 375 667); autoresize = W+H; gestureRecognizers = &lt;NSArray: 0x170242b50&gt;; layer = &lt;UIWindowLayer: 0x17002b240&gt;&gt;</div><div class="line">   | &lt;UIView: 0x10020fd00; frame = (0 0; 375 667); autoresize = W+H; layer = &lt;CALayer: 0x17002b780&gt;&gt;</div><div class="line">   |    | &lt;_UILayoutGuide: 0x1002100a0; frame = (0 0; 0 0); hidden = YES; layer = &lt;CALayer: 0x17002b820&gt;&gt;</div><div class="line">   |    | &lt;_UILayoutGuide: 0x100210650; frame = (0 0; 0 0); hidden = YES; layer = &lt;CALayer: 0x17002b8e0&gt;&gt;</div><div class="line">   |    | &lt;UITableView: 0x10081cc00; frame = (100 100; 100 100); clipsToBounds = YES; gestureRecognizers = &lt;NSArray: 0x170243e70&gt;; layer = &lt;CALayer: 0x17002bf20&gt;; contentOffset: &#123;0, 0&#125;; contentSize: &#123;0, 0&#125;&gt;</div><div class="line">   |    |    | &lt;UITableViewWrapperView: 0x10080fe00; frame = (0 0; 100 100); gestureRecognizers = &lt;NSArray: 0x1702441a0&gt;; layer = &lt;CALayer: 0x17002bf80&gt;; contentOffset: &#123;0, 0&#125;; contentSize: &#123;100, 100&#125;&gt;</div><div class="line"></div><div class="line">目前所有的约束:</div><div class="line">(</div><div class="line">    &quot;&lt;NSLayoutConstraint:0x17008a500 UITableView:0x10081cc00.top == UITableView:0x10081cc00.top + 10   (active)&gt;&quot;</div><div class="line">)</div><div class="line"></div><div class="line">系统尝试打破的约束:</div><div class="line">&lt;NSLayoutConstraint:0x17008a500 UITableView:0x10081cc00.top == UITableView:0x10081cc00.top + 10   (active)&gt;</div></pre></td></tr></table></figure>
<p>这样就能根据记录到的内存地址，准确地找到是哪个界面的哪个控件的约束出错了，即便在iOS7上crash，也能在crash之前记录到错误信息。</p>
<h2 id="需要注意的问题"><a href="#需要注意的问题" class="headerlink" title="需要注意的问题"></a>需要注意的问题</h2><ul>
<li>某些系统控件本身存在约束冲突的问题，例如在使用<code>UIAlertController</code>的时候。目前是在检测到冲突时，再检测viewController的类型前缀，如果是<code>UI</code>前缀则忽略。</li>
<li>同一个约束冲突有时候会有多次回调。这些回调来自处理auto layout的不同阶段，例如添加重复约束时、<code>addSubview</code>时，<code>layoutSubLayer</code>时等。</li>
</ul>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>工具地址在此：<a href="https://github.com/Zuikyo/ZIKConstraintsGuard" target="_blank" rel="external">ZIKConstraintsGuard</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;功能&lt;/em&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在非调试模式下，获取出错的具体约束。&lt;/li&gt;
&lt;li&gt;监测约束冲突，并获取出错的view和viewController。&lt;/li&gt;
&lt;li&gt;监测iOS7上layoutSubViews导致的crash问题&lt;/li&gt;
&lt;/u
    
    </summary>
    
      <category term="调试技巧" scheme="http://yoursite.com/categories/%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>@inerface的11条规范写法</title>
    <link href="http://yoursite.com/2016/12/07/interface%E7%9A%84%E8%A7%84%E8%8C%83%E5%86%99%E6%B3%95/"/>
    <id>http://yoursite.com/2016/12/07/interface的规范写法/</id>
    <published>2016-12-07T00:55:29.000Z</published>
    <updated>2017-05-24T18:00:55.540Z</updated>
    
    <content type="html"><![CDATA[<p>总结一些interface声明时的规范，相关宏的介绍，定义方法时有用的修饰符，编写注释的规范，最终写出一个合格的头文件。</p>
<ul>
<li><a href="#readwrite">1.读写权限</a><ul>
<li><a href="#readwrite-1">1.1实例变量的@public,@protected,@private关键字</a></li>
<li><a href="#readwrite-2">1.2属性的readonly,readwrite关键字</a></li>
</ul>
</li>
<li><a href="#forward-declaration">2.前向声明</a></li>
<li><a href="#private">3.只暴露必要的接口和实现</a><ul>
<li><a href="#private-1">3.1不要暴露任何只在类内部使用的私有方法</a></li>
<li><a href="#private-2">3.2不要在头文件里声明类内部遵循的protocol</a></li>
</ul>
</li>
<li><a href="#nullability">4.nullability说明</a></li>
<li><a href="#enum">5.定义枚举</a><ul>
<li><a href="#enum-1">5.1 NS_ENUM</a></li>
<li><a href="#enum-2">5.2 NS_OPTIONS</a></li>
<li><a href="#enum-3">5.3 字符串枚举</a></li>
</ul>
</li>
<li><a href="#extern">6.使用extern向外部提供只读常量</a></li>
<li><a href="#protected">7.向子类和category提供父类的私有属性</a></li>
<li><a href="#designated-initializer">8.标明designated initializer</a></li>
<li><a href="#version-control">9.API版本控制</a><ul>
<li><a href="#version-control-1">9.1 available</a></li>
<li><a href="#version-control-2">9.2 unavailable</a></li>
<li><a href="#version-control-3">9.3 deprecated</a></li>
</ul>
</li>
<li><a href="#keywords">10.额外的修饰符</a><ul>
<li><a href="#keywords-1">10.1泛型</a></li>
<li><a href="#keywords-2">10.2 NS_REQUIRES_SUPER</a></li>
<li><a href="#keywords-3">10.3 NS_NOESCAPE</a></li>
</ul>
</li>
<li><a href="#comment">11.写注释</a><ul>
<li><a href="#comment-1">11.1单行注释</a></li>
<li><a href="#comment-2">11.2多行注释</a></li>
<li><a href="#comment-3">11.3枚举注释</a></li>
<li><a href="#comment-4">11.4几个注释约定</a></li>
</ul>
</li>
</ul>
<hr>
<h2 id="1-读写权限"><a href="#1-读写权限" class="headerlink" title="1.读写权限"></a><a name="readwrite"></a>1.读写权限</h2><p>.h文件里的声明是用于暴露给外部的接口，而类内部的私有方法、私有属性和实例变量，应该放到.m文件的interface extension里。</p>
<h3 id="1-1-实例变量的-public-protected-private关键字"><a href="#1-1-实例变量的-public-protected-private关键字" class="headerlink" title="1.1 实例变量的@public,@protected,@private关键字"></a><a name="readwrite-1"></a>1.1 实例变量的@public,@protected,@private关键字</h3><p>这3个关键字用于修饰实例变量，不能用于修饰属性。当错误地使用了实例变量时，Xcode会报错提示。</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>@private</td>
<td>作用范围只能在自身类</td>
</tr>
<tr>
<td>@protected</td>
<td>作用范围在自身类和继承自己的子类，什么都不写，默认是此属性。</td>
</tr>
<tr>
<td>@public</td>
<td>作用范围最大，在任何地方。</td>
</tr>
</tbody>
</table>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//SearchManager.h</div><div class="line">@interface SearchManager : NSObject &#123;</div><div class="line">    @public    NSInteger *state;</div><div class="line">    @public    NSInteger *timeout;</div><div class="line">    @protected id *searchAPI;</div><div class="line">    @private   id _privateIvar;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>由于会暴露私有变量，并且没有@property的一些高级关键字，很少在头文件里声明实例变量。优先使用@property。</p>
<h3 id="1-2-属性的readonly-readwrite关键字"><a href="#1-2-属性的readonly-readwrite关键字" class="headerlink" title="1.2 属性的readonly,readwrite关键字"></a><a name="readwrite-2"></a>1.2 属性的readonly,readwrite关键字</h3><p>头文件中的属性是用于描述这个对象的一系列特性集合。<br>声明@property时，在.h里使用readonly，让外部只有读的权限，在.m里使用readwrite，使内部拥有读写权限。</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//SearchManager.h</div><div class="line">@interface SearchManager : NSObject</div><div class="line">@property (nonatomic, readonly) NSInteger * state;</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//SearchManager.m</div><div class="line">@interface SearchManager : NSObject</div><div class="line">@property (nonatomic, readwrite) NSInteger * state;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h2 id="2-前向声明"><a href="#2-前向声明" class="headerlink" title="2.前向声明"></a><a name="forward-declaration"></a>2.前向声明</h2><p>当在@interface的接口里用到了其他类，不要在.h里直接导入类的头文件，这样会让使用此头文件的地方也导入这些不必要的其他头文件。正确的做法是使用关键字<code>@class</code>进行前向声明。当然，如果是继承了父类，还是需要import父类的头文件。<br>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//SearchManager.h</div><div class="line">#import &quot;SearchManagerBase.h&quot;//导入父类的头文件</div><div class="line"></div><div class="line">@class LocationModel;//前向声明LocationModel类</div><div class="line"></div><div class="line">typedef void(^LocationSearchCompletionHandler)(LocationModel *location, NSError *error);</div><div class="line">@interface LocationSearchManager : SearchManagerBase</div><div class="line">- (void)searchLocationWithKeyword:(NSString *)keyword completionHandler:(LocationSearchCompletionHandler)completionHandler;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>使用@class会告诉编译器有这么一个类存在，但是现在并不关心这个类的具体实现，等到调用者在.m里使用的时候再import这个类即可。使用@class和@protocol分别声明一个类和一个protocol。<br>使用前向引用的原因有两个：</p>
<ul>
<li>提升编译效率。<br>如果import了<code>LocationModel.h</code>，那么当<code>LocationModel.h</code>的内容发生变化时，所有import了<code>LocationModel.h</code>的地方都需要重新编译。如果.m引用了<code>SearchManager.h</code>，但是并没有使用<code>LocationModel</code>，就会增加不必要的编译，降低开发效率。</li>
<li>解决交叉引用的问题。<br>如果类A的头文件import了B，类B的头文件import了A，这样在编译时会报错：“can not find interface declaration”，这是因为Objective-C不允许交叉引用。</li>
</ul>
<h2 id="3-只暴露必要的接口和实现"><a href="#3-只暴露必要的接口和实现" class="headerlink" title="3.只暴露必要的接口和实现"></a><a name="private"></a>3.只暴露必要的接口和实现</h2><h3 id="3-1不要暴露任何只在类内部使用的私有方法"><a href="#3-1不要暴露任何只在类内部使用的私有方法" class="headerlink" title="3.1不要暴露任何只在类内部使用的私有方法"></a><a name="private-1"></a>3.1不要暴露任何只在类内部使用的私有方法</h3><p>头文件里只声明那些给外部使用的公开方法，并且在设计时需要考虑到可测试性，遵循单一职责。<br>私有方法只定义在类内部，并且为了进行区别，建议在私有方法前加上前缀，例如<code>- (void)p_myPrivateMethod</code>。<br>由于Apple在它的编码规范里声明了，Apple公司拥有下划线的方法前缀，就像它拥有<code>NS</code>,<code>UI</code>这些类名前缀一样，因此不建议我们的私有方法直接使用下划线作为前缀。否则，当你在继承Cocoa Touch的类时，有可能会覆盖父类的私有方法，造成难以调试的错误。</p>
<h3 id="3-2不要在头文件里声明类内部遵循的protocol"><a href="#3-2不要在头文件里声明类内部遵循的protocol" class="headerlink" title="3.2不要在头文件里声明类内部遵循的protocol"></a><a name="private-2"></a>3.2不要在头文件里声明类内部遵循的protocol</h3><p><strong>错误</strong>的示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//SearchManager.h</div><div class="line">@interface SearchManager : NSObject&lt;NSCoding, UITableViewDelegate&gt;</div><div class="line">@property (nonatomic, readonly) NSInteger * state;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p><code>UITableViewDelegate</code>是类内部使用时遵循的protocol，没有必要暴露给外部，因此应该放到.m文件里。<br>而<code>NSCoding</code>则描述了类的特性，用于告诉外部本类可以使用归档，因此应该放在头文件里。</p>
<h2 id="4-nullability说明"><a href="#4-nullability说明" class="headerlink" title="4.nullability说明"></a><a name="nullability"></a>4.nullability说明</h2><p>在声明时，可以使用下列关键字描述对象是否可以为nil。</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>nullable</td>
<td>可空，用于描述objc对象</td>
</tr>
<tr>
<td>nonnull</td>
<td>不可空，用于描述objc对象</td>
</tr>
<tr>
<td>null_unspecified</td>
<td>不确定，用于描述objc对象</td>
</tr>
<tr>
<td>null_resettable</td>
<td>set可空，get不为空。仅用于property</td>
</tr>
<tr>
<td>_Nullable</td>
<td>可空，用于描述C指针和block</td>
</tr>
<tr>
<td>_Nonnull</td>
<td>不可空，用于描述C指针和block</td>
</tr>
<tr>
<td>_Null_unspecified</td>
<td>不确定，用于描述C指针和block</td>
</tr>
</tbody>
</table>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//SearchManager.h</div><div class="line">#import &quot;SearchManagerBase.h&quot;</div><div class="line">@class LocationModel;</div><div class="line"></div><div class="line">typedef void(^LocationSearchCompletionHandler)(LocationModel *_Nullable location, NSError *_Nullable error);</div><div class="line">@interface LocationSearchManager : SearchManagerBase</div><div class="line">- (void)searchLocationWithKeyword:(nonnull NSString *)keyword completionHandler:(LocationSearchCompletionHandler _Nonnull)completionHandler;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>如果向一个使用nonnull修饰的值赋空，编译器会给出警告。<br>在开发时，大部分时候使用的都是nonnull，因此Apple提供了一对宏<code>NS_ASSUME_NONNULL_BEGIN</code>和<code>NS_ASSUME_NONNULL_END</code>来进行快速修饰，写在两个宏之间的属性、方法，均会使用<code>nonnull</code>修饰。<br>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//LocationSearchManager.h</div><div class="line"></div><div class="line">#import &quot;SearchManagerBase.h&quot;</div><div class="line">@class LocationModel;</div><div class="line"></div><div class="line">NS_ASSUME_NONNULL_BEGIN</div><div class="line">typedef void(^LocationSearchCompletionHandler)(LocationModel *_Nullable location, NSError *_Nullable error);</div><div class="line">@interface LocationSearchManager : SearchManagerBase</div><div class="line">- (void)searchLocationWithKeyword:(NSString *)keyword completionHandler:(LocationSearchCompletionHandler)completionHandler;</div><div class="line">@end</div><div class="line">NS_ASSUME_NONNULL_END</div></pre></td></tr></table></figure>
<h2 id="5-定义枚举"><a href="#5-定义枚举" class="headerlink" title="5.定义枚举"></a><a name="enum"></a>5.定义枚举</h2><p>关于NS_ENUM和NS_OPTIONS的区别，参考<a href="http://nshipster.cn/ns_enum-ns_options/" target="_blank" rel="external">这里</a>。<br>简单来说，NS_OPTIONS提供了按位掩码的功能。</p>
<h3 id="5-1-NS-ENUM"><a href="#5-1-NS-ENUM" class="headerlink" title="5.1 NS_ENUM"></a><a name="enum-1"></a>5.1 NS_ENUM</h3><p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSInteger,SearchState) &#123;</div><div class="line">    SearchStateNotSearch,</div><div class="line">    SearchStateSearching,</div><div class="line">    SearchStateSearchFinished,</div><div class="line">    SearchStateSearchFailed</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="5-2-NS-OPTIONS"><a href="#5-2-NS-OPTIONS" class="headerlink" title="5.2 NS_OPTIONS"></a><a name="enum-2"></a>5.2 NS_OPTIONS</h3><p>示例代码，参考<code>NSKeyValueObserving.h</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">typedef NS_OPTIONS(NSUInteger, NSKeyValueObservingOptions) &#123;</div><div class="line">    NSKeyValueObservingOptionNew,</div><div class="line">    NSKeyValueObservingOptionOld,</div><div class="line">    NSKeyValueObservingOptionInitial,</div><div class="line">    NSKeyValueObservingOptionPrior</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在使用时就可以用<code>|</code>组合多个option：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[_webView addObserver:self forKeyPath:@&quot;title&quot; options:NSKeyValueObservingOptionInitial | NSKeyValueObservingOptionNew context:NULL];</div></pre></td></tr></table></figure></p>
<h3 id="5-3-字符串枚举"><a href="#5-3-字符串枚举" class="headerlink" title="5.3 字符串枚举"></a><a name="enum-3"></a>5.3 字符串枚举</h3><p>当使用字典作为参数传递，或者作为返回值时，往往难以直接提供字典的key，现在使用字符串枚举即可解决这个问题。<br>示例代码，参考<code>NSKeyValueObserving.h</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//使用NS_STRING_ENUM宏，定义了一个枚举类型</div><div class="line">typedef NSString * NSKeyValueChangeKey NS_STRING_ENUM;</div><div class="line"></div><div class="line">FOUNDATION_EXPORT NSKeyValueChangeKey const NSKeyValueChangeKindKey;</div><div class="line">FOUNDATION_EXPORT NSKeyValueChangeKey const NSKeyValueChangeNewKey;</div><div class="line">FOUNDATION_EXPORT NSKeyValueChangeKey const NSKeyValueChangeOldKey;</div><div class="line">FOUNDATION_EXPORT NSKeyValueChangeKey const NSKeyValueChangeIndexesKey;</div><div class="line">FOUNDATION_EXPORT NSKeyValueChangeKey const NSKeyValueChangeNotificationIsPriorKey;</div><div class="line"></div><div class="line">//使用泛型，声明了change参数用到的key，是在NSKeyValueChangeKey的枚举范围中</div><div class="line">- (void)observeValueForKeyPath:(nullable NSString *)keyPath ofObject:(nullable id)object change:(nullable NSDictionary&lt;NSKeyValueChangeKey, id&gt; *)change context:(nullable void *)context;</div></pre></td></tr></table></figure>
<h2 id="6-使用extern向外部提供只读常量"><a href="#6-使用extern向外部提供只读常量" class="headerlink" title="6.使用extern向外部提供只读常量"></a><a name="extern"></a>6.使用extern向外部提供只读常量</h2><p>这不关@interface的事，但是和头文件有关，就放在一起说明了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//SearchManager.h</div><div class="line">extern NSString *const SearchErrorDomain;</div><div class="line">extern NSInteger SearchDefaultTimeout;</div><div class="line"></div><div class="line">@interface SearchManager : NSObject</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//SearchManager.m</div><div class="line">NSString *const SearchErrorDomain = @&quot;SearchErrorDomain&quot;;</div><div class="line">const NSInteger SearchDefaultTimeout = 20;</div><div class="line"></div><div class="line">@interface SearchManager()</div><div class="line">@end</div></pre></td></tr></table></figure>
<h2 id="7-向子类和category提供父类的私有属性"><a href="#7-向子类和category提供父类的私有属性" class="headerlink" title="7.向子类和category提供父类的私有属性"></a><a name="protected"></a>7.向子类和category提供父类的私有属性</h2><p>由于类的头文件只存放那些暴露给外部的属性和方法，在遇到这些情况时，会遇到障碍：</p>
<ul>
<li>在子类里或者category里，想要使用父类定义在.m里的私有属性。</li>
<li>在类的头文件里属性是readonly，但是在子类或者category里，需要readwrite权限。<br>由于这些属性并没有暴露在头文件里，因此需要另外建立一个私有头文件，用来存放这些需要暴露给子类和category的属性。<br>可以参考Apple官方的<code>UIGestureRecognizerSubclass.h</code>。<br>示例代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//SearchManager.h</div><div class="line">@interface SearchManager : NSObject</div><div class="line">///外部访问，只有读权限</div><div class="line">@property (nonatomic, readonly) SearchState *state;</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//SearchManager.m</div><div class="line">@interface SearchManager()</div><div class="line">///内部使用，有读写权限</div><div class="line">@property (nonatomic, assign) SearchState *state;</div><div class="line">///只在内部使用的私有属性</div><div class="line">@property (nonatomic, strong) id searchAPI;</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">///暴露给子类和category的私有属性和私有方法</div><div class="line">//SearchManagerInternal.h</div><div class="line">///限制使用此头文件，防止被别的类误用</div><div class="line">#ifdef SEARCHMANAGER_PROTECTED_ACCESS</div><div class="line"></div><div class="line">#import &quot;SearchManager.h&quot;</div><div class="line">@interface SearchManager()</div><div class="line">///在internal.h里，重新声明为readwrite权限</div><div class="line">@property (nonatomic, readwrite, assgin) SearchState *state;</div><div class="line">///暴露私有属性</div><div class="line">@property (nonatomic, strong) id searchAPI;</div><div class="line">///暴露私有方法</div><div class="line">- (void)p_privateMethod;</div><div class="line">@end</div><div class="line"></div><div class="line">#else</div><div class="line">#error Only be included by SearchManager&apos;s subclass or category!</div><div class="line">#endif</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">///category的实现文件</div><div class="line">//SearchManager+Category.m</div><div class="line">///声明私有头文件的使用权限</div><div class="line">#define SEARCHMANAGER_PROTECTED_ACCESS</div><div class="line">///导入私有头文件</div><div class="line">#import &quot;SearchManagerInternal.h&quot;</div><div class="line"></div><div class="line">@implementation SearchManager(Category)</div><div class="line">- (void)categoryMethod &#123;</div><div class="line">    //拥有了读写权限</div><div class="line">    self.state = SearchStateSearching;</div><div class="line">    //可以访问私有属性</div><div class="line">    [self.searchAPI startSearch];</div><div class="line">    //可以使用私有方法</div><div class="line">    [self p_privateMethod];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p><code>SearchManagerInternal.h</code>其实也是公开的，其他类也能够导入并使用，只能在开发时进行约定。如果想要限制其他类导入，并且提示错误，<code>Internal.h</code>可以使用如下方式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#ifdef MYCLASS_PROTECTED_ACCESS</div><div class="line">//声明部分</div><div class="line">#else</div><div class="line">#error Only be included by MYCLASS&apos;s subclass or category!</div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>这样在别的类内意外地导入了<code>Internal.h</code>时就会产生编译警告，并且无法直接使用。缺点是需要在所有使用到<code>Internal.h</code>的地方都<code>#define MYCLASS_PROTECTED_ACCESS</code>。</p>
<h2 id="8-标明designated-initializer"><a href="#8-标明designated-initializer" class="headerlink" title="8.标明designated initializer"></a><a name="designated-initializer"></a>8.标明designated initializer</h2><p>指定初始化方法，即接收参数最多的那个初始化方法，其他初始化方法调用它即可，这样设计的目的是为了保证所有初始化方法都正确地初始化实例变量。<br>在方法后面加上<code>NS_DESIGNATED_INITIALIZER</code>宏即可。这样，当你子类化这个类时，在子类的初始化方法里如果没有正确地调用父类的designated initializer，编译器就会给出警告。<br>实例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@interface WKWebView : UIView</div><div class="line">- (instancetype)initWithFrame:(CGRect)frame configuration:(WKWebViewConfiguration *)configuration NS_DESIGNATED_INITIALIZER;</div><div class="line">- (nullable instancetype)initWithCoder:(NSCoder *)coder NS_DESIGNATED_INITIALIZER;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>关于designated initializer更详细的说明，参考:</p>
<ul>
<li><a href="https://github.com/100mango/zen/blob/master/Objective-C%20拾遗：designated%20initializer/Objective-C%20拾遗：designated%20initializer.md" target="_blank" rel="external">Objective-C 拾遗：designated initializer</a></li>
<li><a href="http://www.starfelix.com/blog/2014/04/13/zheng-que-bian-xie-designated-initializerde-ji-ge-yuan-ze/" target="_blank" rel="external">正确编写Designated Initializer的几个原则</a></li>
</ul>
<h2 id="9-API版本控制"><a href="#9-API版本控制" class="headerlink" title="9.API版本控制"></a><a name="version-control"></a>9.API版本控制</h2><p>在更新接口，或者开发framework时，需要标明版本信息，告诉使用者此接口的平台限制、操作系统版本、是否可用、是否已弃用等。<br>苹果给出了几个自带的宏用于标明版本，Xcode在检测到错误使用时会给出警告。只需要在方法名后面加上对应的宏即可。</p>
<h3 id="9-1-available"><a href="#9-1-available" class="headerlink" title="9.1 available"></a><a name="version-control-1"></a>9.1 available</h3><p>声明本接口最低支持的操作系统版本。<br>当你的接口使用了新系统的API，例如iOS8以上才有的UIAlertController，但是项目的deployment target却是iOS7时，需要标明此接口的版本信息，让使用者进行兼容。<br>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//SearchManager.h</div><div class="line"></div><div class="line">typedef NS_ENUM(NSInteger,SearchState) &#123;</div><div class="line">    SearchStateNotSearch,</div><div class="line">    SearchStateSearching,</div><div class="line">    SearchStateSearchFinished,</div><div class="line">    SearchStateSearchFailed</div><div class="line">&#125; NS_ENUM_AVAILABLE_IOS(2_0);//此枚举在iOS2.0以上才能使用</div><div class="line"></div><div class="line">NS_CLASS_AVAILABLE_IOS(2_0) //此类在iOS2.0以上才能使用</div><div class="line">@interface SearchManager : NSObject</div><div class="line">- (void)reSearch NS_AVAILABLE_IOS(5_0);//此方法在iOS5.0以上才能使用</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这几个宏有对应平台的版本，例如NS_AVAILABLE_MAC, NS_AVAILABLE_IOS, NS_AVAILABLE_IPHONE。<br>iOS10开始提供了新的available宏<code>API_AVAILABLE</code>，用来统一macOS、iOS、watchOS、tvOS几个平台。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">API_AVAILABLE(macos(10.10))</div><div class="line">API_AVAILABLE(macos(10.9), ios(10.0))</div><div class="line">API_AVAILABLE(macos(10.4), ios(8.0), watchos(2.0), tvos(10.0))</div></pre></td></tr></table></figure>
<h3 id="9-2-unavailable"><a href="#9-2-unavailable" class="headerlink" title="9.2 unavailable"></a><a name="version-control-2"></a>9.2 unavailable</h3><p>声明此接口不可用，大多数时候是用于声明所在平台限制。<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@interface SearchManager : NSObject</div><div class="line">- (void)searchInWatch NS_UNAVAILABLE;//不能用此接口</div><div class="line">- (void)searchInHostApp NS_EXTENSION_UNAVAILABLE_IOS;//extension里不能用此接口</div><div class="line">- (void)search __TVOS_PROHIBITED;//tvOS里不能用此接口，可修饰枚举，类，方法，参数</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>iOS10开始提供了新的unavailable宏<code>API_UNAVAILABLE</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">API_UNAVAILABLE(macos)</div><div class="line">API_UNAVAILABLE(watchos, tvos)</div></pre></td></tr></table></figure>
<h3 id="9-3-deprecated"><a href="#9-3-deprecated" class="headerlink" title="9.3 deprecated"></a><a name="version-control-3"></a>9.3 deprecated</h3><p>声明此接口已经被弃用，可以同时加注释注明替代接口。<br>当deployment target版本号设置成大于或等于方法被弃用的版本号时，Xcode会给出警告。<br>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//注明废弃类</div><div class="line">NS_CLASS_DEPRECATED_IOS(2_0, 9_0, &quot;UIAlertView is deprecated. Use UIAlertController with a preferredStyle of UIAlertControllerStyleAlert instead&quot;)</div><div class="line">@interface UIAlertView : UIView</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//注明废弃API</div><div class="line">@interface UIViewController : UIResponder</div><div class="line">- (void)viewDidUnload NS_DEPRECATED_IOS(3_0,6_0);</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//注明废弃枚举</div><div class="line">typedef NS_ENUM(NSInteger, UIStatusBarStyle) &#123;</div><div class="line">    UIStatusBarStyleDefault                                     = 0, // Dark content, for use on light backgrounds</div><div class="line">    UIStatusBarStyleLightContent     NS_ENUM_AVAILABLE_IOS(7_0) = 1, // Light content, for use on dark backgrounds</div><div class="line">    </div><div class="line">    UIStatusBarStyleBlackTranslucent NS_ENUM_DEPRECATED_IOS(2_0, 7_0, &quot;Use UIStatusBarStyleLightContent&quot;) = 1,</div><div class="line">    UIStatusBarStyleBlackOpaque      NS_ENUM_DEPRECATED_IOS(2_0, 7_0, &quot;Use UIStatusBarStyleLightContent&quot;) = 2,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>iOS10开始提供了新的deprecated宏<code>API_DEPRECATED</code>和<code>API_DEPRECATED_WITH_REPLACEMENT</code>。前者可以注明弃用原因，后者可以注明替代接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">API_DEPRECATED(&quot;No longer supported&quot;, macos(10.4, 10.8))</div><div class="line">API_DEPRECATED(&quot;No longer supported&quot;, macos(10.4, 10.8), ios(2.0, 3.0), watchos(2.0, 3.0), tvos(9.0, 10.0))</div><div class="line"></div><div class="line">API_DEPRECATED_WITH_REPLACEMENT(&quot;-setName:&quot;, tvos(10.0, 10.4), ios(9.0, 10.0))</div><div class="line">API_DEPRECATED_WITH_REPLACEMENT(&quot;SomeClassName&quot;, macos(10.4, 10.6), watchos(2.0, 3.0))</div></pre></td></tr></table></figure>
<h2 id="10-额外的修饰符"><a href="#10-额外的修饰符" class="headerlink" title="10.额外的修饰符"></a><a name"keywords"=""></a>10.额外的修饰符</h2><h3 id="10-1-泛型"><a href="#10-1-泛型" class="headerlink" title="10.1 泛型"></a><a name"keywords-1"=""></a>10.1 泛型</h3><p>在声明时，对集合类型的对象增加泛型的修饰，就可以声明集合内存储的数据类型。<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, strong) NSMutableArray&lt;NSString *&gt; *myArray;</div></pre></td></tr></table></figure>
<p>当你向<code>myArray</code>里放入一个非<code>NSString *</code>类型的对象时，编译器会给出警告。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property(nonatomic, strong) NSMutableArray&lt;__kindof UIView *&gt; * viewArray;</div></pre></td></tr></table></figure>
<p><code>_kindof</code>只限定了存储类型为<code>UIView</code>，因此也可以存储<code>UIView</code>的子类，例如<code>UIButton</code>。<br>更详细的介绍，参考:<a href="https://my.oschina.net/u/2340880/blog/514804" target="_blank" rel="external">Objective—C语言的新魅力——Nullability、泛型集合与类型延拓</a></p>
<h3 id="10-2-NS-REQUIRES-SUPER"><a href="#10-2-NS-REQUIRES-SUPER" class="headerlink" title="10.2 NS_REQUIRES_SUPER"></a><a name"keywords-2"=""></a>10.2 NS_REQUIRES_SUPER</h3><p><code>NS_REQUIRES_SUPER</code>宏用于声明子类在重载父类的这个方法时，需要调用父类的方法。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)viewWillAppear:(BOOL)animated NS_REQUIRES_SUPER;</div></pre></td></tr></table></figure>
<h3 id="10-3-NS-NOESCAPE"><a href="#10-3-NS-NOESCAPE" class="headerlink" title="10.3 NS_NOESCAPE"></a><a name"keywords-3"=""></a>10.3 NS_NOESCAPE</h3><p><code>NS_NOESCAPE</code>用于修饰方法中的block类型参数，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface NSArray: NSObject</div><div class="line">- (NSArray *)sortedArrayUsingComparator:(NSComparator NS_NOESCAPE)cmptr</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>作用是告诉编译器，<code>cmptr</code>这个block在<code>sortedArrayUsingComparator:</code>方法返回之前就会执行完毕，而不是被保存起来在之后的某个时候再执行。<br>类似于这样的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)performWithLock:(NS_NOESCAPE void (^)())block &#123;  // exposed as @noescape to Swift</div><div class="line">    [myLock lock];</div><div class="line">    block();</div><div class="line">    [myLock unlock];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译器知道之后，就会相应地做一些优化，例如去掉一些多余的对<code>self</code>的捕获、retain、release操作。因为block的存活范围仅限于本方法内，没有必要再在block内保留<code>self</code>了。<br>更详细的介绍，参考<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0012-add-noescape-to-public-library-api.md" target="_blank" rel="external">这里</a>。</p>
<h2 id="11-写注释"><a href="#11-写注释" class="headerlink" title="11.写注释"></a><a name="comment"></a>11.写注释</h2><p>头文件就是文档，需要让使用者快速知道这个类的作用。一个好的方法名可以让使用者快速理解，但大部分时候还是需要相应的注释。<br>写好格式化注释后，当光标停留在方法名和属性上时，在Xcode右侧的Quick Help栏里会出现注释内容，按住<code>option</code>并单击，也会弹出注释框。</p>
<h3 id="11-1单行注释"><a href="#11-1单行注释" class="headerlink" title="11.1单行注释"></a><a name="comment-1"></a>11.1单行注释</h3><p>直接在方法或者属性声明的上一行使用<code>///</code>，后面加注释，同时兼容Xcode和appleDoc。Xcode也支持<code>//!</code>，但是appleDoc不支持。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//SearchManagerBase.h</div><div class="line"></div><div class="line">///搜索manager的基类</div><div class="line">@interface SearchManagerBase : NSObject</div><div class="line">///搜索状态</div><div class="line">@property (nonatomic, readonly) NSInteger * state;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="11-2多行注释"><a href="#11-2多行注释" class="headerlink" title="11.2多行注释"></a><a name="comment-2"></a>11.2多行注释</h3><p>多行注释使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> 注释内容</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>Xcode8提供了快速生成格式化注释的快捷键：<code>option</code>+<code>command</code>+<code>/</code>。如果方法有参数，会自动添加@param关键字，用于描述对应的参数。<br>Apple提供了官方的headDoc语法，但是很多都已经在Xcode中失效了，而且有些关键字也和appleDoc不兼容。下面几种列举出了在Xcode中仍然有效的一些关键字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> 演示苹果headDoc的语法。这里可以写方法简介</div><div class="line"> </div><div class="line"> @brief 方法的简介(appleDoc不支持此关键字)</div><div class="line"> @discussion 方法的详细说明</div><div class="line"> </div><div class="line"> @code //示例代码(这个在Xcode里常用，但是appleDoc不支持此关键字)</div><div class="line"> UIView *view;</div><div class="line"> @endcode</div><div class="line"> </div><div class="line"> @bug       存在的bug的说明</div><div class="line"> @note      需要注意的提示</div><div class="line"> @warning   警告</div><div class="line"> @since     iOS7.0</div><div class="line"> @exception 方法会抛出的异常的说明</div><div class="line"> </div><div class="line"> @attention 注意，从这里开始往下的关键字，appleDoc都不支持</div><div class="line"> @author    编写者</div><div class="line"> @copyright 版权</div><div class="line"> @date      日期</div><div class="line"> @invariant 不变量</div><div class="line"> @post      后置条件</div><div class="line"> @pre       前置条件</div><div class="line"> @remarks   备注</div><div class="line"> @todo      todo text</div><div class="line"> @version   版本</div><div class="line"> */</div><div class="line">- (void)sampleMethod;</div></pre></td></tr></table></figure>
<p>在Xcode中，就会显示为这样：<br><img src="http://upload-images.jianshu.io/upload_images/1865432-dfc9a9b1de31ec47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="comment.png"></p>
<h3 id="11-3-枚举注释"><a href="#11-3-枚举注释" class="headerlink" title="11.3 枚举注释"></a><a name="comment-3"></a>11.3 枚举注释</h3><p>如果要给枚举注释，需要在每个枚举值前注释，按照如下格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">///搜索状态</div><div class="line">typedef NS_ENUM(NSInteger,SearchState) &#123;</div><div class="line">    ///没有开始搜索</div><div class="line">    SearchStateNotSearch,</div><div class="line">    ///搜索中</div><div class="line">    SearchStateSearching,</div><div class="line">    ///搜索结束</div><div class="line">    SearchStateSearchFinished,</div><div class="line">    ///搜索失败</div><div class="line">    SearchStateSearchFailed</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="11-4-几个注释约定"><a href="#11-4-几个注释约定" class="headerlink" title="11.4 几个注释约定"></a><a name="comment-4"></a>11.4 几个注释约定</h3><p>需要注释的内容：</p>
<ul>
<li>尽量为类添加描述，即便只有一句话。</li>
<li>标明某些参数和属性的默认值，比如超时time。</li>
<li>如果属性是KVO兼容的，即外部可以使用KVO监听此属性，则在属性注释里声明。</li>
<li>回调block参数需要说明回调所在的线程，避免让使用者在block里进行多余的线程判断。</li>
<li>如果需要的话，说明使用此API需要的前置条件，防止被错误地调用。</li>
<li>对使用了method swizzling的API进行统一形式的标注，方便遇到runtime的bug时进行排查。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://blog.sunnyxx.com/2014/04/13/objc_dig_interface/" target="_blank" rel="external">http://blog.sunnyxx.com/2014/04/13/objc_dig_interface/</a></li>
<li><a href="http://blog.sunnyxx.com/2015/06/12/objc-new-features-in-2015/" target="_blank" rel="external">http://blog.sunnyxx.com/2015/06/12/objc-new-features-in-2015/</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结一些interface声明时的规范，相关宏的介绍，定义方法时有用的修饰符，编写注释的规范，最终写出一个合格的头文件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#readwrite&quot;&gt;1.读写权限&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#readwrite-1&quot;&gt;
    
    </summary>
    
      <category term="代码规范" scheme="http://yoursite.com/categories/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>私有API-iOS10 openURL方法跳转到设置界面失效的解决方法</title>
    <link href="http://yoursite.com/2016/10/10/%E7%A7%81%E6%9C%89API-iOS10%20openURL%E6%96%B9%E6%B3%95%E8%B7%B3%E8%BD%AC%E5%88%B0%E8%AE%BE%E7%BD%AE%E7%95%8C%E9%9D%A2%E5%A4%B1%E6%95%88%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2016/10/10/私有API-iOS10 openURL方法跳转到设置界面失效的解决方法/</id>
    <published>2016-10-10T00:48:29.000Z</published>
    <updated>2017-05-03T08:23:01.770Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在iOS10之前，跳转到系统设置界面的某个指定界面的方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//打开定位服务界面</div><div class="line">NSURL*url=[NSURL URLWithString:@&quot;prefs:root=Privacy&amp;path=LOCATION&quot;];</div><div class="line">if ([[UIApplication sharedApplication] canOpenURL:url]) &#123;</div><div class="line">    [[UIApplication sharedApplication] openURL:url];</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>但是在iOS10上，调用canOpenURL:打开系统设置界面时控制台会报如下错误，并且无法跳转：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-canOpenURL: failed for URL: &quot;Prefs:root=Privacy&amp;path=LOCATION&quot; - error: &quot;The operation couldn’t be completed. (OSStatus error -10814.)&quot;</div></pre></td></tr></table></figure></p>
<p>原因是iOS10只允许如下方式跳转到设置里自己app的界面，对跳转到其他界面做了限制：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[UIApplication sharedApplication] openURL:[NSURL URLWithString:UIApplicationOpenSettingsURLString]];</div></pre></td></tr></table></figure></p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>可以使用<code>MobileCoreServices.framework</code>里的私有API:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (BOOL)openSensitiveURL:(id)arg1 withOptions:(id)arg2;</div></pre></td></tr></table></figure></p>
<p>头文件参考：<a href="https://github.com/JaviSoto/iOS10-Runtime-Headers/blob/master/Frameworks/MobileCoreServices.framework/LSApplicationWorkspace.h" target="_blank" rel="external">LSApplicationWorkspace.h</a><br>使用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//注意首字母改成了大写，prefs-&gt;Prefs</div><div class="line">NSURL*url=[NSURL URLWithString:@&quot;Prefs:root=Privacy&amp;path=LOCATION&quot;];</div><div class="line">Class LSApplicationWorkspace = NSClassFromString(@&quot;LSApplicationWorkspace&quot;);</div><div class="line">[[LSApplicationWorkspace performSelector:@selector(defaultWorkspace)] performSelector:@selector(openSensitiveURL:withOptions:) withObject:url withObject:nil];</div></pre></td></tr></table></figure></p>
<p><code>MobileCoreServices.framework</code>不是私有库，所以直接使用<code>performSelector:</code>即可调用私有API。</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li>iOS10的系统URLScheme改成了首字母大写，使用小写的方式会无法打开。</li>
<li>使用私有API的app无法通过App Store审核。你也可以尝试把私有类名和selector字符串混淆一下，绕过审核。例如<a href="http://blog.csdn.net/wenmingzheng/article/details/50475671" target="_blank" rel="external">这位仁兄</a>用ASCII混淆的方法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (UIView *)statusBarView &#123; </div><div class="line">    UIView *statusBar = nil; </div><div class="line">    NSData *data = [NSData dataWithBytes:(unsigned char [])&#123;0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x42, 0x61, 0x72&#125; length:9]; </div><div class="line">    NSString *key = [[NSString alloc] initWithData:data encoding:NSASCIIStringEncoding]; </div><div class="line">    id object = [UIApplication sharedApplication]; </div><div class="line">    if ([object respondsToSelector:NSSelectorFromString(key)]) &#123;</div><div class="line">        statusBar = [object valueForKey:key]; </div><div class="line">    &#125;</div><div class="line">    return statusBar; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不过，还是不建议使用私有API，因为它是不可靠的。也许某天苹果就把它移除了。</p>
<h4 id="update"><a href="#update" class="headerlink" title="update:"></a><em>update:</em></h4><ul>
<li>还有一步遗漏了，app需要添加一个<code>Prefs</code>的URL Schemes，即添加到<code>info.plist</code>的<code>LSApplicationQueriesSchemes</code>项中。</li>
</ul>
<h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><p><a href="http://stackoverflow.com/a/39102075/6380485" target="_blank" rel="external">http://stackoverflow.com/a/39102075/6380485</a><br><a href="https://www.zhihu.com/question/50635906/answer/125195317" target="_blank" rel="external">https://www.zhihu.com/question/50635906/answer/125195317</a><br><a href="https://github.com/cyanzhong/app-tutorials/blob/master/schemes.md" target="_blank" rel="external">iOS10系统URLScheme</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;在iOS10之前，跳转到系统设置界面的某个指定界面的方式如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;ta
    
    </summary>
    
      <category term="私有API" scheme="http://yoursite.com/categories/%E7%A7%81%E6%9C%89API/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
</feed>
